{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "f4bcd87c-d42b-3e06-b7bd-34d4a7518b34",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "63b65834-a55a-3b82-8b7a-07204466c8b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "3bd0dcf7-b391-3067-b185-f6ab2ff7f67a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "579a91ef-be13-3167-8139-1b70ee75fd5a",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b1f874b2-6fb4-3983-b3c1-6ec7d27d40bf",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6b4002af-03ac-3a2f-8926-7c16735b225d",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "faa790ff-69b4-3ae9-92be-8fe5b67629df",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7245961d-dff1-367d-a38d-25d08fd62538",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "84c55a99-1160-3fdd-b86c-ad7267b589aa",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d985e0f8-d6e8-3987-a846-a89c1fe1f989",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a657694a-5528-3733-9489-4ee0e9d3a06d",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "57ec42fc-213e-3a1a-946a-7162cf77d0a7",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6099f83e-921a-38d7-944b-efe7600ae996",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a011fa33-3231-3b34-afe3-62388aa312c3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "a011fa33-3231-3b34-afe3-62388aa312c3"
                ]
              }
            },
            {
              "id": "bb888cb9-7a60-3655-82c4-f374ff8e10b7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of non-secure HTTP protocol for network communication in a C++ program. This can expose the program to various security risks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the communication between the program and the server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure protocols such as HTTPS for network communication. HTTPS encrypts the data sent between the client and the server, making it difficult for an attacker to read or modify the data.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in the provided code is the use of the non-secure HTTP protocol in the web address \"http://half.sourceforge.net\". To fix this, replace the HTTP protocol with HTTPS, if the server supports it. \n\n```cpp\n// Vulnerable code\nstd::string url = \"http://half.sourceforge.net\";\n\n// Fixed code\nstd::string url = \"https://half.sourceforge.net\";\n```\n\n## Library Dependencies\n\nThe code example does not require any specific library dependencies to execute properly.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n\nPlease note that the provided links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "3d415c72-881c-3926-8e06-186bc46f1516",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "3d415c72-881c-3926-8e06-186bc46f1516"
                ]
              }
            },
            {
              "id": "55538980-194f-3552-b19c-8a9c643bfcb6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of non-secure HTTP protocol for network communication in a C++ program. This can expose the program to various security risks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the communication between the program and the server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure protocols such as HTTPS for network communication. HTTPS encrypts the data sent between the client and the server, making it difficult for an attacker to read or modify the data.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in the provided code is the use of the non-secure HTTP protocol in the web address \"http://half.sourceforge.net\". To fix this, replace the HTTP protocol with HTTPS, if the server supports it. \n\n```cpp\n// Vulnerable code\nstd::string url = \"http://half.sourceforge.net\";\n\n// Fixed code\nstd::string url = \"https://half.sourceforge.net\";\n```\n\n## Library Dependencies\n\nThe code example does not require any specific library dependencies to execute properly.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n\nPlease note that the provided links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "1bc94487-6dfb-35b1-a738-e03c4a33a29e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "1bc94487-6dfb-35b1-a738-e03c4a33a29e"
                ]
              }
            },
            {
              "id": "9f2a021d-10a1-3fcd-8ff8-e81cf087796f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "9f2a021d-10a1-3fcd-8ff8-e81cf087796f"
                ]
              }
            },
            {
              "id": "f4ca8137-257b-37e7-8a1b-86301a647d1e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "fa222a45-afb5-36bb-95fc-df45a8debc1b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "97ea52ce-c102-3600-9424-bb2e7420c6a8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "00c832fa-781c-3e87-8ae0-fd9e345661bd",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8707d7a8-dbda-3504-a630-bf781b406d6b",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3a24382c-6fb9-30c8-89a8-73a1c1a8045a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "011a25f0-7915-321e-8563-a42c138ee601",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "39719e99-873d-3500-b38a-fb17aac97137",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "264c4abe-7e6f-3acc-bc28-1c61407fc8ac",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "13d3dcb0-e633-3c89-b2ec-2b131a408c06",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e2464196-b54d-3045-9b57-7266f0cf8c45",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3676d032-d31e-3bd3-bc61-16db9caa85d0",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8a60286d-4e0c-3867-858f-d17175822cf1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "73e24196-f7c0-36a9-86e4-648486796697",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e2d5fe6e-43c8-3056-ad4e-2e17ad1d2133",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a9d9c2dc-255f-326a-9aa1-ce8495a1ab4b",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "33781bca-3742-3029-af23-863c8a54bf91",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflow, memory corruption, or other similar issues. The `memmove` function is one of these prohibited functions. It is used to copy a block of memory from one location to another and can lead to vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `memmove` such as `memcpy_s` or `memmove_s` which are part of the C11 standard. These functions include additional parameters that specify the maximum size of the destination buffer, which can help prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `memmove_s` or `memcpy_s`. Here is an example of how to do it:\n\n```cpp\n#include <string.h>\n\nvoid unsafe(char *src, char *dest, size_t n) {\n    memmove(dest, src, n);\n}\n\nvoid safe(char *src, char *dest, size_t n, size_t max) {\n    memmove_s(dest, max, src, n);\n}\n```\n\nIn this example, `memmove_s` is used instead of `memmove`. The `max` parameter specifies the maximum size of the destination buffer.\n\n## Library Dependencies\n\nThe `string.h` library is required for the `memmove` and `memmove_s` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2058c040-f779-3cf7-9d65-084cd929b437",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "f121f25f-42e8-35f9-8aab-6c53e48c140b",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "ca526359-696d-3550-8b11-c6d0bd37cd61",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflow, memory corruption, or other similar issues. The `memmove` function is one of these prohibited functions. It is used to copy a block of memory from one location to another and can lead to vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `memmove` such as `memcpy_s` or `memmove_s` which are part of the C11 standard. These functions include additional parameters that specify the maximum size of the destination buffer, which can help prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `memmove_s` or `memcpy_s`. Here is an example of how to do it:\n\n```cpp\n#include <string.h>\n\nvoid unsafe(char *src, char *dest, size_t n) {\n    memmove(dest, src, n);\n}\n\nvoid safe(char *src, char *dest, size_t n, size_t max) {\n    memmove_s(dest, max, src, n);\n}\n```\n\nIn this example, `memmove_s` is used instead of `memmove`. The `max` parameter specifies the maximum size of the destination buffer.\n\n## Library Dependencies\n\nThe `string.h` library is required for the `memmove` and `memmove_s` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "35932502-d5c6-39df-9adc-7b0590ef3eab",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. One such function is `alloca`.\n\nThe `alloca` function dynamically allocates memory on the stack. This can be dangerous because it can lead to stack overflow if the requested size is too large. Additionally, unlike `malloc`, the `alloca` function does not provide any mechanism to detect such errors. This can lead to unpredictable behavior or crashes.\n\n## Mitigation Advice\n\nAvoid using `alloca` function. Instead, use functions like `malloc` or `calloc` which allocate memory on the heap and provide error checking. If you need to use dynamic memory allocation, consider using C++ constructs like `new` and `delete` or smart pointers, which are safer and more flexible.\n\n## Source Code Fix Recommendation\n\nReplace `alloca` with `malloc` or `calloc`. For example, if you have the following code:\n\n```cpp\n#include <alloca.h>\n\nvoid function(size_t size) {\n    char* buffer = (char*) alloca(size);\n    // ...\n}\n```\n\nYou can replace it with:\n\n```cpp\n#include <stdlib.h>\n\nvoid function(size_t size) {\n    char* buffer = (char*) malloc(size);\n    if (buffer == NULL) {\n        // handle error\n    }\n    // ...\n    free(buffer);\n}\n```\n\n## Library Dependencies\n\nThe `alloca` function is declared in the `alloca.h` header file. The `malloc`, `calloc`, and `free` functions are declared in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "343454c2-3387-3561-b6ba-49d5352ec8fc",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d90fb2ad-e0a8-3b8e-985f-fab6a8caa31f",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "1d3d66a6-e959-3430-a7ac-a251c43af97d",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "81eb0c45-24d1-3930-a177-9e3797dbb15a",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7eab39bf-9c18-3c11-b60d-0ff51bb3aa70",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b0480fcd-b09a-3fd2-8145-b6a276f88e65",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dae71298-18fc-3f87-a46e-5ca84f790ca9",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7c856da8-1e08-3f63-beb9-06c96b2824a2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "97ff9085-198b-3b95-bd81-0ff26271ebd5",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "eeda3e42-7d8a-322a-ba65-1247ac06d83a",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8b91929d-fcd9-3c9c-b7e8-82b9ec94be0b",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "39e8afd6-ccc2-34d9-831a-4203debb96ff",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "aa25054f-301a-34a8-8f04-46f1782ef7e6",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "12240eb1-4ec1-35b5-b725-b8a915be3d40",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6f67176e-f6ce-30d4-a4cb-b6f029a8101f",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4c49039e-54dd-39e5-9a9e-75cee56a5690",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fa65ebe1-e965-308e-bb4b-7c15f05a2603",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ed49b0dc-27c4-3d4a-9d7a-90ff1111fd1c",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8bdf98f3-3765-3d0d-8d14-ddc39df178ba",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "db9e914b-5825-327e-a4d7-f74203e05526",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1d46ea14-f53c-31af-92a0-c12fd20a9fb4",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7a1b9856-e0eb-320e-997b-a13a8de80a12",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "64a04276-8c3d-3e92-ad5c-dba9807ec104",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "95e8293b-fc59-3e76-b49e-2655d280ea90",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "cc0b2f93-c2fd-3f65-bd3b-03b2edffc555",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "725c3ead-87b0-3080-bb80-6258edcd0001",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e80fbf39-1012-37f3-a2e6-c0cb8b6589ee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "2d6496ce-8375-3bf1-8a13-d9cf924390a2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "96957430-ac90-3d80-851b-51888b97dea3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "96957430-ac90-3d80-851b-51888b97dea3"
                ]
              }
            },
            {
              "id": "e65560a6-f9cd-3838-b659-e5aa6d0355da",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "516d5458-ef03-3006-ae8c-35daa1a0a268",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "39c3c578-409f-3a6f-89ad-9009e2dc89e4",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0a0f3296-a078-3ec6-bd3a-f8ff16b55342",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6680d9e3-8ea2-3a93-a749-e1686e692ef7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "034e0f37-b617-3f3b-b4ab-4f4ba8c9a368",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e92f9da9-dd66-376a-ab2f-b455cde63436",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "e92f9da9-dd66-376a-ab2f-b455cde63436"
                ]
              }
            },
            {
              "id": "08282e69-cb06-36f0-af21-c5ef89d83528",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e0c3adf1-534a-39e5-9bb6-ec29495650a5",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6a96b405-3662-3aee-bbc2-cb981085d9a1",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "076ad077-5a3b-3e0e-9ef3-161c7f573452",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a0636a6a-9fc4-33b3-af67-edd4ad18d920",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0440a437-85d5-3054-94b8-f061ee89264f",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dd966dd2-8711-3d23-ab3b-0398ff4519ea",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "414018d6-1d7d-3600-a5b1-281942e71a92",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "64b8b755-45bf-37ef-a814-4e47b011ed1d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "d90045bc-f037-305a-9d7f-794a07eb5b9f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "ab077fa8-f208-384b-996d-ee1bc4b048ab",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "76e93c0a-7054-39ca-b105-374641a78dd5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "bea50275-bf91-35f5-9d20-2a5f5e3ac6c2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "14ccfd3a-9b8d-3378-979d-0ee031f4e4a5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "783192ee-66ee-3105-b824-2789aae99359",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "36f1d284-de53-34cf-bef9-998caf7b8e5d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "67e52466-91ce-3aa0-ab73-8a6b3274c00a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or information disclosure. One such function is `sscanf`.\n\nThe `sscanf` function reads data from a string and stores them according to the parameter format into the locations pointed by the additional arguments. The potential problem with `sscanf` is that it does not perform bounds checking, and thus can cause buffer overflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `sscanf` and other unsafe C functions. Instead, use safer alternatives that perform bounds checking, such as `strncpy` for string copying, `snprintf` for string formatting, and `fgets` for reading lines of text.\n\nAlso, always validate and sanitize input data before processing it. Never trust user input blindly. Consider using libraries or frameworks that automatically handle these tasks.\n\n## Source Code Fix Recommendation\n\nInstead of `sscanf`, you can use `std::istringstream` from the C++ Standard Library for parsing strings. Here is an example:\n\n```cpp\n#include <sstream>\n#include <string>\n\nstd::string str = \"123 456\";\nint a, b;\n\nstd::istringstream iss(str);\niss >> a >> b;\n```\n\nIn this code, `std::istringstream` reads integers from the string `str` and stores them in `a` and `b`. If the string cannot be parsed as integers, `iss` will be in a fail state, and you can check this with `iss.fail()`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<sstream>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a44457c5-322e-34c9-a5e4-0eb015908a29",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured URL Vulnerability refers to the security risk associated with the use of unsecured URLs in a C++ program. This vulnerability can be exploited by attackers to perform malicious activities such as phishing, malware injection, and data theft. In the context of C++ programming, this vulnerability can occur when a program fetches data from an unsecured URL, potentially exposing the program to malicious content.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always use secure URLs (HTTPS) instead of HTTP. HTTPS ensures that the data transferred between the server and client is encrypted and secure.\n2. Validate and sanitize all URLs before using them in the program.\n3. Avoid hardcoding URLs in the program. Instead, use configuration files or environment variables to store URLs.\n4. Use libraries and functions that support secure connections.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in the provided URL is not clear as the URL is a homepage of a library. However, if we assume that the vulnerability is about fetching data from an unsecured URL, here is a general fix recommendation:\n\n```cpp\n// Before\nstd::string unsecured_url = \"http://eigen.tuxfamily.org\";\n// Fetch data from unsecured_url\n\n// After\nstd::string secured_url = \"https://eigen.tuxfamily.org\";\n// Fetch data from secured_url\n```\n\n## Library Dependencies\n\nThe code example does not provide any specific library dependencies. However, if you are using a library to fetch data from a URL, you might need libraries such as `libcurl` or `Boost.Asio`.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n- [CWE-598: Information Exposure Through Query Strings in URL](https://cwe.mitre.org/data/definitions/598.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "597f8468-7c7f-3ccd-b886-e98161e70098",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured URL Vulnerability refers to the security risk associated with the use of unsecured URLs in a C++ program. This vulnerability can be exploited by attackers to perform malicious activities such as phishing, malware injection, and data theft. In the context of C++ programming, this vulnerability can occur when a program fetches data from an unsecured URL, potentially exposing the program to malicious content.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always use secure URLs (HTTPS) instead of HTTP. HTTPS ensures that the data transferred between the server and client is encrypted and secure.\n2. Validate and sanitize all URLs before using them in the program.\n3. Avoid hardcoding URLs in the program. Instead, use configuration files or environment variables to store URLs.\n4. Use libraries and functions that support secure connections.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in the provided URL is not clear as the URL is a homepage of a library. However, if we assume that the vulnerability is about fetching data from an unsecured URL, here is a general fix recommendation:\n\n```cpp\n// Before\nstd::string unsecured_url = \"http://eigen.tuxfamily.org\";\n// Fetch data from unsecured_url\n\n// After\nstd::string secured_url = \"https://eigen.tuxfamily.org\";\n// Fetch data from secured_url\n```\n\n## Library Dependencies\n\nThe code example does not provide any specific library dependencies. However, if you are using a library to fetch data from a URL, you might need libraries such as `libcurl` or `Boost.Asio`.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n- [CWE-598: Information Exposure Through Query Strings in URL](https://cwe.mitre.org/data/definitions/598.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "b429276c-c32c-3f98-afce-603695b3c432",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or information disclosure. One such function is `sscanf`.\n\nThe `sscanf` function reads data from a string and stores them according to the parameter format into the locations pointed by the additional arguments. The potential problem with `sscanf` is that it does not perform bounds checking, and thus can cause buffer overflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `sscanf` and other unsafe C functions. Instead, use safer alternatives that perform bounds checking, such as `strncpy` for string copying, `snprintf` for string formatting, and `fgets` for reading lines of text.\n\nAlso, always validate and sanitize input data before processing it. Never trust user input blindly. Consider using libraries or frameworks that automatically handle these tasks.\n\n## Source Code Fix Recommendation\n\nInstead of `sscanf`, you can use `std::istringstream` from the C++ Standard Library for parsing strings. Here is an example:\n\n```cpp\n#include <sstream>\n#include <string>\n\nstd::string str = \"123 456\";\nint a, b;\n\nstd::istringstream iss(str);\niss >> a >> b;\n```\n\nIn this code, `std::istringstream` reads integers from the string `str` and stores them in `a` and `b`. If the string cannot be parsed as integers, `iss` will be in a fail state, and you can check this with `iss.fail()`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<sstream>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bf85f604-d246-36da-a767-ef536fa1c594",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or information disclosure. One such function is `sscanf`.\n\nThe `sscanf` function reads data from a string and stores them according to the parameter format into the locations pointed by the additional arguments. The potential problem with `sscanf` is that it does not perform bounds checking, and thus can cause buffer overflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `sscanf` and other unsafe C functions. Instead, use safer alternatives that perform bounds checking, such as `strncpy` for string copying, `snprintf` for string formatting, and `fgets` for reading lines of text.\n\nAlso, always validate and sanitize input data before processing it. Never trust user input blindly. Consider using libraries or frameworks that automatically handle these tasks.\n\n## Source Code Fix Recommendation\n\nInstead of `sscanf`, you can use `std::istringstream` from the C++ Standard Library for parsing strings. Here is an example:\n\n```cpp\n#include <sstream>\n#include <string>\n\nstd::string str = \"123 456\";\nint a, b;\n\nstd::istringstream iss(str);\niss >> a >> b;\n```\n\nIn this code, `std::istringstream` reads integers from the string `str` and stores them in `a` and `b`. If the string cannot be parsed as integers, `iss` will be in a fail state, and you can check this with `iss.fail()`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<sstream>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c77cd837-3623-32ca-a6dd-750d3cd36b0c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function in question is `atof`.\n\nThe `atof` function converts a string to a double. It does not check for overflow or underflow, and it does not report any errors. This can lead to unexpected behavior if the string cannot be represented as a double.\n\n## Mitigation Advice\n\nAvoid using the `atof` function. Instead, use safer alternatives such as `strtod` or `sscanf`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atof` function with `strtod` or `sscanf`. Here is an example of how to use `strtod`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char* str = \"123.45\";\nchar* endptr;\nerrno = 0; // To distinguish success/failure after call\ndouble val = strtod(str, &endptr);\n\n// Check for various possible errors\nif ((errno == ERANGE && (val == HUGE_VALF || val == HUGE_VALL)) || (errno != 0 && val == 0)) {\n    perror(\"strtod\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == str) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\n// If we got here, strtod() successfully parsed a number\nprintf(\"strtod() returned %f\\n\", val);\n\nif (*endptr != '\\0') // Not necessarily an error...\n    printf(\"Further characters after number: %s\\n\", endptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n- cstdio\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7d18cb29-690e-3dc2-9a3e-32fa8aa048b9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or information disclosure. One such function is `sscanf`.\n\nThe `sscanf` function reads data from a string and stores them according to the parameter format into the locations pointed by the additional arguments. The potential problem with `sscanf` is that it does not perform bounds checking, and thus can cause buffer overflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `sscanf` and other unsafe C functions. Instead, use safer alternatives that perform bounds checking, such as `strncpy` for string copying, `snprintf` for string formatting, and `fgets` for reading lines of text.\n\nAlso, always validate and sanitize input data before processing it. Never trust user input blindly. Consider using libraries or frameworks that automatically handle these tasks.\n\n## Source Code Fix Recommendation\n\nInstead of `sscanf`, you can use `std::istringstream` from the C++ Standard Library for parsing strings. Here is an example:\n\n```cpp\n#include <sstream>\n#include <string>\n\nstd::string str = \"123 456\";\nint a, b;\n\nstd::istringstream iss(str);\niss >> a >> b;\n```\n\nIn this code, `std::istringstream` reads integers from the string `str` and stores them in `a` and `b`. If the string cannot be parsed as integers, `iss` will be in a fail state, and you can check this with `iss.fail()`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<sstream>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "44afb113-db3a-3769-82d7-69ca3a9a191c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "a39a4d16-994f-344d-8072-c1b25d15b76b",
              "help": {
                "text": "",
                "markdown": "null\n\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c32e1388-7014-3347-8595-997bece32718",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that will be generated. This can be particularly dangerous in scenarios where these numbers are used for security-critical operations, such as generating encryption keys, random identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(3,3)`, which generates a 3x3 matrix of random floating-point numbers. However, the random number generator used by this function is not specified and may not be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic purposes, `std::random_device` is recommended, as it is designed to produce non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses `std::random_device` to generate the random numbers for the matrix:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nEigen::MatrixXf A(3,3);\nfor(int i=0; i<3; ++i)\n    for(int j=0; j<3; ++j)\n        A(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: for the random number generator\n- `Eigen/Dense`: for the `MatrixXf` class\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "de9d29a5-c4a0-36fd-8dd5-841f78f937e7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "bf92539b-f315-30c1-931b-29bfcc1a6042",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, potentially leading to a security breach.\n\nIn the given code snippet, `MatrixXi::Random(3,4)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf m = Eigen::MatrixXf::Zero(3,4).unaryExpr([&](float dummy){return dis(gen);});\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure random number generator. Then, `std::uniform_real_distribution` is used to generate random numbers in the range [-1, 1]. Finally, these random numbers are used to populate the matrix `m`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard C++ library for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is used for linear algebra operations.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "d352f1db-f775-3372-90a4-1e5b9cf45471",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict future values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\nIn the given code snippet, `MatrixXd::Random(3,3)` is a weak random number generator as it uses a non-cryptographic random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that can be used for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A = Eigen::MatrixXd::Zero(3,3).unaryExpr([&](double dummy){return dis(gen);});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "4cbe22e3-e728-3457-8c79-a4e0813724dc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nIn the provided code snippet, the `rand()` function is used, which is a weak random number generator. It generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic operations, you can use `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n#include <complex>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = std::complex<T> ( T( dis(gen) ), T( dis(gen) ) );\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `<complex>`: for the complex number operations\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "4cbe22e3-e728-3457-8c79-a4e0813724dc"
                ]
              }
            },
            {
              "id": "527eaa60-b063-38cc-9fb2-89b0a2d5b169",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. This can lead to a variety of security issues, such as predictability in password generation, session identifiers, or other security-critical values.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXd::Random(5,5)`, which generates a 5x5 matrix of random numbers. However, the randomness of these numbers is not guaranteed to be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a secure random number generator that is suitable for cryptographic use. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrixXd X = MatrixXd::NullaryExpr(5,5, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e3a76444-ab07-3897-a4d1-084684e0d2fb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nIn the provided code snippet, the `rand()` function is used, which is a weak random number generator. It generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic operations, you can use `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n#include <complex>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = std::complex<T> ( T( dis(gen) ), T( dis(gen) ) );\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `<complex>`: for the complex number operations\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "e3a76444-ab07-3897-a4d1-084684e0d2fb"
                ]
              }
            },
            {
              "id": "9447cf9d-7654-38c5-962b-5691c2ac66ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. This can lead to a variety of security issues, such as predictability in password generation, session identifiers, or other security-critical values.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXd::Random(5,5)`, which generates a 5x5 matrix of random numbers. However, the randomness of these numbers is not guaranteed to be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a secure random number generator that is suitable for cryptographic use. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrixXd X = MatrixXd::NullaryExpr(5,5, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "d418fc0b-09fc-3824-b854-ac155375cf5a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nIn the provided code snippet, the `rand()` function is used, which is a weak random number generator. It generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic operations, you can use `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n#include <complex>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = std::complex<T> ( T( dis(gen) ), T( dis(gen) ) );\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `<complex>`: for the complex number operations\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "d418fc0b-09fc-3824-b854-ac155375cf5a"
                ]
              }
            },
            {
              "id": "4fded670-4afd-30c7-b608-2b8c9b7ca3a9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nIn the provided code snippet, the `rand()` function is used, which is a weak random number generator. It generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic operations, you can use `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n#include <complex>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = std::complex<T> ( T( dis(gen) ), T( dis(gen) ) );\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `<complex>`: for the complex number operations\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "4fded670-4afd-30c7-b608-2b8c9b7ca3a9"
                ]
              }
            },
            {
              "id": "2af9ebd1-f815-31ba-8447-b4bff7e24365",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "13d94f0c-682f-37b1-8253-37e72e2407c7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of functions or methods that generate random numbers which are not suitable for security-critical operations. The `rand()` function, for example, is a weak random number generator because it produces predictable numbers and is not suitable for generating random numbers in a cryptographic context.\n\nThe line of code `vec[k] = T( rand() )/T(RAND_MAX) - T(.5)` is an example of this vulnerability. Here, `rand()` is used to generate a random number, which is then normalized to a range between -0.5 and 0.5. However, the `rand()` function is not a secure way to generate random numbers for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a secure random number generator that is suitable for cryptographic operations. In C++, you can use functions from the `<random>` library, such as `std::random_device` or `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `std::random_device`:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = dis(gen);\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "13d94f0c-682f-37b1-8253-37e72e2407c7"
                ]
              }
            },
            {
              "id": "fd59b561-ff2d-3a90-958b-8e82f7b55756",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of functions or methods that generate random numbers which are not suitable for security-critical operations. The `rand()` function, for example, is a weak random number generator because it produces predictable numbers and is not suitable for generating random numbers in a cryptographic context.\n\nThe line of code `vec[k] = T( rand() )/T(RAND_MAX) - T(.5)` is an example of this vulnerability. Here, `rand()` is used to generate a random number, which is then normalized to a range between -0.5 and 0.5. However, the `rand()` function is not a secure way to generate random numbers for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a secure random number generator that is suitable for cryptographic operations. In C++, you can use functions from the `<random>` library, such as `std::random_device` or `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `std::random_device`:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = dis(gen);\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "fd59b561-ff2d-3a90-958b-8e82f7b55756"
                ]
              }
            },
            {
              "id": "5ff775c3-543d-3fa5-9c65-1ceb1c27f40d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the system, leading to a variety of attacks such as brute force attacks, session prediction, and more.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix4d A;\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        A(i, j) = dis(gen);\n```\n\nIn this code, we use the Mersenne Twister algorithm (`std::mt19937`) as a random number generator, which is a widely used and robust random number generator suitable for cryptographic use. We also use `std::uniform_real_distribution<>` to generate a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "6fe7c369-a1a2-32c3-ad0a-b02ab91f3e18",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. This can lead to a variety of security issues, such as predictability in password generation, session identifiers, or other security-critical values.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXd::Random(5,5)`, which generates a 5x5 matrix of random numbers. However, the randomness of these numbers is not guaranteed to be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a secure random number generator that is suitable for cryptographic use. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrixXd X = MatrixXd::NullaryExpr(5,5, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "714bf76d-5a5b-3429-9e25-849a759ad327",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXcf::Random(2,2)`, which generates a 2x2 matrix of complex float numbers with random values. If this function uses a non-cryptographic or weak random number generator, it could lead to predictable outcomes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf a(2,2);\nfor (int i=0; i<2; ++i)\n    for (int j=0; j<2; ++j)\n        a(i,j) = std::complex<float>(dis(gen), dis(gen));\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure random number generator. `std::uniform_real_distribution<>` is used to generate random float numbers between -1 and 1, which are then used to create the complex float numbers for the matrix.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generators and distributions.\n- `<Eigen/Dense>`: for the `MatrixXcf` class.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "78f1867a-2c10-3292-9d02-2620d162fec5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, potentially leading to a security breach.\n\nIn the given code snippet, `MatrixXi::Random(3,4)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf m = Eigen::MatrixXf::Zero(3,4).unaryExpr([&](float dummy){return dis(gen);});\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure random number generator. Then, `std::uniform_real_distribution` is used to generate random numbers in the range [-1, 1]. Finally, these random numbers are used to populate the matrix `m`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard C++ library for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is used for linear algebra operations.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "f401c856-320f-35bd-b9dc-b479841bb85d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "91454575-edd8-3c7a-a5fc-8af75f943902",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the given code example, `MatrixXf::Random(5,3)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf A = Eigen::MatrixXf::Zero(5,3);\n\nfor(int i=0; i<A.rows(); ++i)\n    for(int j=0; j<A.cols(); ++j)\n        A(i,j) = dis(gen);\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used with a uniform real distribution to generate random numbers. This engine is seeded with a random device (`std::random_device`), which provides a source of non-deterministic random numbers.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "7c2b7708-e7f4-352c-ac5b-9cbe58a5cf2c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the generator.\n\nIn the given code example, `MatrixXd::Random(6,6)` is used to generate a 6x6 matrix of random numbers. However, the `Random()` function from the Eigen library is not cryptographically secure, making it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A(6,6);\nfor(int i=0; i<6; ++i)\n    for(int j=0; j<6; ++j)\n        A(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister generator `std::mt19937`, which is a cryptographically secure pseudorandom number generator. `std::uniform_real_distribution<>` is then used to generate random numbers in the range [-1, 1], which is the same range as `MatrixXd::Random()`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0c449cd9-8b70-3972-bed6-4ddf445882e5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\nIn the given code example, `MatrixXf::Random(4,4)` is used to generate a 4x4 matrix of random floating point numbers. However, the `Random` function in Eigen library is not cryptographically secure, which makes it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code example using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf X(4,4);\nfor(int i=0; i<4; ++i)\n    for(int j=0; j<4; ++j)\n        X(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`), and `std::uniform_real_distribution` is used to generate random floating point numbers between -1 and 1. These random numbers are then used to fill the matrix `X`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "7d986658-9dda-3b4e-91a2-9736fa4383fb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other similar attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides facilities to generate random numbers with high quality of randomness.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXcf::Random(4,4)`, you can use the `std::random_device` and `std::mt19937` from the `<random>` library to generate a matrix of random numbers. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf A(4, 4);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0ee3343a-3c18-34c0-80f0-7f3447a0dbc1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\nIn the given code example, `MatrixXf::Random(4,4)` is used to generate a 4x4 matrix of random floating point numbers. However, the `Random` function in Eigen library is not cryptographically secure, which makes it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code example using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf X(4,4);\nfor(int i=0; i<4; ++i)\n    for(int j=0; j<4; ++j)\n        X(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`), and `std::uniform_real_distribution` is used to generate random floating point numbers between -1 and 1. These random numbers are then used to fill the matrix `X`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "c3c96ce3-3521-3167-a7f7-7318e4e59a58",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\nIn the given code snippet, `MatrixXi::Random(4,6)` is a weak random number generator as it does not provide cryptographically secure random numbers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographically secure random number generator. In C++, you can use the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to use the `<random>` library to generate cryptographically secure random numbers:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nfor (int n=0; n<10; ++n)\n    std::cout << dis(gen) << ' ';\nstd::cout << '\\n';\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This library is used to generate random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0fb17a26-8830-3ab1-b665-25ea612d9b1f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the generator.\n\nIn the given code example, `MatrixXd::Random(6,6)` is used to generate a 6x6 matrix of random numbers. However, the `Random()` function from the Eigen library is not cryptographically secure, making it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A(6,6);\nfor(int i=0; i<6; ++i)\n    for(int j=0; j<6; ++j)\n        A(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister generator `std::mt19937`, which is a cryptographically secure pseudorandom number generator. `std::uniform_real_distribution<>` is then used to generate random numbers in the range [-1, 1], which is the same range as `MatrixXd::Random()`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "00b1f2a5-2444-3e5c-a2ce-99849cd4cf3d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "4be47059-21bd-3233-9816-58e00783422e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other similar attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides facilities to generate random numbers with high quality of randomness.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXcf::Random(4,4)`, you can use the `std::random_device` and `std::mt19937` from the `<random>` library to generate a matrix of random numbers. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf A(4, 4);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "3785b26f-4afb-3179-b50a-27d93d06f441",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\nIn the given code snippet, `MatrixXi::Random(4,6)` is a weak random number generator as it does not provide cryptographically secure random numbers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographically secure random number generator. In C++, you can use the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to use the `<random>` library to generate cryptographically secure random numbers:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nfor (int n=0; n<10; ++n)\n    std::cout << dis(gen) << ' ';\nstd::cout << '\\n';\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This library is used to generate random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "bdb083fc-006b-3351-8586-223120398812",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other similar attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides facilities to generate random numbers with high quality of randomness.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXcf::Random(4,4)`, you can use the `std::random_device` and `std::mt19937` from the `<random>` library to generate a matrix of random numbers. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf A(4, 4);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e15d867e-6093-386e-a1f8-210795c29e4e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the generator.\n\nIn the given code example, `MatrixXd::Random(6,6)` is used to generate a 6x6 matrix of random numbers. However, the `Random()` function from the Eigen library is not cryptographically secure, making it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A(6,6);\nfor(int i=0; i<6; ++i)\n    for(int j=0; j<6; ++j)\n        A(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister generator `std::mt19937`, which is a cryptographically secure pseudorandom number generator. `std::uniform_real_distribution<>` is then used to generate random numbers in the range [-1, 1], which is the same range as `MatrixXd::Random()`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a812ceda-ac2b-3a8d-86b3-bf5845f57074",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that the generator will produce. This can lead to serious security issues, especially in applications where the random numbers are used for security-critical operations such as generating encryption keys, random identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. If the underlying random number generator used by `MatrixXf::Random` is not cryptographically secure, this could lead to the aforementioned security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses the `std::random_device` class from the `<random>` library to generate random floating-point numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::MatrixXf A(4,4);\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        A(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: This is a standard C++ library that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "fa22f8e7-9067-344f-a6d8-b56508d785a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that will be generated. This can lead to a variety of security issues, such as the ability to predict session IDs, encryption keys, or other sensitive data.\n\nThe specific vulnerability sink in the provided code is the use of `Matrix4Xd::Random(4,5)`, which uses a non-cryptographic random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix4Xd M(4,5);\nfor(int i=0; i<M.rows(); ++i)\n    for(int j=0; j<M.cols(); ++j)\n        M(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "6df0f168-f792-3f79-beaf-bf92ac351b32",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable outputs and can be exploited by attackers to predict the sequence of random numbers, which can compromise the security of the application.\n\nIn the given code snippet, `b = VectorXf::Random(3)`, a non-cryptographic random number generator is used to generate a vector of random floating point numbers. This can be a potential security vulnerability if the generated random numbers are used in a security-sensitive context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::VectorXf b(3);\nfor (int i = 0; i < 3; ++i)\n    b(i) = dis(gen);\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used with a uniform real distribution to generate cryptographically secure random floating point numbers.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "d331582f-5ff7-3b7a-9d69-6ce43eb9f693",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable outputs and can be exploited by attackers to predict the sequence of random numbers, which can compromise the security of the application.\n\nIn the given code snippet, `Matrix3Xd::Random(3,5)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix3Xd M(3,5);\nfor(int i=0; i<M.size(); i++)\n    M(i) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: This is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: This is a standard C++ library that provides facilities to generate random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a24a5345-a860-32e6-9dbf-bc2bd5801cda",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict future values generated by the random number generator, leading to potential security risks.\n\nIn the given code snippet, `MatrixXf::Random(3, 2)` is used to generate a random matrix. However, the `Random()` function in Eigen library is not a cryptographic random number generator, and it may not provide sufficient randomness for security-sensitive operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographic random number generator that is designed to be unpredictable and resistant to attacks. In C++, you can use functions provided by libraries such as `<random>` or OpenSSL's `RAND_bytes()`.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to use `<random>` to generate a random matrix:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nEigen::MatrixXf A(3, 2);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = dis(gen);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "53d51183-2beb-3750-98b9-b0d118d2d29c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values, leading to a breach of security.\n\nIn the given code snippet, `MatrixXi::Random(2,3)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nEigen::MatrixXi m(2,3);\nfor(int i=0; i<2; ++i)\n    for(int j=0; j<3; ++j)\n        m(i,j) = dis(gen);\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used, which is a cryptographically secure random number generator. The `std::uniform_int_distribution<>` is used to generate random numbers in a specified range.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is used for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e5b5b358-0a2d-328e-896c-a6277b3c5138",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that the generator will produce. This can lead to serious security issues, especially in applications where the random numbers are used for security-critical operations such as generating encryption keys, random identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. If the underlying random number generator used by `MatrixXf::Random` is not cryptographically secure, this could lead to the aforementioned security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses the `std::random_device` class from the `<random>` library to generate random floating-point numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::MatrixXf A(4,4);\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        A(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: This is a standard C++ library that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "c76f7b2c-662c-35b8-833a-15889e017eb6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable outputs and can be exploited by attackers to predict the sequence of random numbers, which can compromise the security of the application.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. However, the random number generator used by this function may not be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf B = Eigen::MatrixXf::Zero(4,4);\n\nfor (int i = 0; i < B.rows(); ++i) {\n    for (int j = 0; j < B.cols(); ++j) {\n        B(i, j) = dis(gen);\n    }\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`), and `std::uniform_real_distribution` is used to generate random floating-point numbers in the range [-1, 1].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "098997c9-a126-3a89-839b-3628090fd608",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix4f X = Eigen::Matrix4f::NullaryExpr(4,4,[&](){return dis(gen);});\n```\n\nIn this code, we are using the Mersenne Twister engine (`std::mt19937`) seeded with a random device (`std::random_device`) to generate random numbers. The `std::uniform_real_distribution` is used to generate random floating-point numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "58d0b67b-2ba5-3f2a-b37c-645aa90c423e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\nIn the given code snippet, `MatrixXf::Random(2, 3)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf mat(2, 3);\nfor(int i=0; i<2; ++i)\n    for(int j=0; j<3; ++j)\n        mat(i,j) = dis(gen);\n```\n\nIn this code, a Mersenne Twister generator (`std::mt19937`) is used, which is a cryptographically secure random number generator. The `std::uniform_real_distribution` is used to generate random floating-point numbers between -1 and 1, similar to `MatrixXf::Random`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "06928318-f5f3-3e22-ae47-f7c35fd15023",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values, leading to a breach of security.\n\nIn the given code snippet, `MatrixXi::Random(2,3)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nEigen::MatrixXi m(2,3);\nfor(int i=0; i<2; ++i)\n    for(int j=0; j<3; ++j)\n        m(i,j) = dis(gen);\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used, which is a cryptographically secure random number generator. The `std::uniform_int_distribution<>` is used to generate random numbers in a specified range.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is used for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e45ede20-ba7d-3ade-83fb-5ffd95bd2f4b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `alloca()` is used, which is considered unsafe.\n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size of the allocation is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits via `longjmp()`.\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use functions that allocate memory on the heap, such as `malloc()`, `calloc()`, or `new` in C++. These functions do not have the same risks as `alloca()`. However, remember to free the memory allocated with `malloc()` or `calloc()` using `free()`, and the memory allocated with `new` using `delete`.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `new`:\n\n```cpp\nint* jpiv = new int[N];\n```\n\nRemember to free the memory when you're done with it:\n\n```cpp\ndelete[] jpiv;\n```\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "706de43f-f56f-3aef-8480-f4316bf81416",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, leading to a variety of security issues.\n\nIn the given code snippet, `MatrixXd::Random(3,2)` is a weak random number generator as it uses a non-cryptographic random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks, making them suitable for generating sensitive data such as encryption keys, random nonces, and other security-related numbers.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXd::Random(3,2)`, use a cryptographic random number generator. Here is an example using the `<random>` library in C++:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd B = Eigen::MatrixXd::Zero(3,2);\n\nfor(int i=0; i<B.size(); i++)\n{\n    B(i) = dis(gen);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "4b2a7cdd-cdeb-3eb1-b262-ef86e5f9ee76",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict future values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\nIn the given code snippet, `MatrixXd::Random(3,3)` is a weak random number generator as it uses a non-cryptographic random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that can be used for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A = Eigen::MatrixXd::Zero(3,3).unaryExpr([&](double dummy){return dis(gen);});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "ab4e11b4-c527-3070-b34d-f90bed0219c6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the given code example, `MatrixXd::Random(4,4)` is used to generate a 4x4 matrix of random numbers. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks, making them suitable for generating random numbers in a security context.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXd::Random(4,4)`, you can use a cryptographic library to generate random numbers. Here is an example using the OpenSSL library:\n\n```cpp\n#include <openssl/rand.h>\n\nMatrixXd X(4,4);\nfor(int i=0; i<4; i++)\n{\n    for(int j=0; j<4; j++)\n    {\n        unsigned char buffer[4];\n        RAND_bytes(buffer, 4);\n        int num = *reinterpret_cast<int*>(buffer);\n        X(i,j) = num;\n    }\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the OpenSSL library to execute properly.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0504c979-3e1f-38ab-abd3-5ff0137680c1",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `alloca` function is used, which is a potential source of vulnerability.\n\nThe `alloca` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca` returns. This can lead to stack overflow if the size of the allocation is too large, which can in turn lead to arbitrary code execution.\n\n## Mitigation Advice\n\nAvoid using the `alloca` function. Instead, use functions that allocate memory on the heap, such as `malloc`, `calloc`, or `new`. These functions do not have the risk of causing stack overflow. However, they require manual memory management, so be sure to free or delete the memory when you're done with it to avoid memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca` function with `new`:\n\n```cpp\nint* ipiv = new int[N];\n```\n\nDon't forget to delete the memory when you're done with it:\n\n```cpp\ndelete[] ipiv;\n```\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-121: Stack-based Buffer Overflow](https://cwe.mitre.org/data/definitions/121.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "161e81a7-40ad-3e46-9dea-f0b47d07fd99",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. This can lead to a variety of security issues, such as predictability in password generation, session identifiers, or other security-critical values.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXd::Random(5,5)`, which generates a 5x5 matrix of random numbers. However, the randomness of these numbers is not guaranteed to be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a secure random number generator that is suitable for cryptographic use. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrixXd X = MatrixXd::NullaryExpr(5,5, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "cf3fe8e2-62ce-3533-aef0-1774775e70c7",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `alloca` function is used, which is a potential source of vulnerability.\n\nThe `alloca` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca` returns. This can lead to stack overflow if the size of the allocation is too large, which can in turn lead to arbitrary code execution.\n\n## Mitigation Advice\n\nAvoid using the `alloca` function. Instead, use functions that allocate memory on the heap, such as `malloc`, `calloc`, or `new`. These functions do not have the risk of causing stack overflow. However, they require manual memory management, so be sure to free or delete the memory when you're done with it to avoid memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca` function with `new`:\n\n```cpp\nint* ipiv = new int[N];\n```\n\nDon't forget to delete the memory when you're done with it:\n\n```cpp\ndelete[] ipiv;\n```\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-121: Stack-based Buffer Overflow](https://cwe.mitre.org/data/definitions/121.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4dd2ee8c-1ff6-3a04-a73a-a67708c6157b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other similar attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides facilities to generate random numbers with high quality of randomness.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXcf::Random(4,4)`, you can use the `std::random_device` and `std::mt19937` from the `<random>` library to generate a matrix of random numbers. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf A(4, 4);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "14be3e3b-1561-3dcf-9674-f1cb7db4b6af",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 3724,
                  "startColumn": 9,
                  "endLine": 3724,
                  "endColumn": 17,
                  "charOffset": 163045,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "63b65834-a55a-3b82-8b7a-07204466c8b6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 3710,
                  "startColumn": 29,
                  "endLine": 3710,
                  "endColumn": 37,
                  "charOffset": 162574,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "3bd0dcf7-b391-3067-b185-f6ab2ff7f67a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 3728,
                  "startColumn": 9,
                  "endLine": 3728,
                  "endColumn": 17,
                  "charOffset": 163157,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "579a91ef-be13-3167-8139-1b70ee75fd5a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1878,
                  "startColumn": 2,
                  "endLine": 1878,
                  "endColumn": 32,
                  "charOffset": 85886,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(to, &from, sizeof(from)",
                    "rendered": {
                      "text": "memcpy(to, &from, sizeof(from)",
                      "markdown": "`memcpy(to, &from, sizeof(from)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85886,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(to, <size of to>,  &from,  sizeof(from)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b1f874b2-6fb4-3983-b3c1-6ec7d27d40bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1872,
                  "startColumn": 2,
                  "endLine": 1872,
                  "endColumn": 32,
                  "charOffset": 85493,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(to, &from, sizeof(from)",
                    "rendered": {
                      "text": "memcpy(to, &from, sizeof(from)",
                      "markdown": "`memcpy(to, &from, sizeof(from)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85493,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(to, <size of to>,  &from,  sizeof(from)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6b4002af-03ac-3a2f-8926-7c16735b225d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1915,
                  "startColumn": 2,
                  "endLine": 1915,
                  "endColumn": 32,
                  "charOffset": 88336,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(to, &from, sizeof(from)",
                    "rendered": {
                      "text": "memcpy(to, &from, sizeof(from)",
                      "markdown": "`memcpy(to, &from, sizeof(from)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 88336,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(to, <size of to>,  &from,  sizeof(from)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "faa790ff-69b4-3ae9-92be-8fe5b67629df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1909,
                  "startColumn": 2,
                  "endLine": 1909,
                  "endColumn": 32,
                  "charOffset": 87936,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(to, &from, sizeof(from)",
                    "rendered": {
                      "text": "memcpy(to, &from, sizeof(from)",
                      "markdown": "`memcpy(to, &from, sizeof(from)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 87936,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(to, <size of to>,  &from,  sizeof(from)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7245961d-dff1-367d-a38d-25d08fd62538",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1714,
                  "startColumn": 2,
                  "endLine": 1714,
                  "endColumn": 37,
                  "charOffset": 77772,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(&res, from, sizeof(Packet4c)",
                    "rendered": {
                      "text": "memcpy(&res, from, sizeof(Packet4c)",
                      "markdown": "`memcpy(&res, from, sizeof(Packet4c)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77772,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&res, <size of &res>,  from,  sizeof(Packet4c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "84c55a99-1160-3fdd-b86c-ad7267b589aa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1679,
                  "startColumn": 2,
                  "endLine": 1679,
                  "endColumn": 38,
                  "charOffset": 75784,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&res, from, sizeof(Packet4uc)",
                    "rendered": {
                      "text": "memcpy(&res, from, sizeof(Packet4uc)",
                      "markdown": "`memcpy(&res, from, sizeof(Packet4uc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75784,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&res, <size of &res>,  from,  sizeof(Packet4uc)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d985e0f8-d6e8-3987-a846-a89c1fe1f989",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1669,
                  "startColumn": 2,
                  "endLine": 1669,
                  "endColumn": 37,
                  "charOffset": 75373,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(&res, from, sizeof(Packet4c)",
                    "rendered": {
                      "text": "memcpy(&res, from, sizeof(Packet4c)",
                      "markdown": "`memcpy(&res, from, sizeof(Packet4c)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75373,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&res, <size of &res>,  from,  sizeof(Packet4c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a657694a-5528-3733-9489-4ee0e9d3a06d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1724,
                  "startColumn": 2,
                  "endLine": 1724,
                  "endColumn": 38,
                  "charOffset": 78190,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&res, from, sizeof(Packet4uc)",
                    "rendered": {
                      "text": "memcpy(&res, from, sizeof(Packet4uc)",
                      "markdown": "`memcpy(&res, from, sizeof(Packet4uc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 78190,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&res, <size of &res>,  from,  sizeof(Packet4uc)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "57ec42fc-213e-3a1a-946a-7162cf77d0a7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                },
                "region": {
                  "startLine": 2955,
                  "startColumn": 2,
                  "endLine": 2955,
                  "endColumn": 29,
                  "charOffset": 111454,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(tmp, &x, sizeof(tmp)",
                    "rendered": {
                      "text": "memcpy(tmp, &x, sizeof(tmp)",
                      "markdown": "`memcpy(tmp, &x, sizeof(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111454,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp, <size of tmp>,  &x,  sizeof(tmp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6099f83e-921a-38d7-944b-efe7600ae996",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                },
                "region": {
                  "startLine": 2945,
                  "startColumn": 2,
                  "endLine": 2945,
                  "endColumn": 29,
                  "charOffset": 111197,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(tmp, &x, sizeof(tmp)",
                    "rendered": {
                      "text": "memcpy(tmp, &x, sizeof(tmp)",
                      "markdown": "`memcpy(tmp, &x, sizeof(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111197,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp, <size of tmp>,  &x,  sizeof(tmp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bb888cb9-7a60-3655-82c4-f374ff8e10b7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/Default/Half.h"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 70,
                  "endLine": 227,
                  "endColumn": 97,
                  "charOffset": 10185,
                  "charLength": 27,
                  "snippet": {
                    "text": "http://half.sourceforge.net",
                    "rendered": {
                      "text": "http://half.sourceforge.net",
                      "markdown": "`http://half.sourceforge.net`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/Default/Half.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10185,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "https://half.sourceforge.net"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "55538980-194f-3552-b19c-8a9c643bfcb6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/Default/Half.h"
                },
                "region": {
                  "startLine": 226,
                  "startColumn": 70,
                  "endLine": 226,
                  "endColumn": 97,
                  "charOffset": 10024,
                  "charLength": 27,
                  "snippet": {
                    "text": "http://half.sourceforge.net",
                    "rendered": {
                      "text": "http://half.sourceforge.net",
                      "markdown": "`http://half.sourceforge.net`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/Default/Half.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10024,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "https://half.sourceforge.net"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "f4ca8137-257b-37e7-8a1b-86301a647d1e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 40,
                  "endLine": 220,
                  "endColumn": 45,
                  "charOffset": 7739,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "fa222a45-afb5-36bb-95fc-df45a8debc1b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/Default/Half.h"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 41,
                  "endLine": 6,
                  "endColumn": 59,
                  "charOffset": 264,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/Default/Half.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 264,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "97ea52ce-c102-3600-9424-bb2e7420c6a8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 336,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 336,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "00c832fa-781c-3e87-8ae0-fd9e345661bd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 1009,
                  "startColumn": 20,
                  "endLine": 1009,
                  "endColumn": 39,
                  "charOffset": 39420,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39420,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8707d7a8-dbda-3504-a630-bf781b406d6b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 45,
                  "endLine": 264,
                  "endColumn": 89,
                  "charOffset": 8824,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void* dst, const void* src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void* dst, const void* src, size_t n)",
                      "markdown": "`memcpy(void* dst, const void* src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8824,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void* dst, <size of void* dst>,  const void* src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3a24382c-6fb9-30c8-89a8-73a1c1a8045a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 41,
                  "endLine": 13,
                  "endColumn": 59,
                  "charOffset": 490,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 490,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "011a25f0-7915-321e-8563-a42c138ee601",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 324,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 324,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "39719e99-873d-3500-b38a-fb17aac97137",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorBase.h"
                },
                "region": {
                  "startLine": 1145,
                  "startColumn": 4,
                  "endLine": 1145,
                  "endColumn": 12,
                  "charOffset": 56648,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "264c4abe-7e6f-3acc-bc28-1c61407fc8ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 1008,
                  "startColumn": 27,
                  "endLine": 1008,
                  "endColumn": 72,
                  "charOffset": 39346,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(void *dst, const Index *src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void *dst, const Index *src, size_t n)",
                      "markdown": "`memcpy(void *dst, const Index *src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39346,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *dst, <size of void *dst>,  const Index *src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "13d3dcb0-e633-3c89-b2ec-2b131a408c06",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 316,
                  "startColumn": 27,
                  "endLine": 316,
                  "endColumn": 71,
                  "charOffset": 12336,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void *dst, const void *src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void *dst, const void *src, size_t n)",
                      "markdown": "`memcpy(void *dst, const void *src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12336,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *dst, <size of void *dst>,  const void *src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e2464196-b54d-3045-9b57-7266f0cf8c45",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 19,
                  "endLine": 297,
                  "endColumn": 85,
                  "charOffset": 11946,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&buf[base_offset], line_buf, line_len*sizeof(ComplexScalar)",
                    "rendered": {
                      "text": "memcpy(&buf[base_offset], line_buf, line_len*sizeof(ComplexScalar)",
                      "markdown": "`memcpy(&buf[base_offset], line_buf, line_len*sizeof(ComplexScalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11946,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&buf[base_offset], <size of &buf[base_offset]>,  line_buf,  line_len*sizeof(ComplexScalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3676d032-d31e-3bd3-bc61-16db9caa85d0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 19,
                  "endLine": 279,
                  "endColumn": 85,
                  "charOffset": 11333,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(line_buf, &buf[base_offset], line_len*sizeof(ComplexScalar)",
                    "rendered": {
                      "text": "memcpy(line_buf, &buf[base_offset], line_len*sizeof(ComplexScalar)",
                      "markdown": "`memcpy(line_buf, &buf[base_offset], line_len*sizeof(ComplexScalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11333,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(line_buf, <size of line_buf>,  &buf[base_offset],  line_len*sizeof(ComplexScalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8a60286d-4e0c-3867-858f-d17175822cf1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorBase.h"
                },
                "region": {
                  "startLine": 1140,
                  "startColumn": 4,
                  "endLine": 1140,
                  "endColumn": 12,
                  "charOffset": 56406,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "73e24196-f7c0-36a9-86e4-648486796697",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorBase.h"
                },
                "region": {
                  "startLine": 934,
                  "startColumn": 4,
                  "endLine": 934,
                  "endColumn": 12,
                  "charOffset": 46282,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e2d5fe6e-43c8-3056-ad4e-2e17ad1d2133",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h"
                },
                "region": {
                  "startLine": 274,
                  "startColumn": 15,
                  "endLine": 274,
                  "endColumn": 90,
                  "charOffset": 10690,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy((void*)(m_device.get(data)),m_device.get(m_data), m_dims.TotalSize()",
                    "rendered": {
                      "text": "memcpy((void*)(m_device.get(data)),m_device.get(m_data), m_dims.TotalSize()",
                      "markdown": "`memcpy((void*)(m_device.get(data)),m_device.get(m_data), m_dims.TotalSize()`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10690,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void*)(m_device.get(data)), <size of (void*)(m_device.get(data))>, m_device.get(m_data),  m_dims.TotalSize()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a9d9c2dc-255f-326a-9aa1-ce8495a1ab4b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 15,
                  "endLine": 79,
                  "endColumn": 91,
                  "charOffset": 3118,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy((void*)(m_device.get(dest)), m_device.get(m_data), m_dims.TotalSize()",
                    "rendered": {
                      "text": "memcpy((void*)(m_device.get(dest)), m_device.get(m_data), m_dims.TotalSize()",
                      "markdown": "`memcpy((void*)(m_device.get(dest)), m_device.get(m_data), m_dims.TotalSize()`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3118,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void*)(m_device.get(dest)), <size of (void*)(m_device.get(dest))>,  m_device.get(m_data),  m_dims.TotalSize()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "33781bca-3742-3029-af23-863c8a54bf91",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 9,
                  "endLine": 593,
                  "endColumn": 16,
                  "charOffset": 21230,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2058c040-f779-3cf7-9d65-084cd929b437",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 257,
                  "startColumn": 17,
                  "endLine": 257,
                  "endColumn": 29,
                  "charOffset": 9623,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Memory.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9623,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f121f25f-42e8-35f9-8aab-6c53e48c140b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 13,
                  "endLine": 184,
                  "endColumn": 25,
                  "charOffset": 7535,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Memory.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7535,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ca526359-696d-3550-8b11-c6d0bd37cd61",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 9,
                  "endLine": 138,
                  "endColumn": 16,
                  "charOffset": 5834,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "35932502-d5c6-39df-9adc-7b0590ef3eab",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 624,
                  "startColumn": 49,
                  "endLine": 624,
                  "endColumn": 55,
                  "charOffset": 22272,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "343454c2-3387-3561-b6ba-49d5352ec8fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 570,
                  "startColumn": 4,
                  "endLine": 570,
                  "endColumn": 31,
                  "charOffset": 20409,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(target, start, size)",
                    "rendered": {
                      "text": "memcpy(target, start, size)",
                      "markdown": "`memcpy(target, start, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Memory.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20409,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(target, <size of target>,  start,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d90fb2ad-e0a8-3b8e-985f-fab6a8caa31f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/misc/lapacke.h"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 31,
                  "endLine": 113,
                  "endColumn": 45,
                  "charOffset": 3658,
                  "charLength": 14,
                  "snippet": {
                    "text": "malloc( size )",
                    "rendered": {
                      "text": "malloc( size )",
                      "markdown": "`malloc( size )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/misc/lapacke.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3658,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d3d66a6-e959-3430-a7ac-a251c43af97d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 24,
                  "endLine": 105,
                  "endColumn": 48,
                  "charOffset": 4446,
                  "charLength": 24,
                  "snippet": {
                    "text": "malloc(size + alignment)",
                    "rendered": {
                      "text": "malloc(size + alignment)",
                      "markdown": "`malloc(size + alignment)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Memory.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4446,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "81eb0c45-24d1-3930-a177-9e3797dbb15a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 4,
                  "endLine": 36,
                  "endColumn": 23,
                  "charOffset": 1341,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1341,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7eab39bf-9c18-3c11-b60d-0ff51bb3aa70",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 45,
                  "endLine": 32,
                  "endColumn": 89,
                  "charOffset": 1143,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void* dst, const void* src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void* dst, const void* src, size_t n)",
                      "markdown": "`memcpy(void* dst, const void* src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1143,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void* dst, <size of void* dst>,  const void* src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b0480fcd-b09a-3fd2-8145-b6a276f88e65",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 4,
                  "endLine": 39,
                  "endColumn": 23,
                  "charOffset": 1480,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1480,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dae71298-18fc-3f87-a46e-5ca84f790ca9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 6,
                  "endLine": 33,
                  "endColumn": 25,
                  "charOffset": 1202,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1202,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7c856da8-1e08-3f63-beb9-06c96b2824a2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 336,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 336,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "97ff9085-198b-3b95-bd81-0ff26271ebd5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 4,
                  "endLine": 102,
                  "endColumn": 42,
                  "charOffset": 3454,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(dest, value.data(), data_bytes)",
                    "rendered": {
                      "text": "memcpy(dest, value.data(), data_bytes)",
                      "markdown": "`memcpy(dest, value.data(), data_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3454,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  value.data(),  data_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "eeda3e42-7d8a-322a-ba65-1247ac06d83a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 4,
                  "endLine": 112,
                  "endColumn": 38,
                  "charOffset": 3875,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(&header, src, header_bytes)",
                    "rendered": {
                      "text": "memcpy(&header, src, header_bytes)",
                      "markdown": "`memcpy(&header, src, header_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3875,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&header, <size of &header>,  src,  header_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8b91929d-fcd9-3c9c-b7e8-82b9ec94be0b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 4,
                  "endLine": 117,
                  "endColumn": 41,
                  "charOffset": 4127,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(value.data(), src, data_bytes)",
                    "rendered": {
                      "text": "memcpy(value.data(), src, data_bytes)",
                      "markdown": "`memcpy(value.data(), src, data_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4127,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value.data(), <size of value.data()>,  src,  data_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "39e8afd6-ccc2-34d9-831a-4203debb96ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 4,
                  "endLine": 100,
                  "endColumn": 39,
                  "charOffset": 3387,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(dest, &header, header_bytes)",
                    "rendered": {
                      "text": "memcpy(dest, &header, header_bytes)",
                      "markdown": "`memcpy(dest, &header, header_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3387,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  &header,  header_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "aa25054f-301a-34a8-8f04-46f1782ef7e6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 72,
                  "endColumn": 37,
                  "charOffset": 2476,
                  "charLength": 33,
                  "snippet": {
                    "text": "memcpy(&value, src, sizeof(value)",
                    "rendered": {
                      "text": "memcpy(&value, src, sizeof(value)",
                      "markdown": "`memcpy(&value, src, sizeof(value)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2476,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&value, <size of &value>,  src,  sizeof(value)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "12240eb1-4ec1-35b5-b725-b8a915be3d40",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 4,
                  "endLine": 57,
                  "endColumn": 38,
                  "charOffset": 1825,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(dest, &value, sizeof(value)",
                    "rendered": {
                      "text": "memcpy(dest, &value, sizeof(value)",
                      "markdown": "`memcpy(dest, &value, sizeof(value)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1825,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  &value,  sizeof(value)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6f67176e-f6ce-30d4-a4cb-b6f029a8101f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 4,
                  "endLine": 120,
                  "endColumn": 23,
                  "charOffset": 3945,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3945,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4c49039e-54dd-39e5-9a9e-75cee56a5690",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 8,
                  "endLine": 97,
                  "endColumn": 27,
                  "charOffset": 2990,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2990,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fa65ebe1-e965-308e-bb4b-7c15f05a2603",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 6,
                  "endLine": 88,
                  "endColumn": 25,
                  "charOffset": 2524,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2524,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ed49b0dc-27c4-3d4a-9d7a-90ff1111fd1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 4,
                  "endLine": 117,
                  "endColumn": 23,
                  "charOffset": 3824,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3824,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8bdf98f3-3765-3d0d-8d14-ddc39df178ba",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 336,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 336,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "db9e914b-5825-327e-a4d7-f74203e05526",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 8,
                  "endLine": 111,
                  "endColumn": 43,
                  "charOffset": 3652,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(dst_ptr, src_ptr, blocksize)",
                    "rendered": {
                      "text": "memcpy(dst_ptr, src_ptr, blocksize)",
                      "markdown": "`memcpy(dst_ptr, src_ptr, blocksize)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3652,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_ptr, <size of dst_ptr>,  src_ptr,  blocksize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d46ea14-f53c-31af-92a0-c12fd20a9fb4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 27,
                  "endLine": 86,
                  "endColumn": 71,
                  "charOffset": 2446,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void* dst, const void* src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void* dst, const void* src, size_t n)",
                      "markdown": "`memcpy(void* dst, const void* src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2446,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void* dst, <size of void* dst>,  const void* src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7a1b9856-e0eb-320e-997b-a13a8de80a12",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h"
                },
                "region": {
                  "startLine": 518,
                  "startColumn": 19,
                  "endLine": 518,
                  "endColumn": 119,
                  "charOffset": 20415,
                  "charLength": 100,
                  "snippet": {
                    "text": "memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), contiguous_values * sizeof(Scalar)",
                    "rendered": {
                      "text": "memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), contiguous_values * sizeof(Scalar)",
                      "markdown": "`memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), contiguous_values * sizeof(Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20415,
                        "charLength": 100
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void*)(m_device.get(data + i)), <size of (void*)(m_device.get(data + i))>,  m_device.get(src+offset),  contiguous_values * sizeof(Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "64a04276-8c3d-3e92-ad5c-dba9807ec104",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/SparseCore/AmbiVector.h"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 11,
                  "endLine": 99,
                  "endColumn": 70,
                  "charOffset": 2832,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(newBuffer,  m_buffer,  copyElements * sizeof(ListEl)",
                    "rendered": {
                      "text": "memcpy(newBuffer,  m_buffer,  copyElements * sizeof(ListEl)",
                      "markdown": "`memcpy(newBuffer,  m_buffer,  copyElements * sizeof(ListEl)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/SparseCore/AmbiVector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2832,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(newBuffer, <size of newBuffer>,   m_buffer,   copyElements * sizeof(ListEl)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "95e8293b-fc59-3e76-b49e-2655d280ea90",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorIO.h"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 54,
                  "endLine": 145,
                  "endColumn": 62,
                  "charOffset": 4940,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "cc0b2f93-c2fd-3f65-bd3b-03b2edffc555",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorIO.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 336,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorIO.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 336,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "725c3ead-87b0-3080-bb80-6258edcd0001",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/NumTraits.h"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 2,
                  "endLine": 98,
                  "endColumn": 35,
                  "charOffset": 3070,
                  "charLength": 33,
                  "snippet": {
                    "text": "memcpy(&tgt, &staged, sizeof(Tgt)",
                    "rendered": {
                      "text": "memcpy(&tgt, &staged, sizeof(Tgt)",
                      "markdown": "`memcpy(&tgt, &staged, sizeof(Tgt)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/NumTraits.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3070,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tgt, <size of &tgt>,  &staged,  sizeof(Tgt)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e80fbf39-1012-37f3-a2e6-c0cb8b6589ee",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/MathFunctions.h"
                },
                "region": {
                  "startLine": 887,
                  "startColumn": 30,
                  "endLine": 887,
                  "endColumn": 38,
                  "charOffset": 26126,
                  "charLength": 8,
                  "snippet": {
                    "text": "RAND_MAX",
                    "rendered": {
                      "text": "RAND_MAX",
                      "markdown": "`RAND_MAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "2d6496ce-8375-3bf1-8a13-d9cf924390a2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/MathFunctions.h"
                },
                "region": {
                  "startLine": 907,
                  "startColumn": 24,
                  "endLine": 907,
                  "endColumn": 29,
                  "charOffset": 26919,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e65560a6-f9cd-3838-b659-e5aa6d0355da",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 8,
                  "endLine": 224,
                  "endColumn": 82,
                  "charOffset": 7098,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(lowerProfile, m_lowerProfile, copyLowerProfileSize * sizeof (Index)",
                    "rendered": {
                      "text": "memcpy(lowerProfile, m_lowerProfile, copyLowerProfileSize * sizeof (Index)",
                      "markdown": "`memcpy(lowerProfile, m_lowerProfile, copyLowerProfileSize * sizeof (Index)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7098,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(lowerProfile, <size of lowerProfile>,  m_lowerProfile,  copyLowerProfileSize * sizeof (Index)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "516d5458-ef03-3006-ae8c-35daa1a0a268",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 8,
                  "endLine": 223,
                  "endColumn": 82,
                  "charOffset": 7013,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(upperProfile, m_upperProfile, copyUpperProfileSize * sizeof (Index)",
                    "rendered": {
                      "text": "memcpy(upperProfile, m_upperProfile, copyUpperProfileSize * sizeof (Index)",
                      "markdown": "`memcpy(upperProfile, m_upperProfile, copyUpperProfileSize * sizeof (Index)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7013,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(upperProfile, <size of upperProfile>,  m_upperProfile,  copyUpperProfileSize * sizeof (Index)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "39c3c578-409f-3a6f-89ad-9009e2dc89e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 8,
                  "endLine": 222,
                  "endColumn": 62,
                  "charOffset": 6948,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(lower, m_lower, copyLowerSize * sizeof (Scalar)",
                    "rendered": {
                      "text": "memcpy(lower, m_lower, copyLowerSize * sizeof (Scalar)",
                      "markdown": "`memcpy(lower, m_lower, copyLowerSize * sizeof (Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6948,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(lower, <size of lower>,  m_lower,  copyLowerSize * sizeof (Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0a0f3296-a078-3ec6-bd3a-f8ff16b55342",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 8,
                  "endLine": 221,
                  "endColumn": 62,
                  "charOffset": 6883,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(upper, m_upper, copyUpperSize * sizeof (Scalar)",
                    "rendered": {
                      "text": "memcpy(upper, m_upper, copyUpperSize * sizeof (Scalar)",
                      "markdown": "`memcpy(upper, m_upper, copyUpperSize * sizeof (Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6883,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(upper, <size of upper>,  m_upper,  copyUpperSize * sizeof (Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6680d9e3-8ea2-3a93-a749-e1686e692ef7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/MathFunctions.h"
                },
                "region": {
                  "startLine": 902,
                  "startColumn": 54,
                  "endLine": 902,
                  "endColumn": 62,
                  "charOffset": 26638,
                  "charLength": 8,
                  "snippet": {
                    "text": "RAND_MAX",
                    "rendered": {
                      "text": "RAND_MAX",
                      "markdown": "`RAND_MAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "034e0f37-b617-3f3b-b4ab-4f4ba8c9a368",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/MathFunctions.h"
                },
                "region": {
                  "startLine": 892,
                  "startColumn": 30,
                  "endLine": 892,
                  "endColumn": 35,
                  "charOffset": 26337,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "08282e69-cb06-36f0-af21-c5ef89d83528",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 8,
                  "endLine": 63,
                  "endColumn": 88,
                  "charOffset": 1755,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(m_upperProfile, other.m_upperProfile, m_upperProfileSize * sizeof (Index)",
                    "rendered": {
                      "text": "memcpy(m_upperProfile, other.m_upperProfile, m_upperProfileSize * sizeof (Index)",
                      "markdown": "`memcpy(m_upperProfile, other.m_upperProfile, m_upperProfileSize * sizeof (Index)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1755,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_upperProfile, <size of m_upperProfile>,  other.m_upperProfile,  m_upperProfileSize * sizeof (Index)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e0c3adf1-534a-39e5-9bb6-ec29495650a5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 8,
                  "endLine": 62,
                  "endColumn": 56,
                  "charOffset": 1678,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(m_lower, other.m_lower, other.lowerSize()",
                    "rendered": {
                      "text": "memcpy(m_lower, other.m_lower, other.lowerSize()",
                      "markdown": "`memcpy(m_lower, other.m_lower, other.lowerSize()`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1678,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_lower, <size of m_lower>,  other.m_lower,  other.lowerSize()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6a96b405-3662-3aee-bbc2-cb981085d9a1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 8,
                  "endLine": 64,
                  "endColumn": 88,
                  "charOffset": 1846,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(m_lowerProfile, other.m_lowerProfile, m_lowerProfileSize * sizeof (Index)",
                    "rendered": {
                      "text": "memcpy(m_lowerProfile, other.m_lowerProfile, m_lowerProfileSize * sizeof (Index)",
                      "markdown": "`memcpy(m_lowerProfile, other.m_lowerProfile, m_lowerProfileSize * sizeof (Index)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1846,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_lowerProfile, <size of m_lowerProfile>,  other.m_lowerProfile,  m_lowerProfileSize * sizeof (Index)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "076ad077-5a3b-3e0e-9ef3-161c7f573452",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 8,
                  "endLine": 220,
                  "endColumn": 59,
                  "charOffset": 6821,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(diag, m_diag, copyDiagSize * sizeof (Scalar)",
                    "rendered": {
                      "text": "memcpy(diag, m_diag, copyDiagSize * sizeof (Scalar)",
                      "markdown": "`memcpy(diag, m_diag, copyDiagSize * sizeof (Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6821,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(diag, <size of diag>,  m_diag,  copyDiagSize * sizeof (Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a0636a6a-9fc4-33b3-af67-edd4ad18d920",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 8,
                  "endLine": 61,
                  "endColumn": 56,
                  "charOffset": 1601,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(m_upper, other.m_upper, other.upperSize()",
                    "rendered": {
                      "text": "memcpy(m_upper, other.m_upper, other.upperSize()",
                      "markdown": "`memcpy(m_upper, other.m_upper, other.upperSize()`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1601,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_upper, <size of m_upper>,  other.m_upper,  other.upperSize()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0440a437-85d5-3054-94b8-f061ee89264f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 8,
                  "endLine": 60,
                  "endColumn": 65,
                  "charOffset": 1533,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(m_diag, other.m_diag, m_diagSize * sizeof (Scalar)",
                    "rendered": {
                      "text": "memcpy(m_diag, other.m_diag, m_diagSize * sizeof (Scalar)",
                      "markdown": "`memcpy(m_diag, other.m_diag, m_diagSize * sizeof (Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1533,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_diag, <size of m_diag>,  other.m_diag,  m_diagSize * sizeof (Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dd966dd2-8711-3d23-ab3b-0398ff4519ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineMatrix.h"
                },
                "region": {
                  "startLine": 668,
                  "startColumn": 12,
                  "endLine": 668,
                  "endColumn": 76,
                  "charOffset": 25167,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(m_colStartIndex, other.m_colStartIndex, (m_outerSize + 1)",
                    "rendered": {
                      "text": "memcpy(m_colStartIndex, other.m_colStartIndex, (m_outerSize + 1)",
                      "markdown": "`memcpy(m_colStartIndex, other.m_colStartIndex, (m_outerSize + 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineMatrix.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25167,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_colStartIndex, <size of m_colStartIndex>,  other.m_colStartIndex,  (m_outerSize + 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "414018d6-1d7d-3600-a5b1-281942e71a92",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineMatrix.h"
                },
                "region": {
                  "startLine": 669,
                  "startColumn": 12,
                  "endLine": 669,
                  "endColumn": 76,
                  "charOffset": 25263,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(m_rowStartIndex, other.m_rowStartIndex, (m_outerSize + 1)",
                    "rendered": {
                      "text": "memcpy(m_rowStartIndex, other.m_rowStartIndex, (m_outerSize + 1)",
                      "markdown": "`memcpy(m_rowStartIndex, other.m_rowStartIndex, (m_outerSize + 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineMatrix.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25263,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_rowStartIndex, <size of m_rowStartIndex>,  other.m_rowStartIndex,  (m_outerSize + 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "64b8b755-45bf-37ef-a814-4e47b011ed1d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/Random.h"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 17,
                  "endLine": 134,
                  "endColumn": 24,
                  "charOffset": 4918,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "d90045bc-f037-305a-9d7f-794a07eb5b9f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/IterativeSolvers/IDRSTABL.h"
                },
                "region": {
                  "startLine": 204,
                  "startColumn": 59,
                  "endLine": 204,
                  "endColumn": 66,
                  "charOffset": 7500,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "ab077fa8-f208-384b-996d-ee1bc4b048ab",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/DenseBase.h"
                },
                "region": {
                  "startLine": 558,
                  "startColumn": 34,
                  "endLine": 558,
                  "endColumn": 41,
                  "charOffset": 25260,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "76e93c0a-7054-39ca-b105-374641a78dd5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/DenseBase.h"
                },
                "region": {
                  "startLine": 557,
                  "startColumn": 34,
                  "endLine": 557,
                  "endColumn": 41,
                  "charOffset": 25194,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "bea50275-bf91-35f5-9d20-2a5f5e3ac6c2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/IterativeSolvers/IDRS.h"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 55,
                  "endLine": 76,
                  "endColumn": 62,
                  "charOffset": 3197,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "14ccfd3a-9b8d-3378-979d-0ee031f4e4a5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/Random.h"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 20,
                  "endLine": 57,
                  "endColumn": 27,
                  "charOffset": 2056,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "783192ee-66ee-3105-b824-2789aae99359",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/IterativeSolvers/BiCGSTABL.h"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 35,
                  "endLine": 74,
                  "endColumn": 42,
                  "charOffset": 3209,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "36f1d284-de53-34cf-bef9-998caf7b8e5d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/Random.h"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 20,
                  "endLine": 88,
                  "endColumn": 27,
                  "charOffset": 3252,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "67e52466-91ce-3aa0-ab73-8a6b3274c00a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 9,
                  "endLine": 40,
                  "endColumn": 15,
                  "charOffset": 1444,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a44457c5-322e-34c9-a5e4-0eb015908a29",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured URL Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/DenseStorage.h"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 15,
                  "endLine": 81,
                  "endColumn": 41,
                  "charOffset": 3113,
                  "charLength": 26,
                  "snippet": {
                    "text": "http://eigen.tuxfamily.org",
                    "rendered": {
                      "text": "http://eigen.tuxfamily.org",
                      "markdown": "`http://eigen.tuxfamily.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/DenseStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3113,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "https://eigen.tuxfamily.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "597f8468-7c7f-3ccd-b886-e98161e70098",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured URL Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/DenseStorage.h"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 15,
                  "endLine": 75,
                  "endColumn": 41,
                  "charOffset": 2747,
                  "charLength": 26,
                  "snippet": {
                    "text": "http://eigen.tuxfamily.org",
                    "rendered": {
                      "text": "http://eigen.tuxfamily.org",
                      "markdown": "`http://eigen.tuxfamily.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/DenseStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2747,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "https://eigen.tuxfamily.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "b429276c-c32c-3f98-afce-603695b3c432",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 9,
                  "endLine": 37,
                  "endColumn": 15,
                  "charOffset": 1240,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bf85f604-d246-36da-a767-ef536fa1c594",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 9,
                  "endLine": 34,
                  "endColumn": 15,
                  "charOffset": 1083,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c77cd837-3623-32ca-a6dd-750d3cd36b0c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h"
                },
                "region": {
                  "startLine": 385,
                  "startColumn": 14,
                  "endLine": 385,
                  "endColumn": 18,
                  "charOffset": 16066,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7d18cb29-690e-3dc2-9a3e-32fa8aa048b9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 9,
                  "endLine": 31,
                  "endColumn": 15,
                  "charOffset": 940,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "44afb113-db3a-3769-82d7-69ca3a9a191c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 41,
                  "endLine": 9,
                  "endColumn": 59,
                  "charOffset": 407,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 407,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "a39a4d16-994f-344d-8072-c1b25d15b76b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h"
                },
                "region": {
                  "startLine": 701,
                  "startColumn": 8,
                  "endLine": 701,
                  "endColumn": 86,
                  "charOffset": 27095,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(&(m_values[nz_marker]), it->value().data(), block_size * sizeof(Scalar)",
                    "rendered": {
                      "text": "memcpy(&(m_values[nz_marker]), it->value().data(), block_size * sizeof(Scalar)",
                      "markdown": "`memcpy(&(m_values[nz_marker]), it->value().data(), block_size * sizeof(Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27095,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&(m_values[nz_marker]), <size of &(m_values[nz_marker])>,  it->value().data(),  block_size * sizeof(Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c32e1388-7014-3347-8595-997bece32718",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/doc/examples/MatrixSinh.cpp"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 25,
                  "endLine": 8,
                  "endColumn": 32,
                  "charOffset": 128,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "de9d29a5-c4a0-36fd-8dd5-841f78f937e7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_compute_MatrixType2.cpp"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 14,
                  "endLine": 3,
                  "endColumn": 21,
                  "charOffset": 82,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "bf92539b-f315-30c1-931b-29bfcc1a6042",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Vectorwise_reverse.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "d352f1db-f775-3372-90a4-1e5b9cf45471",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/doc/examples/MatrixSine.cpp"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 25,
                  "endLine": 8,
                  "endColumn": 32,
                  "charOffset": 128,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "527eaa60-b063-38cc-9fb2-89b0a2d5b169",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tridiagonalization_decomposeInPlace.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "9447cf9d-7654-38c5-962b-5691c2ac66ff",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_compute_MatrixType2.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "2af9ebd1-f815-31ba-8447-b4bff7e24365",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_random_int_int.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 18,
                  "endLine": 1,
                  "endColumn": 25,
                  "charOffset": 18,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "5ff775c3-543d-3fa5-9c65-1ceb1c27f40d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/HessenbergDecomposition_packedMatrix.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "6fe7c369-a1a2-32c3-ad0a-b02ab91f3e18",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "714bf76d-5a5b-3429-9e25-849a759ad327",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/tut_arithmetic_transpose_conjugate.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "78f1867a-2c10-3292-9d02-2620d162fec5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_reverse.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "f401c856-320f-35bd-b9dc-b479841bb85d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 14,
                  "endLine": 4,
                  "endColumn": 21,
                  "charOffset": 152,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "91454575-edd8-3c7a-a5fc-8af75f943902",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/HouseholderQR_householderQ.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 21,
                  "endLine": 1,
                  "endColumn": 28,
                  "charOffset": 21,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "7c2b7708-e7f4-352c-ac5b-9cbe58a5cf2c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/RealSchur_RealSchur_MatrixType.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0c449cd9-8b70-3972-bed6-4ddf445882e5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_compute_MatrixType.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 63,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "7d986658-9dda-3b4e-91a2-9736fa4383fb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/HessenbergDecomposition_compute.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0ee3343a-3c18-34c0-80f0-7f3447a0dbc1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tridiagonalization_compute.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 57,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "c3c96ce3-3521-3167-a7f7-7318e4e59a58",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Slicing_rawarray_cxx11.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0fb17a26-8830-3ab1-b665-25ea612d9b1f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "00b1f2a5-2444-3e5c-a2ce-99849cd4cf3d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_random_int.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 18,
                  "endLine": 1,
                  "endColumn": 25,
                  "charOffset": 18,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "4be47059-21bd-3233-9816-58e00783422e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/ComplexEigenSolver_compute.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "3785b26f-4afb-3179-b50a-27d93d06f441",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Slicing_arrayexpr.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 55,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "bdb083fc-006b-3351-8586-223120398812",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/ComplexSchur_matrixU.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e15d867e-6093-386e-a1f8-210795c29e4e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/EigenSolver_pseudoEigenvectors.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a812ceda-ac2b-3a8d-86b3-bf5845f57074",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/HessenbergDecomposition_matrixH.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "fa22f8e7-9067-344f-a6d8-b56508d785a7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/DirectionWise_hnormalized.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "6df0f168-f792-3f79-beaf-bf92ac351b32",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/LeastSquaresQR.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 60,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "d331582f-5ff7-3b7a-9d69-6ce43eb9f693",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/VectorwiseOp_homogeneous.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a24a5345-a860-32e6-9dbf-bc2bd5801cda",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/LeastSquaresQR.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "53d51183-2beb-3750-98b9-b0d118d2d29c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_replicate.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e5b5b358-0a2d-328e-896c-a6277b3c5138",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/RealQZ_compute.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "c76f7b2c-662c-35b8-833a-15889e017eb6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/RealQZ_compute.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 59,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "098997c9-a126-3a89-839b-3628090fd608",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 60,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "58d0b67b-2ba5-3f2a-b37c-645aa90c423e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tutorial_AdvancedInitialization_CommaTemporary.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "06928318-f5f3-3e22-ae47-f7c35fd15023",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/DirectionWise_replicate.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e45ede20-ba7d-3ade-83fb-5ffd95bd2f4b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/libs/BLAS/blas_interface_impl.hh"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 23,
                  "endLine": 105,
                  "endColumn": 29,
                  "charOffset": 3776,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "706de43f-f56f-3aef-8480-f4316bf81416",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/PartialPivLU_solve.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 59,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "4b2a7cdd-cdeb-3eb1-b262-ef86e5f9ee76",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/PartialPivLU_solve.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "ab4e11b4-c527-3070-b34d-f90bed0219c6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_operatorSqrt.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0504c979-3e1f-38ab-abd3-5ff0137680c1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/libs/BLAS/blas_interface_impl.hh"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 23,
                  "endLine": 104,
                  "endColumn": 29,
                  "charOffset": 3730,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "161e81a7-40ad-3e46-9dea-f0b47d07fd99",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "cf3fe8e2-62ce-3533-aef0-1774775e70c7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/libs/BLAS/blas_interface_impl.hh"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 23,
                  "endLine": 79,
                  "endColumn": 29,
                  "charOffset": 2722,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4dd2ee8c-1ff6-3a04-a73a-a67708c6157b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/ComplexSchur_compute.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}