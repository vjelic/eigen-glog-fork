{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-d3887856-5962-4c16-8c61-f9e16174b659",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-55b00535-1353-467f-902b-c7f6e628f29c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol instead of the secure HTTPS protocol for network communication. This can expose sensitive data to potential interception or manipulation by attackers. In C++ programming, this vulnerability can occur when libraries or functions that perform network communication are used without proper encryption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use secure HTTPS protocol for network communication. This ensures that the data transmitted between the client and the server is encrypted and cannot be easily intercepted or manipulated by attackers. If you are using libraries or functions that do not support HTTPS, consider switching to ones that do.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in this case is the unsecured web address \"http://mozilla.org\". To fix this, simply change the protocol from HTTP to HTTPS:\n\n```cpp\nstd::string url = \"https://mozilla.org\";\n```\n\n## Library Dependencies\n\nThe specific library dependencies required by the code example will depend on the libraries or functions used for network communication. For example, if you are using the `curl` library, you will need to have `libcurl` installed.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "glog-8ead13f8-01f1-4701-b16a-60b188b81d23",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s` (in C11), which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe source code fix would involve checking the size of the destination buffer before calling `memcpy`. Here is a possible fix:\n\n```cpp\nsize_t size = contiguous_values * sizeof(Scalar);\nif (size <= m_device.get(data + i).size()) {\n    memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-504c60ba-cdb1-423c-b9a8-508d0b5ac862",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(tmp, &x, sizeof(tmp))`, the size of the source data (`&x`) may be larger than the size of the destination buffer (`tmp`), leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(x) <= sizeof(tmp)) {\n    memcpy(tmp, &x, sizeof(x));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `x` is less than or equal to the size of `tmp`. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ef8cf4fc-ddb1-4d0b-8ca5-2cd6eacea51d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(tmp, &x, sizeof(tmp))`, the size of the source data (`&x`) may be larger than the size of the destination buffer (`tmp`), leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(x) <= sizeof(tmp)) {\n    memcpy(tmp, &x, sizeof(x));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `x` is less than or equal to the size of `tmp`. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-003b46a6-5b6d-4ecf-88ab-5bd585f2cb1f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from a source address to a destination address. A vulnerability can occur when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause a program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no more than this size is written.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to fix the vulnerability in the `memcpy` function:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void *dst, size_t dst_size, const void *src, size_t n) {\n    if (dst_size < n) {\n        // Handle the error, e.g. by throwing an exception, returning an error code, etc.\n        throw std::length_error(\"Destination buffer is too small\");\n    }\n    memcpy(dst, src, n);\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e1c0b84e-f604-45e8-8d45-436d7bfa7b1b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. It takes three arguments: a pointer to the destination, a pointer to the source, and the number of bytes to copy. The vulnerability arises when the size of the destination buffer is less than the number of bytes to be copied. This can lead to buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the source data is larger than the destination buffer, either increase the size of the destination buffer or reduce the size of the source data.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to fix this vulnerability:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void* dst, size_t dst_size, const void* src, size_t src_size) {\n    if (src_size <= dst_size) {\n        memcpy(dst, src, src_size);\n    } else {\n        // Handle error: source data is too large\n    }\n}\n```\n\nIn this example, the `safe_memcpy` function checks the size of the source data before calling `memcpy`. If the source data is too large, it does not call `memcpy` and instead handles the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-24509818-96a7-4f3e-bf17-5a1f7a01a2b4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol instead of the secure HTTPS protocol for network communication. This can expose sensitive data to potential interception or manipulation by attackers. In C++ programming, this vulnerability can occur when libraries or functions that perform network communication are used without proper encryption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use secure HTTPS protocol for network communication. This ensures that the data transmitted between the client and the server is encrypted and cannot be easily intercepted or manipulated by attackers. If you are using libraries or functions that do not support HTTPS, consider switching to ones that do.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in this case is the unsecured web address \"http://mozilla.org\". To fix this, simply change the protocol from HTTP to HTTPS:\n\n```cpp\nstd::string url = \"https://mozilla.org\";\n```\n\n## Library Dependencies\n\nThe specific library dependencies required by the code example will depend on the libraries or functions used for network communication. For example, if you are using the `curl` library, you will need to have `libcurl` installed.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "glog-575d2ab2-5fa2-4f28-8fa8-2254b93465e0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is greater than the size of the destination buffer (`dst`). This can lead to unexpected behavior, including program crashes, data corruption, and execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring> // for memcpy\n#include <cassert> // for assert\n\nvoid safe_memcpy(void *dst, size_t dst_size, const void *src, size_t src_size) {\n    assert(dst_size >= src_size);\n    memcpy(dst, src, src_size);\n}\n```\n\nIn this code, `assert` is used to ensure that the size of the destination buffer is greater than or equal to the size of the source data. If this condition is not met, the program will terminate with an error message.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This header file contains definitions for functions to manipulate C strings and arrays, including `memcpy`.\n- `<cassert>`: This header file contains the `assert` macro, which is used to diagnose logical errors during program execution.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-729af993-62b9-4cde-95a0-f0961c9ebaad",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. It takes three arguments: a pointer to the destination, a pointer to the source, and the number of bytes to copy. The vulnerability arises when the size of the destination buffer is less than the number of bytes to be copied from the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the source data is larger than the destination buffer, either increase the size of the destination buffer or reduce the amount of data being copied.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to safely use `memcpy`:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void *dst, size_t dst_size, const void *src, size_t src_size) {\n    if (src_size <= dst_size) {\n        memcpy(dst, src, src_size);\n    } else {\n        // Handle error: source data is too large for destination buffer\n    }\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-d3887856-5962-4c16-8c61-f9e16174b659",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 40,
                  "endLine": 220,
                  "endColumn": 45,
                  "charOffset": 7739,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-55b00535-1353-467f-902b-c7f6e628f29c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 324,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 324,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "glog-8ead13f8-01f1-4701-b16a-60b188b81d23",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h"
                },
                "region": {
                  "startLine": 518,
                  "startColumn": 19,
                  "endLine": 518,
                  "endColumn": 119,
                  "charOffset": 20415,
                  "charLength": 100,
                  "snippet": {
                    "text": "memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), contiguous_values * sizeof(Scalar)",
                    "rendered": {
                      "text": "memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), contiguous_values * sizeof(Scalar)",
                      "markdown": "`memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), contiguous_values * sizeof(Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20415,
                        "charLength": 100
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void*)(m_device.get(data + i)), <size of (void*)(m_device.get(data + i))>,  m_device.get(src+offset),  contiguous_values * sizeof(Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-504c60ba-cdb1-423c-b9a8-508d0b5ac862",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                },
                "region": {
                  "startLine": 2945,
                  "startColumn": 2,
                  "endLine": 2945,
                  "endColumn": 29,
                  "charOffset": 111197,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(tmp, &x, sizeof(tmp)",
                    "rendered": {
                      "text": "memcpy(tmp, &x, sizeof(tmp)",
                      "markdown": "`memcpy(tmp, &x, sizeof(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111197,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp, <size of tmp>,  &x,  sizeof(tmp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef8cf4fc-ddb1-4d0b-8ca5-2cd6eacea51d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                },
                "region": {
                  "startLine": 2955,
                  "startColumn": 2,
                  "endLine": 2955,
                  "endColumn": 29,
                  "charOffset": 111454,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(tmp, &x, sizeof(tmp)",
                    "rendered": {
                      "text": "memcpy(tmp, &x, sizeof(tmp)",
                      "markdown": "`memcpy(tmp, &x, sizeof(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111454,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp, <size of tmp>,  &x,  sizeof(tmp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-003b46a6-5b6d-4ecf-88ab-5bd585f2cb1f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 1009,
                  "startColumn": 20,
                  "endLine": 1009,
                  "endColumn": 39,
                  "charOffset": 39420,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39420,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e1c0b84e-f604-45e8-8d45-436d7bfa7b1b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 45,
                  "endLine": 264,
                  "endColumn": 89,
                  "charOffset": 8824,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void* dst, const void* src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void* dst, const void* src, size_t n)",
                      "markdown": "`memcpy(void* dst, const void* src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8824,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void* dst, <size of void* dst>,  const void* src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-24509818-96a7-4f3e-bf17-5a1f7a01a2b4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 336,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 336,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "glog-575d2ab2-5fa2-4f28-8fa8-2254b93465e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 1008,
                  "startColumn": 27,
                  "endLine": 1008,
                  "endColumn": 72,
                  "charOffset": 39346,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(void *dst, const Index *src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void *dst, const Index *src, size_t n)",
                      "markdown": "`memcpy(void *dst, const Index *src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39346,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *dst, <size of void *dst>,  const Index *src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-729af993-62b9-4cde-95a0-f0961c9ebaad",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 316,
                  "startColumn": 27,
                  "endLine": 316,
                  "endColumn": 71,
                  "charOffset": 12336,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void *dst, const void *src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void *dst, const void *src, size_t n)",
                      "markdown": "`memcpy(void *dst, const void *src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12336,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *dst, <size of void *dst>,  const void *src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}