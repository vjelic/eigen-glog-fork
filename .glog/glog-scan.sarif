{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "14be3e3b-1561-3dcf-9674-f1cb7db4b6af",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "f4bcd87c-d42b-3e06-b7bd-34d4a7518b34",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "63b65834-a55a-3b82-8b7a-07204466c8b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "3bd0dcf7-b391-3067-b185-f6ab2ff7f67a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "faa790ff-69b4-3ae9-92be-8fe5b67629df",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(to, &from, sizeof(from))`, if the size of `from` is larger than the size of `to`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code, potentially gaining unauthorized access or control over the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif(sizeof(to) >= sizeof(from)) {\n    memcpy(to, &from, sizeof(from));\n} else {\n    // Handle the error, e.g., by logging it or by terminating the program.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6b4002af-03ac-3a2f-8926-7c16735b225d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(to, &from, sizeof(from))`, if the size of `from` is larger than the size of `to`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code, potentially gaining unauthorized access or control over the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif(sizeof(to) >= sizeof(from)) {\n    memcpy(to, &from, sizeof(from));\n} else {\n    // Handle the error, e.g., by logging it or by terminating the program.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "579a91ef-be13-3167-8139-1b70ee75fd5a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(to, &from, sizeof(from))`, if the size of `from` is larger than the size of `to`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code, potentially gaining unauthorized access or control over the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif(sizeof(to) >= sizeof(from)) {\n    memcpy(to, &from, sizeof(from));\n} else {\n    // Handle the error, e.g., by logging it or by terminating the program.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b1f874b2-6fb4-3983-b3c1-6ec7d27d40bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(to, &from, sizeof(from))`, if the size of `from` is larger than the size of `to`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code, potentially gaining unauthorized access or control over the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif(sizeof(to) >= sizeof(from)) {\n    memcpy(to, &from, sizeof(from));\n} else {\n    // Handle the error, e.g., by logging it or by terminating the program.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7245961d-dff1-367d-a38d-25d08fd62538",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&res, from, sizeof(Packet4c))`, if the size of `from` is larger than `res`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code in the context of the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(res) >= sizeof(Packet4c)) {\n    memcpy(&res, from, sizeof(Packet4c));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `res` is larger or equal to the size of `Packet4c`. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a657694a-5528-3733-9489-4ee0e9d3a06d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&res, from, sizeof(Packet4uc))`, if the size of `from` is larger than `res`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code in the context of the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter. These functions will not copy more data than the destination buffer can hold, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nif(sizeof(res) >= sizeof(Packet4uc)) {\n    memcpy(&res, from, sizeof(Packet4uc));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we check if `res` is large enough to hold `Packet4uc` before calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a011fa33-3231-3b34-afe3-62388aa312c3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "a011fa33-3231-3b34-afe3-62388aa312c3"
                ]
              }
            },
            {
              "id": "3d415c72-881c-3926-8e06-186bc46f1516",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "3d415c72-881c-3926-8e06-186bc46f1516"
                ]
              }
            },
            {
              "id": "bb888cb9-7a60-3655-82c4-f374ff8e10b7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of non-secure HTTP protocol for network communication in a C++ program. This can expose the program to various security risks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the communication between the program and the server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure protocols such as HTTPS for network communication. HTTPS encrypts the data sent between the client and the server, making it difficult for an attacker to read or modify the data.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in the provided code is the use of the non-secure HTTP protocol in the web address \"http://half.sourceforge.net\". To fix this, replace the HTTP protocol with HTTPS, if the server supports it. \n\n```cpp\n// Vulnerable code\nstd::string url = \"http://half.sourceforge.net\";\n\n// Fixed code\nstd::string url = \"https://half.sourceforge.net\";\n```\n\n## Library Dependencies\n\nThe code example does not require any specific library dependencies to execute properly.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n\nPlease note that the provided links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "84c55a99-1160-3fdd-b86c-ad7267b589aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&res, from, sizeof(Packet4uc))`, if the size of `from` is larger than `res`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code in the context of the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter. These functions will not copy more data than the destination buffer can hold, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nif(sizeof(res) >= sizeof(Packet4uc)) {\n    memcpy(&res, from, sizeof(Packet4uc));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we check if `res` is large enough to hold `Packet4uc` before calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d985e0f8-d6e8-3987-a846-a89c1fe1f989",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&res, from, sizeof(Packet4c))`, if the size of `from` is larger than `res`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code in the context of the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(res) >= sizeof(Packet4c)) {\n    memcpy(&res, from, sizeof(Packet4c));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `res` is larger or equal to the size of `Packet4c`. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "55538980-194f-3552-b19c-8a9c643bfcb6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of non-secure HTTP protocol for network communication in a C++ program. This can expose the program to various security risks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the communication between the program and the server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure protocols such as HTTPS for network communication. HTTPS encrypts the data sent between the client and the server, making it difficult for an attacker to read or modify the data.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in the provided code is the use of the non-secure HTTP protocol in the web address \"http://half.sourceforge.net\". To fix this, replace the HTTP protocol with HTTPS, if the server supports it. \n\n```cpp\n// Vulnerable code\nstd::string url = \"http://half.sourceforge.net\";\n\n// Fixed code\nstd::string url = \"https://half.sourceforge.net\";\n```\n\n## Library Dependencies\n\nThe code example does not require any specific library dependencies to execute properly.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n\nPlease note that the provided links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "fa222a45-afb5-36bb-95fc-df45a8debc1b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "1bc94487-6dfb-35b1-a738-e03c4a33a29e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "1bc94487-6dfb-35b1-a738-e03c4a33a29e"
                ]
              }
            },
            {
              "id": "9f2a021d-10a1-3fcd-8ff8-e81cf087796f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "9f2a021d-10a1-3fcd-8ff8-e81cf087796f"
                ]
              }
            },
            {
              "id": "1fb89969-b6b1-3bf8-913e-5bf0ae362f28",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential interception by attackers, as the data is transmitted in plain text over the network. This vulnerability can lead to information disclosure, data tampering, and man-in-the-middle attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use secure protocols such as HTTPS for network communication. HTTPS encrypts the data between the client and the server, making it difficult for attackers to intercept and read the data. \n\n## Source Code Fix Recommendation\n\nHere is an example of how to fix this vulnerability in C++ code:\n\n```cpp\n// Include required libraries\n#include <iostream>\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://developer.apple.com\");\n\n        /* Perform the request, res will get the return code */\n        res = curl_easy_perform(curl);\n        /* Check for errors */\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n\n        /* always cleanup */\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code requires the libcurl library to execute properly.\n\n## References\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "39719e99-873d-3500-b38a-fb17aac97137",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "6099f83e-921a-38d7-944b-efe7600ae996",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(tmp, &x, sizeof(tmp))`, the size of the source data (`&x`) may be larger than the size of the destination buffer (`tmp`), leading to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, and information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be achieved by checking the size of the source data before performing the `memcpy` operation.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include built-in checks to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```cpp\nif (sizeof(x) <= sizeof(tmp)) {\n    memcpy(tmp, &x, sizeof(x));\n} else {\n    // Handle error\n}\n```\n\nIn this version, the `memcpy` operation is only performed if the size of the source data (`x`) is less than or equal to the size of the destination buffer (`tmp`).\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "57ec42fc-213e-3a1a-946a-7162cf77d0a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(tmp, &x, sizeof(tmp))`, the size of the source data (`&x`) may be larger than the size of the destination buffer (`tmp`), leading to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, and information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be achieved by checking the size of the source data before performing the `memcpy` operation.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include built-in checks to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```cpp\nif (sizeof(x) <= sizeof(tmp)) {\n    memcpy(tmp, &x, sizeof(x));\n} else {\n    // Handle error\n}\n```\n\nIn this version, the `memcpy` operation is only performed if the size of the source data (`x`) is less than or equal to the size of the destination buffer (`tmp`).\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "73e24196-f7c0-36a9-86e4-648486796697",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "8a60286d-4e0c-3867-858f-d17175822cf1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "011a25f0-7915-321e-8563-a42c138ee601",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "f4ca8137-257b-37e7-8a1b-86301a647d1e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "81eb0c45-24d1-3930-a177-9e3797dbb15a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, and `sprintf`. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, and `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, if you are using C11, you can use the `memcpy_s` function:\n\n```cpp\n#include <string.h>\n\n// ...\n\nsize_t dst_size = sizeof(dst);\nif (n <= dst_size) {\n    memcpy_s(dst, dst_size, src, n);\n} else {\n    // Handle error: the source data is too large to fit in the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3676d032-d31e-3bd3-bc61-16db9caa85d0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the size of the source is larger than the destination. In the provided code snippet, if `line_len*sizeof(ComplexScalar)` is larger than the size of `line_buf`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo prevent buffer overflow vulnerabilities, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\n```cpp\nsize_t size = line_len*sizeof(ComplexScalar);\nif (sizeof(line_buf) >= size) {\n    memcpy(line_buf, &buf[base_offset], size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b0480fcd-b09a-3fd2-8145-b6a276f88e65",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, and `sprintf`. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, and `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, if you are using C11, you can use the `memcpy_s` function:\n\n```cpp\n#include <string.h>\n\n// ...\n\nsize_t dst_size = sizeof(dst);\nif (n <= dst_size) {\n    memcpy_s(dst, dst_size, src, n);\n} else {\n    // Handle error: the source data is too large to fit in the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e2464196-b54d-3045-9b57-7266f0cf8c45",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code or cause a denial of service.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(&buf[base_offset], line_buf, line_len*sizeof(ComplexScalar));\n```\n\nThe `memcpy` function is copying `line_len*sizeof(ComplexScalar)` bytes from `line_buf` to `buf[base_offset]`. If `line_len*sizeof(ComplexScalar)` is larger than the size of `buf` minus `base_offset`, it will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet could be:\n\n```cpp\nsize_t buf_size = sizeof(buf) - base_offset;\nsize_t copy_size = line_len*sizeof(ComplexScalar);\n\nif (copy_size <= buf_size) {\n    memcpy(&buf[base_offset], line_buf, copy_size);\n} else {\n    // Handle error: source data is too large for the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dae71298-18fc-3f87-a46e-5ca84f790ca9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, and `sprintf`. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, and `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, if you are using C11, you can use the `memcpy_s` function:\n\n```cpp\n#include <string.h>\n\n// ...\n\nsize_t dst_size = sizeof(dst);\nif (n <= dst_size) {\n    memcpy_s(dst, dst_size, src, n);\n} else {\n    // Handle error: the source data is too large to fit in the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7c856da8-1e08-3f63-beb9-06c96b2824a2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "e2d5fe6e-43c8-3056-ad4e-2e17ad1d2133",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if `m_dims.TotalSize()` is larger than the size of the buffer pointed to by `m_device.get(data)`, a buffer overflow will occur, potentially leading to arbitrary code execution, application crashes, or other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code:\n\n```cpp\nsize_t dataSize = m_dims.TotalSize();\nvoid* destBuffer = m_device.get(data);\nvoid* srcBuffer = m_device.get(m_data);\n\nif (dataSize <= sizeof(destBuffer)) {\n    memcpy(destBuffer, srcBuffer, dataSize);\n} else {\n    // Handle error: source data is too large for destination buffer\n}\n```\n\n## Library Dependencies\n\nThe provided code appears to depend on a library or class (`m_device`) that provides a `get` method. The exact library or class cannot be determined from the provided code.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ed49b0dc-27c4-3d4a-9d7a-90ff1111fd1c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, and `sprintf`. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, and `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, if you are using C11, you can use the `memcpy_s` function:\n\n```cpp\n#include <string.h>\n\n// ...\n\nsize_t dst_size = sizeof(dst);\nif (n <= dst_size) {\n    memcpy_s(dst, dst_size, src, n);\n} else {\n    // Handle error: the source data is too large to fit in the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a9d9c2dc-255f-326a-9aa1-ce8495a1ab4b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source size is larger than the destination size. This is a common vulnerability in C++ programming, which can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nsize_t size = m_dims.TotalSize();\nif (m_device.get(dest).size() >= size) {\n    memcpy((void*)(m_device.get(dest)), m_device.get(m_data), size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the destination buffer is large enough to hold the data. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6f67176e-f6ce-30d4-a4cb-b6f029a8101f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, and `sprintf`. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, and `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, if you are using C11, you can use the `memcpy_s` function:\n\n```cpp\n#include <string.h>\n\n// ...\n\nsize_t dst_size = sizeof(dst);\nif (n <= dst_size) {\n    memcpy_s(dst, dst_size, src, n);\n} else {\n    // Handle error: the source data is too large to fit in the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "db9e914b-5825-327e-a4d7-f74203e05526",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`blocksize`) is larger than the size of the destination buffer (`dst_ptr`). This can lead to unexpected behavior, including program crashes, data corruption, and execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void* dst_ptr, size_t dst_size, const void* src_ptr, size_t blocksize) {\n    if (blocksize > dst_size) {\n        // Handle the error, e.g., by throwing an exception or returning an error code\n        throw std::length_error(\"blocksize is larger than size of the destination buffer\");\n    }\n    memcpy(dst_ptr, src_ptr, blocksize);\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7eab39bf-9c18-3c11-b60d-0ff51bb3aa70",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, etc. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, etc.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative like `strncpy`. Here is an example:\n\n```cpp\n#include <cstring>\n\nvoid safe_copy(char* dst, const char* src, size_t dst_size) {\n    strncpy(dst, src, dst_size - 1);\n    dst[dst_size - 1] = '\\0';\n}\n```\n\nIn this example, `strncpy` is used to copy the data from `src` to `dst`. The size of the destination buffer (`dst_size - 1`) is passed as a parameter to `strncpy` to prevent buffer overflow. The last character of `dst` is explicitly set to the null character to ensure that `dst` is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-119)](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4c49039e-54dd-39e5-9a9e-75cee56a5690",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, and `sprintf`. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, and `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, if you are using C11, you can use the `memcpy_s` function:\n\n```cpp\n#include <string.h>\n\n// ...\n\nsize_t dst_size = sizeof(dst);\nif (n <= dst_size) {\n    memcpy_s(dst, dst_size, src, n);\n} else {\n    // Handle error: the source data is too large to fit in the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fa65ebe1-e965-308e-bb4b-7c15f05a2603",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, and `sprintf`. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, and `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, if you are using C11, you can use the `memcpy_s` function:\n\n```cpp\n#include <string.h>\n\n// ...\n\nsize_t dst_size = sizeof(dst);\nif (n <= dst_size) {\n    memcpy_s(dst, dst_size, src, n);\n} else {\n    // Handle error: the source data is too large to fit in the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1d46ea14-f53c-31af-92a0-c12fd20a9fb4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, etc. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, etc.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative like `strncpy`. Here is an example:\n\n```cpp\n#include <cstring>\n\nvoid safe_copy(char* dst, const char* src, size_t dst_size) {\n    strncpy(dst, src, dst_size - 1);\n    dst[dst_size - 1] = '\\0';\n}\n```\n\nIn this example, `strncpy` is used to copy the data from `src` to `dst`. The size of the destination buffer (`dst_size - 1`) is passed as a parameter to `strncpy` to prevent buffer overflow. The last character of `dst` is explicitly set to the null character to ensure that `dst` is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-119)](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8bdf98f3-3765-3d0d-8d14-ddc39df178ba",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "97ea52ce-c102-3600-9424-bb2e7420c6a8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "7a1b9856-e0eb-320e-997b-a13a8de80a12",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to overwriting of adjacent memory and can cause unexpected behavior, including program crashes, data corruption, and execution of malicious code.\n\nIn the provided code snippet, the `memcpy` function is used without checking if the size of the data being copied (`contiguous_values * sizeof(Scalar)`) is larger than the size of the destination buffer (`m_device.get(data + i)`). This can potentially lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. If the size of the data being copied is larger than the size of the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t copy_size = contiguous_values * sizeof(Scalar);\nif (m_device.size() >= (data + i + copy_size)) {\n    memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), copy_size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\nIn this fixed code, we first calculate the size of the data being copied (`copy_size`). We then check if the destination buffer (`m_device`) is large enough to hold this data. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet does not include enough context to determine the exact library dependencies. However, the `memcpy` function is part of the C standard library (`<cstring>` in C++), and `m_device.get()` suggests that `m_device` is an object of a class that has a `get` method, which could be part of a custom library or a standard library like `<vector>` or `<array>`.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8707d7a8-dbda-3504-a630-bf781b406d6b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, etc. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, etc.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative like `strncpy`. Here is an example:\n\n```cpp\n#include <cstring>\n\nvoid safe_copy(char* dst, const char* src, size_t dst_size) {\n    strncpy(dst, src, dst_size - 1);\n    dst[dst_size - 1] = '\\0';\n}\n```\n\nIn this example, `strncpy` is used to copy the data from `src` to `dst`. The size of the destination buffer (`dst_size - 1`) is passed as a parameter to `strncpy` to prevent buffer overflow. The last character of `dst` is explicitly set to the null character to ensure that `dst` is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-119)](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "00c832fa-781c-3e87-8ae0-fd9e345661bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, and `sprintf`. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, and `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, if you are using C11, you can use the `memcpy_s` function:\n\n```cpp\n#include <string.h>\n\n// ...\n\nsize_t dst_size = sizeof(dst);\nif (n <= dst_size) {\n    memcpy_s(dst, dst_size, src, n);\n} else {\n    // Handle error: the source data is too large to fit in the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3a24382c-6fb9-30c8-89a8-73a1c1a8045a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "264c4abe-7e6f-3acc-bc28-1c61407fc8ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`n`) is larger than the size of the destination buffer (`dst`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation. \n\nAvoid using functions that do not check the size of the destination buffer such as `memcpy`, `strcpy`, etc. Instead, use safer alternatives that include the size of the destination buffer as a parameter, such as `strncpy`, `snprintf`, etc.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the `memcpy` function:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void *dst, size_t dst_size, const void *src, size_t src_size) {\n    if (src_size <= dst_size) {\n        memcpy(dst, src, src_size);\n    } else {\n        // Handle the error, e.g., by throwing an exception, returning an error code, etc.\n    }\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "95e8293b-fc59-3e76-b49e-2655d280ea90",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "cc0b2f93-c2fd-3f65-bd3b-03b2edffc555",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "d90fb2ad-e0a8-3b8e-985f-fab6a8caa31f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc()` function in C is used to dynamically allocate a block of memory. The size of the memory block is specified in bytes. If the allocation is successful, a pointer to the block of memory is returned. If the allocation fails, a NULL pointer is returned. \n\nA vulnerability can occur when the size parameter passed to `malloc()` is not properly validated or is manipulated in such a way that it causes an overflow or underflow condition. This can lead to various security issues such as buffer overflows, memory corruption, and denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n- Always validate the size parameter before passing it to `malloc()`.\n- Use functions that limit the amount of memory allocated, such as `calloc()`.\n- Check the return value of `malloc()` to ensure that the allocation was successful.\n- Use secure coding practices to prevent integer overflows and underflows.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to properly use `malloc()`:\n\n```c++\n#include <stdlib.h>\n\n// ...\n\nsize_t size = /* some value */;\nif (size > MAX_SIZE) {\n    // Handle error\n    return;\n}\n\nvoid* ptr = malloc(size);\nif (ptr == NULL) {\n    // Handle error\n    return;\n}\n\n// Use ptr\n\nfree(ptr);\n```\n\nIn this example, the size parameter is validated before it is passed to `malloc()`. The return value of `malloc()` is also checked to ensure that the allocation was successful. Finally, the allocated memory is freed with `free()`.\n\n## Library Dependencies\n\nThe `malloc()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "35932502-d5c6-39df-9adc-7b0590ef3eab",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. One such function is `alloca`.\n\nThe `alloca` function dynamically allocates memory on the stack. This can be dangerous because it can lead to stack overflow if the requested size is too large. Additionally, unlike `malloc`, the `alloca` function does not provide any mechanism to detect such errors. This can lead to unpredictable behavior or crashes.\n\n## Mitigation Advice\n\nAvoid using `alloca` function. Instead, use functions like `malloc` or `calloc` which allocate memory on the heap and provide error checking. If you need to use dynamic memory allocation, consider using C++ constructs like `new` and `delete` or smart pointers, which are safer and more flexible.\n\n## Source Code Fix Recommendation\n\nReplace `alloca` with `malloc` or `calloc`. For example, if you have the following code:\n\n```cpp\n#include <alloca.h>\n\nvoid function(size_t size) {\n    char* buffer = (char*) alloca(size);\n    // ...\n}\n```\n\nYou can replace it with:\n\n```cpp\n#include <stdlib.h>\n\nvoid function(size_t size) {\n    char* buffer = (char*) malloc(size);\n    if (buffer == NULL) {\n        // handle error\n    }\n    // ...\n    free(buffer);\n}\n```\n\n## Library Dependencies\n\nThe `alloca` function is declared in the `alloca.h` header file. The `malloc`, `calloc`, and `free` functions are declared in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "33781bca-3742-3029-af23-863c8a54bf91",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflow, memory corruption, or other similar issues. The `memmove` function is one of these prohibited functions. It is used to copy a block of memory from one location to another and can lead to vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `memmove` such as `memcpy_s` or `memmove_s` which are part of the C11 standard. These functions include additional parameters that specify the maximum size of the destination buffer, which can help prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `memmove_s` or `memcpy_s`. Here is an example of how to do it:\n\n```cpp\n#include <string.h>\n\nvoid unsafe(char *src, char *dest, size_t n) {\n    memmove(dest, src, n);\n}\n\nvoid safe(char *src, char *dest, size_t n, size_t max) {\n    memmove_s(dest, max, src, n);\n}\n```\n\nIn this example, `memmove_s` is used instead of `memmove`. The `max` parameter specifies the maximum size of the destination buffer.\n\n## Library Dependencies\n\nThe `string.h` library is required for the `memmove` and `memmove_s` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "13d3dcb0-e633-3c89-b2ec-2b131a408c06",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. It takes three arguments: a pointer to the destination, a pointer to the source, and the number of bytes to copy. The vulnerability arises when the size of the destination buffer is less than the number of bytes to be copied. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the source data is greater than the size of the destination buffer, do not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to check the size of the destination buffer before calling `memcpy`:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void *dst, size_t dst_size, const void *src, size_t src_size) {\n    if (src_size <= dst_size) {\n        memcpy(dst, src, src_size);\n    } else {\n        // Handle the error, e.g., by throwing an exception or returning an error code\n    }\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "343454c2-3387-3561-b6ba-49d5352ec8fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. \n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void* dest, size_t dest_size, const void* src, size_t count) {\n    if (count > dest_size) {\n        // Handle the error, e.g.:\n        throw std::length_error(\"safe_memcpy: destination buffer is too small\");\n    }\n    memcpy(dest, src, count);\n}\n```\n\nIn this code, we first check if the size of the data being copied (`count`) is larger than the size of the destination buffer (`dest_size`). If it is, we throw an exception. If it's not, we proceed with the `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ca526359-696d-3550-8b11-c6d0bd37cd61",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflow, memory corruption, or other similar issues. The `memmove` function is one of these prohibited functions. It is used to copy a block of memory from one location to another and can lead to vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `memmove` such as `memcpy_s` or `memmove_s` which are part of the C11 standard. These functions include additional parameters that specify the maximum size of the destination buffer, which can help prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `memmove_s` or `memcpy_s`. Here is an example of how to do it:\n\n```cpp\n#include <string.h>\n\nvoid unsafe(char *src, char *dest, size_t n) {\n    memmove(dest, src, n);\n}\n\nvoid safe(char *src, char *dest, size_t n, size_t max) {\n    memmove_s(dest, max, src, n);\n}\n```\n\nIn this example, `memmove_s` is used instead of `memmove`. The `max` parameter specifies the maximum size of the destination buffer.\n\n## Library Dependencies\n\nThe `string.h` library is required for the `memmove` and `memmove_s` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2058c040-f779-3cf7-9d65-084cd929b437",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(size)` function in C++ is used to dynamically allocate a block of memory on the heap. The size of the block is specified by the `size` parameter. If the allocation is successful, the function returns a pointer to the beginning of the block. The memory allocated by `malloc` is uninitialized and can contain any data.\n\nA vulnerability can occur when the `size` parameter passed to `malloc` is not properly validated or controlled. This can lead to several types of vulnerabilities, including buffer overflows, integer overflows, and memory corruption. These vulnerabilities can be exploited to execute arbitrary code, cause a denial of service, or leak sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n- Always validate and limit the `size` parameter passed to `malloc`.\n- Check the return value of `malloc` to ensure that the allocation was successful.\n- Initialize the allocated memory to a known value using `memset` or similar function.\n- Use a safe version of `malloc` that includes built-in error checking and validation.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to safely use `malloc`:\n\n```cpp\n#include <stdlib.h>\n#include <string.h>\n\nvoid* safe_malloc(size_t size) {\n    if (size == 0 || size > SIZE_MAX) {\n        // Invalid size\n        return NULL;\n    }\n\n    void* ptr = malloc(size);\n    if (ptr == NULL) {\n        // Allocation failed\n        return NULL;\n    }\n\n    // Initialize memory to zero\n    memset(ptr, 0, size);\n\n    return ptr;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `malloc`\n- `string.h`: for `memset`\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "f121f25f-42e8-35f9-8aab-6c53e48c140b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(size)` function in C++ is used to dynamically allocate a block of memory on the heap. The size of the block is specified by the `size` parameter. If the allocation is successful, the function returns a pointer to the beginning of the block. The memory allocated by `malloc` is uninitialized and can contain any data.\n\nA vulnerability can occur when the `size` parameter passed to `malloc` is not properly validated or controlled. This can lead to several types of vulnerabilities, including buffer overflows, integer overflows, and memory corruption. These vulnerabilities can be exploited to execute arbitrary code, cause a denial of service, or leak sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n- Always validate and limit the `size` parameter passed to `malloc`.\n- Check the return value of `malloc` to ensure that the allocation was successful.\n- Initialize the allocated memory to a known value using `memset` or similar function.\n- Use a safe version of `malloc` that includes built-in error checking and validation.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to safely use `malloc`:\n\n```cpp\n#include <stdlib.h>\n#include <string.h>\n\nvoid* safe_malloc(size_t size) {\n    if (size == 0 || size > SIZE_MAX) {\n        // Invalid size\n        return NULL;\n    }\n\n    void* ptr = malloc(size);\n    if (ptr == NULL) {\n        // Allocation failed\n        return NULL;\n    }\n\n    // Initialize memory to zero\n    memset(ptr, 0, size);\n\n    return ptr;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `malloc`\n- `string.h`: for `memset`\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "1d3d66a6-e959-3430-a7ac-a251c43af97d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(size + alignment)` function in C++ is used to allocate a block of memory of the specified size. The vulnerability arises when the size of the memory to be allocated is not properly validated or controlled, leading to potential buffer overflow, memory corruption, or other related issues. This can be exploited by an attacker to execute arbitrary code, cause a denial of service, or gain unauthorized access to data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and control the size of the memory to be allocated.\n2. Use functions that limit the amount of memory allocated, such as `calloc()`.\n3. Implement error handling for memory allocation functions. If `malloc()` fails, it returns a null pointer. Always check if the returned pointer is null before using it.\n4. Avoid using `malloc()` in a loop as it can lead to memory exhaustion.\n\n## Source Code Fix Recommendation\n\nInstead of using `malloc(size + alignment)`, use `calloc()` function which initializes the allocated memory to zero and helps prevent buffer overflow attacks. Also, add error handling for memory allocation.\n\n```cpp\n// Instead of this\nchar *buffer = (char *) malloc(size + alignment);\n// Use this\nchar *buffer = (char *) calloc(1, size + alignment);\nif (buffer == NULL) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `malloc()` and `calloc()` functions are part of the C Standard Library (`stdlib.h`), so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Matching CWE\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "8b91929d-fcd9-3c9c-b7e8-82b9ec94be0b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source size is larger than the destination size. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the size of the destination buffer before using `memcpy`. If the size of the source is larger than the destination, you should not proceed with the copy operation. Alternatively, you can use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fix for the specific vulnerability sink:\n\n```cpp\nif (data_bytes <= value.size()) {\n    memcpy(value.data(), src, data_bytes);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source (`data_bytes`) is less than or equal to the size of the destination (`value.size()`). If it is, we proceed with the `memcpy` operation. Otherwise, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional library dependencies are required for the code example to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "eeda3e42-7d8a-322a-ba65-1247ac06d83a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `header_bytes` is larger than the size of `header`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(header) >= header_bytes) {\n    memcpy(&header, src, header_bytes);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `header` is greater than or equal to `header_bytes`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "97ff9085-198b-3b95-bd81-0ff26271ebd5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (data_bytes <= sizeof(dest)) {\n    memcpy(dest, value.data(), data_bytes);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`data_bytes`) is less than or equal to the size of the destination buffer (`sizeof(dest)`). If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in an appropriate manner.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "39e8afd6-ccc2-34d9-831a-4203debb96ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `header_bytes` is larger than the size of `dest`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dest) >= header_bytes) {\n    memcpy(dest, &header, header_bytes);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this fixed code, `memcpy` is only called if `dest` is large enough to hold `header_bytes`. If `dest` is not large enough, an error is handled in the else branch.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "aa25054f-301a-34a8-8f04-46f1782ef7e6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer and the size of the destination buffer are not properly checked. In the provided code snippet, `memcpy(&value, src, sizeof(value))`, there is a potential vulnerability if the size of `src` is larger than `sizeof(value)`. This can lead to overwriting of adjacent memory and can cause unexpected behavior, including program crashes, data corruption, and execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the source buffer is not larger than the destination buffer. This can be done by checking the size of the source buffer before calling `memcpy`. If the source buffer is larger, then you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif (sizeof(src) <= sizeof(value)) {\n    memcpy(&value, src, sizeof(value));\n} else {\n    // Handle the error condition, e.g., by logging an error message or throwing an exception.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "12240eb1-4ec1-35b5-b725-b8a915be3d40",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the value of `value` into `dest`. If the size of `value` is larger than the size of `dest`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif (sizeof(dest) >= sizeof(value)) {\n    memcpy(dest, &value, sizeof(value));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `dest` is larger or equal to the size of `value`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "64a04276-8c3d-3e92-ad5c-dba9807ec104",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = copyElements * sizeof(ListEl);\nif (size <= sizeof(newBuffer)) {\n    memcpy(newBuffer, m_buffer, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e65560a6-f9cd-3838-b659-e5aa6d0355da",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `copyLowerProfileSize` is larger than the size of `lowerProfile`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(lowerProfile) >= copyLowerProfileSize * sizeof(Index)) {\n    memcpy(lowerProfile, m_lowerProfile, copyLowerProfileSize * sizeof(Index));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `lowerProfile` is large enough to hold the data before calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "516d5458-ef03-3006-ae8c-35daa1a0a268",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `copyUpperProfileSize` is larger than the size of `upperProfile`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t upperProfileSize = sizeof(upperProfile) / sizeof(Index);\nif (copyUpperProfileSize <= upperProfileSize) {\n    memcpy(upperProfile, m_upperProfile, copyUpperProfileSize * sizeof(Index));\n} else {\n    // Handle error: copyUpperProfileSize is larger than the size of upperProfile\n}\n```\n\nIn this fix, we first calculate the size of `upperProfile` and then check if `copyUpperProfileSize` is larger than `upperProfileSize`. If it is, we handle the error instead of calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "39c3c578-409f-3a6f-89ad-9009e2dc89e4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `copyLowerSize` is larger than the size of `lower`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t lowerSize = sizeof(lower) / sizeof(Scalar);\nif (copyLowerSize <= lowerSize) {\n    memcpy(lower, m_lower, copyLowerSize * sizeof (Scalar));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the `lower` buffer. Then, we check if `copyLowerSize` is less than or equal to `lowerSize` before calling `memcpy`. If `copyLowerSize` is larger than `lowerSize`, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "076ad077-5a3b-3e0e-9ef3-161c7f573452",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(diag) >= copyDiagSize * sizeof(Scalar)) {\n    memcpy(diag, m_diag, copyDiagSize * sizeof (Scalar));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `diag` is large enough to hold the data being copied. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6a96b405-3662-3aee-bbc2-cb981085d9a1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crashes, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. Here is an example of how to do this:\n\n```cpp\nif (m_lowerProfileSize >= other.m_lowerProfileSize) {\n    memcpy(m_lowerProfile, other.m_lowerProfile, other.m_lowerProfileSize * sizeof(Index));\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0a0f3296-a078-3ec6-bd3a-f8ff16b55342",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `copyUpperSize` is larger than the size of `upper`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Also, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t upperSize = sizeof(upper) / sizeof(Scalar);\nif (copyUpperSize <= upperSize) {\n    memcpy(upper, m_upper, copyUpperSize * sizeof (Scalar));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the `upper` buffer. Then, we check if `copyUpperSize` is less than or equal to `upperSize` before calling `memcpy`. If `copyUpperSize` is larger than `upperSize`, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "08282e69-cb06-36f0-af21-c5ef89d83528",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will ensure that the function does not write past the end of the buffer.\n\n```cpp\nif (m_upperProfileSize >= other.m_upperProfileSize) {\n    memcpy_s(m_upperProfile, m_upperProfileSize * sizeof(Index), other.m_upperProfile, other.m_upperProfileSize * sizeof(Index));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a0636a6a-9fc4-33b3-af67-edd4ad18d920",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, data corruption, and application crashes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include size checks.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (other.upperSize() <= sizeof(m_upper)) {\n    memcpy(m_upper, other.m_upper, other.upperSize());\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source (`other.upperSize()`) is less than or equal to the size of the destination (`sizeof(m_upper)`). If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0440a437-85d5-3054-94b8-f061ee89264f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `m_diagSize * sizeof (Scalar)` is larger than the size of `m_diag`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (m_diagSize <= sizeof(m_diag) / sizeof(Scalar)) {\n    memcpy(m_diag, other.m_diag, m_diagSize * sizeof (Scalar));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `m_diagSize` is less than or equal to the size of `m_diag` divided by the size of `Scalar`. If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "414018d6-1d7d-3600-a5b1-281942e71a92",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and code execution.\n\nIn the provided code snippet, the vulnerability lies in the fact that the size of the memory block being copied `(m_outerSize + 1)` may exceed the size of the destination buffer `m_rowStartIndex`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet could be:\n\n```cpp\nsize_t size = m_outerSize + 1;\nif (size <= sizeof(m_rowStartIndex)) {\n    memcpy(m_rowStartIndex, other.m_rowStartIndex, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP and CWE Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e0c3adf1-534a-39e5-9bb6-ec29495650a5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(m_lower) >= other.lowerSize()) {\n    memcpy(m_lower, other.m_lower, other.lowerSize());\n} else {\n    // Handle the error condition, e.g., by resizing m_lower or aborting the operation\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code example.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2d6496ce-8375-3bf1-8a13-d9cf924390a2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "dd966dd2-8711-3d23-ab3b-0398ff4519ea",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fix for the specific vulnerability sink:\n\n```cpp\nsize_t size = (m_outerSize + 1) * sizeof(*m_colStartIndex);\nif (size > sizeof(m_colStartIndex)) {\n    // Handle error: source is too large\n} else {\n    memcpy(m_colStartIndex, other.m_colStartIndex, size);\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "725c3ead-87b0-3080-bb80-6258edcd0001",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer and the size of the destination buffer are not properly checked. In the provided code snippet, `memcpy(&tgt, &staged, sizeof(Tgt))`, there is a potential risk if the size of `staged` is larger than `Tgt`. This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and other security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by comparing the size of the source and destination buffers before performing the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(staged) <= sizeof(Tgt)) {\n    memcpy(&tgt, &staged, sizeof(Tgt));\n} else {\n    // Handle the error condition, perhaps by truncating the data or by allocating a larger buffer for tgt.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always ensure to check the validity of the links before using them."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6680d9e3-8ea2-3a93-a749-e1686e692ef7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e80fbf39-1012-37f3-a2e6-c0cb8b6589ee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "034e0f37-b617-3f3b-b4ab-4f4ba8c9a368",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e92f9da9-dd66-376a-ab2f-b455cde63436",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "e92f9da9-dd66-376a-ab2f-b455cde63436"
                ]
              }
            },
            {
              "id": "96957430-ac90-3d80-851b-51888b97dea3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "96957430-ac90-3d80-851b-51888b97dea3"
                ]
              }
            },
            {
              "id": "783192ee-66ee-3105-b824-2789aae99359",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "d90045bc-f037-305a-9d7f-794a07eb5b9f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "bea50275-bf91-35f5-9d20-2a5f5e3ac6c2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "67e52466-91ce-3aa0-ab73-8a6b3274c00a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or information disclosure. One such function is `sscanf`.\n\nThe `sscanf` function reads data from a string and stores them according to the parameter format into the locations pointed by the additional arguments. The potential problem with `sscanf` is that it does not perform bounds checking, and thus can cause buffer overflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `sscanf` and other unsafe C functions. Instead, use safer alternatives that perform bounds checking, such as `strncpy` for string copying, `snprintf` for string formatting, and `fgets` for reading lines of text.\n\nAlso, always validate and sanitize input data before processing it. Never trust user input blindly. Consider using libraries or frameworks that automatically handle these tasks.\n\n## Source Code Fix Recommendation\n\nInstead of `sscanf`, you can use `std::istringstream` from the C++ Standard Library for parsing strings. Here is an example:\n\n```cpp\n#include <sstream>\n#include <string>\n\nstd::string str = \"123 456\";\nint a, b;\n\nstd::istringstream iss(str);\niss >> a >> b;\n```\n\nIn this code, `std::istringstream` reads integers from the string `str` and stores them in `a` and `b`. If the string cannot be parsed as integers, `iss` will be in a fail state, and you can check this with `iss.fail()`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<sstream>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b429276c-c32c-3f98-afce-603695b3c432",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or information disclosure. One such function is `sscanf`.\n\nThe `sscanf` function reads data from a string and stores them according to the parameter format into the locations pointed by the additional arguments. The potential problem with `sscanf` is that it does not perform bounds checking, and thus can cause buffer overflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `sscanf` and other unsafe C functions. Instead, use safer alternatives that perform bounds checking, such as `strncpy` for string copying, `snprintf` for string formatting, and `fgets` for reading lines of text.\n\nAlso, always validate and sanitize input data before processing it. Never trust user input blindly. Consider using libraries or frameworks that automatically handle these tasks.\n\n## Source Code Fix Recommendation\n\nInstead of `sscanf`, you can use `std::istringstream` from the C++ Standard Library for parsing strings. Here is an example:\n\n```cpp\n#include <sstream>\n#include <string>\n\nstd::string str = \"123 456\";\nint a, b;\n\nstd::istringstream iss(str);\niss >> a >> b;\n```\n\nIn this code, `std::istringstream` reads integers from the string `str` and stores them in `a` and `b`. If the string cannot be parsed as integers, `iss` will be in a fail state, and you can check this with `iss.fail()`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<sstream>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bf85f604-d246-36da-a767-ef536fa1c594",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or information disclosure. One such function is `sscanf`.\n\nThe `sscanf` function reads data from a string and stores them according to the parameter format into the locations pointed by the additional arguments. The potential problem with `sscanf` is that it does not perform bounds checking, and thus can cause buffer overflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `sscanf` and other unsafe C functions. Instead, use safer alternatives that perform bounds checking, such as `strncpy` for string copying, `snprintf` for string formatting, and `fgets` for reading lines of text.\n\nAlso, always validate and sanitize input data before processing it. Never trust user input blindly. Consider using libraries or frameworks that automatically handle these tasks.\n\n## Source Code Fix Recommendation\n\nInstead of `sscanf`, you can use `std::istringstream` from the C++ Standard Library for parsing strings. Here is an example:\n\n```cpp\n#include <sstream>\n#include <string>\n\nstd::string str = \"123 456\";\nint a, b;\n\nstd::istringstream iss(str);\niss >> a >> b;\n```\n\nIn this code, `std::istringstream` reads integers from the string `str` and stores them in `a` and `b`. If the string cannot be parsed as integers, `iss` will be in a fail state, and you can check this with `iss.fail()`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<sstream>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7d18cb29-690e-3dc2-9a3e-32fa8aa048b9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or information disclosure. One such function is `sscanf`.\n\nThe `sscanf` function reads data from a string and stores them according to the parameter format into the locations pointed by the additional arguments. The potential problem with `sscanf` is that it does not perform bounds checking, and thus can cause buffer overflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `sscanf` and other unsafe C functions. Instead, use safer alternatives that perform bounds checking, such as `strncpy` for string copying, `snprintf` for string formatting, and `fgets` for reading lines of text.\n\nAlso, always validate and sanitize input data before processing it. Never trust user input blindly. Consider using libraries or frameworks that automatically handle these tasks.\n\n## Source Code Fix Recommendation\n\nInstead of `sscanf`, you can use `std::istringstream` from the C++ Standard Library for parsing strings. Here is an example:\n\n```cpp\n#include <sstream>\n#include <string>\n\nstd::string str = \"123 456\";\nint a, b;\n\nstd::istringstream iss(str);\niss >> a >> b;\n```\n\nIn this code, `std::istringstream` reads integers from the string `str` and stores them in `a` and `b`. If the string cannot be parsed as integers, `iss` will be in a fail state, and you can check this with `iss.fail()`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<sstream>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "44afb113-db3a-3769-82d7-69ca3a9a191c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "64b8b755-45bf-37ef-a814-4e47b011ed1d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "14ccfd3a-9b8d-3378-979d-0ee031f4e4a5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "36f1d284-de53-34cf-bef9-998caf7b8e5d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a39a4d16-994f-344d-8072-c1b25d15b76b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the data being copied is greater than the size of the destination buffer, then the program should handle this condition appropriately, such as by truncating the data, expanding the destination buffer, or by not performing the copy and reporting an error.\n\n## Source Code Fix Recommendation\n\nIn the given code snippet, the size of the destination buffer `&(m_values[nz_marker])` is not checked before calling `memcpy`. A possible fix would be to add a check before the `memcpy` call:\n\n```cpp\nsize_t dest_size = sizeof(m_values) - nz_marker * sizeof(Scalar);\nsize_t copy_size = block_size * sizeof(Scalar);\nif (copy_size <= dest_size) {\n    memcpy(&(m_values[nz_marker]), it->value().data(), copy_size);\n} else {\n    // Handle error condition\n}\n```\n\n## Library Dependencies\n\nThe given code snippet appears to depend on the following libraries:\n\n- `<cstring>` for the `memcpy` function.\n- `<cstddef>` for the `size_t` type.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ab077fa8-f208-384b-996d-ee1bc4b048ab",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "76e93c0a-7054-39ca-b105-374641a78dd5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a44457c5-322e-34c9-a5e4-0eb015908a29",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured URL Vulnerability refers to the security risk associated with the use of unsecured URLs in a C++ program. This vulnerability can be exploited by attackers to perform malicious activities such as phishing, malware injection, and data theft. In the context of C++ programming, this vulnerability can occur when a program fetches data from an unsecured URL, potentially exposing the program to malicious content.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always use secure URLs (HTTPS) instead of HTTP. HTTPS ensures that the data transferred between the server and client is encrypted and secure.\n2. Validate and sanitize all URLs before using them in the program.\n3. Avoid hardcoding URLs in the program. Instead, use configuration files or environment variables to store URLs.\n4. Use libraries and functions that support secure connections.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in the provided URL is not clear as the URL is a homepage of a library. However, if we assume that the vulnerability is about fetching data from an unsecured URL, here is a general fix recommendation:\n\n```cpp\n// Before\nstd::string unsecured_url = \"http://eigen.tuxfamily.org\";\n// Fetch data from unsecured_url\n\n// After\nstd::string secured_url = \"https://eigen.tuxfamily.org\";\n// Fetch data from secured_url\n```\n\n## Library Dependencies\n\nThe code example does not provide any specific library dependencies. However, if you are using a library to fetch data from a URL, you might need libraries such as `libcurl` or `Boost.Asio`.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n- [CWE-598: Information Exposure Through Query Strings in URL](https://cwe.mitre.org/data/definitions/598.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "597f8468-7c7f-3ccd-b886-e98161e70098",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured URL Vulnerability refers to the security risk associated with the use of unsecured URLs in a C++ program. This vulnerability can be exploited by attackers to perform malicious activities such as phishing, malware injection, and data theft. In the context of C++ programming, this vulnerability can occur when a program fetches data from an unsecured URL, potentially exposing the program to malicious content.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always use secure URLs (HTTPS) instead of HTTP. HTTPS ensures that the data transferred between the server and client is encrypted and secure.\n2. Validate and sanitize all URLs before using them in the program.\n3. Avoid hardcoding URLs in the program. Instead, use configuration files or environment variables to store URLs.\n4. Use libraries and functions that support secure connections.\n\n## Source Code Fix Recommendation\n\nThe specific vulnerability sink in the provided URL is not clear as the URL is a homepage of a library. However, if we assume that the vulnerability is about fetching data from an unsecured URL, here is a general fix recommendation:\n\n```cpp\n// Before\nstd::string unsecured_url = \"http://eigen.tuxfamily.org\";\n// Fetch data from unsecured_url\n\n// After\nstd::string secured_url = \"https://eigen.tuxfamily.org\";\n// Fetch data from secured_url\n```\n\n## Library Dependencies\n\nThe code example does not provide any specific library dependencies. However, if you are using a library to fetch data from a URL, you might need libraries such as `libcurl` or `Boost.Asio`.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n- [CWE-598: Information Exposure Through Query Strings in URL](https://cwe.mitre.org/data/definitions/598.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "4cbe22e3-e728-3457-8c79-a4e0813724dc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nIn the provided code snippet, the `rand()` function is used, which is a weak random number generator. It generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic operations, you can use `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n#include <complex>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = std::complex<T> ( T( dis(gen) ), T( dis(gen) ) );\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `<complex>`: for the complex number operations\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "4cbe22e3-e728-3457-8c79-a4e0813724dc"
                ]
              }
            },
            {
              "id": "d418fc0b-09fc-3824-b854-ac155375cf5a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nIn the provided code snippet, the `rand()` function is used, which is a weak random number generator. It generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic operations, you can use `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n#include <complex>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = std::complex<T> ( T( dis(gen) ), T( dis(gen) ) );\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `<complex>`: for the complex number operations\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "d418fc0b-09fc-3824-b854-ac155375cf5a"
                ]
              }
            },
            {
              "id": "4fded670-4afd-30c7-b608-2b8c9b7ca3a9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nIn the provided code snippet, the `rand()` function is used, which is a weak random number generator. It generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic operations, you can use `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n#include <complex>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = std::complex<T> ( T( dis(gen) ), T( dis(gen) ) );\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `<complex>`: for the complex number operations\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "4fded670-4afd-30c7-b608-2b8c9b7ca3a9"
                ]
              }
            },
            {
              "id": "d352f1db-f775-3372-90a4-1e5b9cf45471",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict future values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\nIn the given code snippet, `MatrixXd::Random(3,3)` is a weak random number generator as it uses a non-cryptographic random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that can be used for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A = Eigen::MatrixXd::Zero(3,3).unaryExpr([&](double dummy){return dis(gen);});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "c32e1388-7014-3347-8595-997bece32718",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that will be generated. This can be particularly dangerous in scenarios where these numbers are used for security-critical operations, such as generating encryption keys, random identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(3,3)`, which generates a 3x3 matrix of random floating-point numbers. However, the random number generator used by this function is not specified and may not be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic purposes, `std::random_device` is recommended, as it is designed to produce non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses `std::random_device` to generate the random numbers for the matrix:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nEigen::MatrixXf A(3,3);\nfor(int i=0; i<3; ++i)\n    for(int j=0; j<3; ++j)\n        A(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: for the random number generator\n- `Eigen/Dense`: for the `MatrixXf` class\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "c77cd837-3623-32ca-a6dd-750d3cd36b0c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function in question is `atof`.\n\nThe `atof` function converts a string to a double. It does not check for overflow or underflow, and it does not report any errors. This can lead to unexpected behavior if the string cannot be represented as a double.\n\n## Mitigation Advice\n\nAvoid using the `atof` function. Instead, use safer alternatives such as `strtod` or `sscanf`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atof` function with `strtod` or `sscanf`. Here is an example of how to use `strtod`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char* str = \"123.45\";\nchar* endptr;\nerrno = 0; // To distinguish success/failure after call\ndouble val = strtod(str, &endptr);\n\n// Check for various possible errors\nif ((errno == ERANGE && (val == HUGE_VALF || val == HUGE_VALL)) || (errno != 0 && val == 0)) {\n    perror(\"strtod\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == str) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\n// If we got here, strtod() successfully parsed a number\nprintf(\"strtod() returned %f\\n\", val);\n\nif (*endptr != '\\0') // Not necessarily an error...\n    printf(\"Further characters after number: %s\\n\", endptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n- cstdio\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e3a76444-ab07-3897-a4d1-084684e0d2fb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nIn the provided code snippet, the `rand()` function is used, which is a weak random number generator. It generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for different purposes. For cryptographic operations, you can use `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n#include <complex>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = std::complex<T> ( T( dis(gen) ), T( dis(gen) ) );\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `<complex>`: for the complex number operations\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "e3a76444-ab07-3897-a4d1-084684e0d2fb"
                ]
              }
            },
            {
              "id": "de9d29a5-c4a0-36fd-8dd5-841f78f937e7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "13d94f0c-682f-37b1-8253-37e72e2407c7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of functions or methods that generate random numbers which are not suitable for security-critical operations. The `rand()` function, for example, is a weak random number generator because it produces predictable numbers and is not suitable for generating random numbers in a cryptographic context.\n\nThe line of code `vec[k] = T( rand() )/T(RAND_MAX) - T(.5)` is an example of this vulnerability. Here, `rand()` is used to generate a random number, which is then normalized to a range between -0.5 and 0.5. However, the `rand()` function is not a secure way to generate random numbers for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a secure random number generator that is suitable for cryptographic operations. In C++, you can use functions from the `<random>` library, such as `std::random_device` or `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `std::random_device`:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = dis(gen);\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "13d94f0c-682f-37b1-8253-37e72e2407c7"
                ]
              }
            },
            {
              "id": "fd59b561-ff2d-3a90-958b-8e82f7b55756",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of functions or methods that generate random numbers which are not suitable for security-critical operations. The `rand()` function, for example, is a weak random number generator because it produces predictable numbers and is not suitable for generating random numbers in a cryptographic context.\n\nThe line of code `vec[k] = T( rand() )/T(RAND_MAX) - T(.5)` is an example of this vulnerability. Here, `rand()` is used to generate a random number, which is then normalized to a range between -0.5 and 0.5. However, the `rand()` function is not a secure way to generate random numbers for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a secure random number generator that is suitable for cryptographic operations. In C++, you can use functions from the `<random>` library, such as `std::random_device` or `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `std::random_device`:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nvec[k] = dis(gen);\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "fd59b561-ff2d-3a90-958b-8e82f7b55756"
                ]
              }
            },
            {
              "id": "bf92539b-f315-30c1-931b-29bfcc1a6042",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, potentially leading to a security breach.\n\nIn the given code snippet, `MatrixXi::Random(3,4)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf m = Eigen::MatrixXf::Zero(3,4).unaryExpr([&](float dummy){return dis(gen);});\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure random number generator. Then, `std::uniform_real_distribution` is used to generate random numbers in the range [-1, 1]. Finally, these random numbers are used to populate the matrix `m`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard C++ library for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is used for linear algebra operations.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "714bf76d-5a5b-3429-9e25-849a759ad327",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXcf::Random(2,2)`, which generates a 2x2 matrix of complex float numbers with random values. If this function uses a non-cryptographic or weak random number generator, it could lead to predictable outcomes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf a(2,2);\nfor (int i=0; i<2; ++i)\n    for (int j=0; j<2; ++j)\n        a(i,j) = std::complex<float>(dis(gen), dis(gen));\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure random number generator. `std::uniform_real_distribution<>` is used to generate random float numbers between -1 and 1, which are then used to create the complex float numbers for the matrix.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generators and distributions.\n- `<Eigen/Dense>`: for the `MatrixXcf` class.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "5ff775c3-543d-3fa5-9c65-1ceb1c27f40d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the system, leading to a variety of attacks such as brute force attacks, session prediction, and more.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix4d A;\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        A(i, j) = dis(gen);\n```\n\nIn this code, we use the Mersenne Twister algorithm (`std::mt19937`) as a random number generator, which is a widely used and robust random number generator suitable for cryptographic use. We also use `std::uniform_real_distribution<>` to generate a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "9447cf9d-7654-38c5-962b-5691c2ac66ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. This can lead to a variety of security issues, such as predictability in password generation, session identifiers, or other security-critical values.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXd::Random(5,5)`, which generates a 5x5 matrix of random numbers. However, the randomness of these numbers is not guaranteed to be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a secure random number generator that is suitable for cryptographic use. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrixXd X = MatrixXd::NullaryExpr(5,5, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "f401c856-320f-35bd-b9dc-b479841bb85d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "6fe7c369-a1a2-32c3-ad0a-b02ab91f3e18",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. This can lead to a variety of security issues, such as predictability in password generation, session identifiers, or other security-critical values.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXd::Random(5,5)`, which generates a 5x5 matrix of random numbers. However, the randomness of these numbers is not guaranteed to be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a secure random number generator that is suitable for cryptographic use. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrixXd X = MatrixXd::NullaryExpr(5,5, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "527eaa60-b063-38cc-9fb2-89b0a2d5b169",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. This can lead to a variety of security issues, such as predictability in password generation, session identifiers, or other security-critical values.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXd::Random(5,5)`, which generates a 5x5 matrix of random numbers. However, the randomness of these numbers is not guaranteed to be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a secure random number generator that is suitable for cryptographic use. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrixXd X = MatrixXd::NullaryExpr(5,5, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "2af9ebd1-f815-31ba-8447-b4bff7e24365",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "78f1867a-2c10-3292-9d02-2620d162fec5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, potentially leading to a security breach.\n\nIn the given code snippet, `MatrixXi::Random(3,4)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf m = Eigen::MatrixXf::Zero(3,4).unaryExpr([&](float dummy){return dis(gen);});\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure random number generator. Then, `std::uniform_real_distribution` is used to generate random numbers in the range [-1, 1]. Finally, these random numbers are used to populate the matrix `m`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard C++ library for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is used for linear algebra operations.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0c449cd9-8b70-3972-bed6-4ddf445882e5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\nIn the given code example, `MatrixXf::Random(4,4)` is used to generate a 4x4 matrix of random floating point numbers. However, the `Random` function in Eigen library is not cryptographically secure, which makes it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code example using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf X(4,4);\nfor(int i=0; i<4; ++i)\n    for(int j=0; j<4; ++j)\n        X(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`), and `std::uniform_real_distribution` is used to generate random floating point numbers between -1 and 1. These random numbers are then used to fill the matrix `X`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "91454575-edd8-3c7a-a5fc-8af75f943902",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the given code example, `MatrixXf::Random(5,3)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf A = Eigen::MatrixXf::Zero(5,3);\n\nfor(int i=0; i<A.rows(); ++i)\n    for(int j=0; j<A.cols(); ++j)\n        A(i,j) = dis(gen);\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used with a uniform real distribution to generate random numbers. This engine is seeded with a random device (`std::random_device`), which provides a source of non-deterministic random numbers.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "7d986658-9dda-3b4e-91a2-9736fa4383fb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other similar attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides facilities to generate random numbers with high quality of randomness.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXcf::Random(4,4)`, you can use the `std::random_device` and `std::mt19937` from the `<random>` library to generate a matrix of random numbers. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf A(4, 4);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0fb17a26-8830-3ab1-b665-25ea612d9b1f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the generator.\n\nIn the given code example, `MatrixXd::Random(6,6)` is used to generate a 6x6 matrix of random numbers. However, the `Random()` function from the Eigen library is not cryptographically secure, making it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A(6,6);\nfor(int i=0; i<6; ++i)\n    for(int j=0; j<6; ++j)\n        A(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister generator `std::mt19937`, which is a cryptographically secure pseudorandom number generator. `std::uniform_real_distribution<>` is then used to generate random numbers in the range [-1, 1], which is the same range as `MatrixXd::Random()`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "fa22f8e7-9067-344f-a6d8-b56508d785a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that will be generated. This can lead to a variety of security issues, such as the ability to predict session IDs, encryption keys, or other sensitive data.\n\nThe specific vulnerability sink in the provided code is the use of `Matrix4Xd::Random(4,5)`, which uses a non-cryptographic random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix4Xd M(4,5);\nfor(int i=0; i<M.rows(); ++i)\n    for(int j=0; j<M.cols(); ++j)\n        M(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "7c2b7708-e7f4-352c-ac5b-9cbe58a5cf2c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the generator.\n\nIn the given code example, `MatrixXd::Random(6,6)` is used to generate a 6x6 matrix of random numbers. However, the `Random()` function from the Eigen library is not cryptographically secure, making it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A(6,6);\nfor(int i=0; i<6; ++i)\n    for(int j=0; j<6; ++j)\n        A(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister generator `std::mt19937`, which is a cryptographically secure pseudorandom number generator. `std::uniform_real_distribution<>` is then used to generate random numbers in the range [-1, 1], which is the same range as `MatrixXd::Random()`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "c3c96ce3-3521-3167-a7f7-7318e4e59a58",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\nIn the given code snippet, `MatrixXi::Random(4,6)` is a weak random number generator as it does not provide cryptographically secure random numbers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographically secure random number generator. In C++, you can use the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to use the `<random>` library to generate cryptographically secure random numbers:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nfor (int n=0; n<10; ++n)\n    std::cout << dis(gen) << ' ';\nstd::cout << '\\n';\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This library is used to generate random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0ee3343a-3c18-34c0-80f0-7f3447a0dbc1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\nIn the given code example, `MatrixXf::Random(4,4)` is used to generate a 4x4 matrix of random floating point numbers. However, the `Random` function in Eigen library is not cryptographically secure, which makes it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code example using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf X(4,4);\nfor(int i=0; i<4; ++i)\n    for(int j=0; j<4; ++j)\n        X(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`), and `std::uniform_real_distribution` is used to generate random floating point numbers between -1 and 1. These random numbers are then used to fill the matrix `X`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a812ceda-ac2b-3a8d-86b3-bf5845f57074",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that the generator will produce. This can lead to serious security issues, especially in applications where the random numbers are used for security-critical operations such as generating encryption keys, random identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. If the underlying random number generator used by `MatrixXf::Random` is not cryptographically secure, this could lead to the aforementioned security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses the `std::random_device` class from the `<random>` library to generate random floating-point numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::MatrixXf A(4,4);\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        A(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: This is a standard C++ library that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e45ede20-ba7d-3ade-83fb-5ffd95bd2f4b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `alloca()` is used, which is considered unsafe.\n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size of the allocation is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits via `longjmp()`.\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use functions that allocate memory on the heap, such as `malloc()`, `calloc()`, or `new` in C++. These functions do not have the same risks as `alloca()`. However, remember to free the memory allocated with `malloc()` or `calloc()` using `free()`, and the memory allocated with `new` using `delete`.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `new`:\n\n```cpp\nint* jpiv = new int[N];\n```\n\nRemember to free the memory when you're done with it:\n\n```cpp\ndelete[] jpiv;\n```\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4be47059-21bd-3233-9816-58e00783422e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other similar attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides facilities to generate random numbers with high quality of randomness.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXcf::Random(4,4)`, you can use the `std::random_device` and `std::mt19937` from the `<random>` library to generate a matrix of random numbers. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf A(4, 4);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "00b1f2a5-2444-3e5c-a2ce-99849cd4cf3d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0504c979-3e1f-38ab-abd3-5ff0137680c1",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `alloca` function is used, which is a potential source of vulnerability.\n\nThe `alloca` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca` returns. This can lead to stack overflow if the size of the allocation is too large, which can in turn lead to arbitrary code execution.\n\n## Mitigation Advice\n\nAvoid using the `alloca` function. Instead, use functions that allocate memory on the heap, such as `malloc`, `calloc`, or `new`. These functions do not have the risk of causing stack overflow. However, they require manual memory management, so be sure to free or delete the memory when you're done with it to avoid memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca` function with `new`:\n\n```cpp\nint* ipiv = new int[N];\n```\n\nDon't forget to delete the memory when you're done with it:\n\n```cpp\ndelete[] ipiv;\n```\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-121: Stack-based Buffer Overflow](https://cwe.mitre.org/data/definitions/121.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cf3fe8e2-62ce-3533-aef0-1774775e70c7",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `alloca` function is used, which is a potential source of vulnerability.\n\nThe `alloca` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca` returns. This can lead to stack overflow if the size of the allocation is too large, which can in turn lead to arbitrary code execution.\n\n## Mitigation Advice\n\nAvoid using the `alloca` function. Instead, use functions that allocate memory on the heap, such as `malloc`, `calloc`, or `new`. These functions do not have the risk of causing stack overflow. However, they require manual memory management, so be sure to free or delete the memory when you're done with it to avoid memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca` function with `new`:\n\n```cpp\nint* ipiv = new int[N];\n```\n\nDon't forget to delete the memory when you're done with it:\n\n```cpp\ndelete[] ipiv;\n```\n\n## Library Dependencies\n\nThe code example does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-121: Stack-based Buffer Overflow](https://cwe.mitre.org/data/definitions/121.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bdb083fc-006b-3351-8586-223120398812",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other similar attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides facilities to generate random numbers with high quality of randomness.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXcf::Random(4,4)`, you can use the `std::random_device` and `std::mt19937` from the `<random>` library to generate a matrix of random numbers. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf A(4, 4);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "925846aa-f227-3784-bad2-73d4e4e56301",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which can lead to integer overflow or underflow if the input is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these insecure functions. For `atoi()`, a safer alternative would be `strtol()` or `sscanf()`. These functions provide error checking which can prevent integer overflows and underflows.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example using `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong int window_half_width = strtol(argv[2], &endptr, 10);\n\nif (errno == ERANGE) {\n    // handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "53d51183-2beb-3750-98b9-b0d118d2d29c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values, leading to a breach of security.\n\nIn the given code snippet, `MatrixXi::Random(2,3)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nEigen::MatrixXi m(2,3);\nfor(int i=0; i<2; ++i)\n    for(int j=0; j<3; ++j)\n        m(i,j) = dis(gen);\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used, which is a cryptographically secure random number generator. The `std::uniform_int_distribution<>` is used to generate random numbers in a specified range.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is used for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "28227fc5-f89d-3fda-a491-0752aebcc272",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `atoi()` is used, which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. This can lead to integer overflow or underflow if the string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform error checking. For example, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong int stop_cut_size = strtol(argv[3], &end, 10);\nif (end == argv[3] || *end != '\\0' || errno == ERANGE) {\n    // handle error\n}\n```\n\nIn this code, `strtol()` converts the string to a long integer and provides a way to check for errors. If the conversion is unsuccessful, `end` will point to the start of the string. If the string contains additional characters after the number, `end` will point to these characters. If the number is out of range, `errno` will be set to `ERANGE`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cb19944e-54b7-348b-a71f-8369c4ca2831",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace `atoi(argv[2])` with `std::stoi(argv[2])`. Make sure to handle the possible exceptions.\n\n```cpp\n#include <string>\n#include <stdexcept>\n\nint start_cut_size;\ntry {\n    start_cut_size = std::stoi(argv[2]);\n} catch (std::invalid_argument& e) {\n    // Handle exception: input string does not represent a valid integer\n} catch (std::out_of_range& e) {\n    // Handle exception: converted value would fall out of the range of the result type\n}\n```\n\n## Library Dependencies\n\n- `<string>`: for `std::stoi()`\n- `<stdexcept>`: for `std::invalid_argument` and `std::out_of_range`\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6df0f168-f792-3f79-beaf-bf92ac351b32",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable outputs and can be exploited by attackers to predict the sequence of random numbers, which can compromise the security of the application.\n\nIn the given code snippet, `b = VectorXf::Random(3)`, a non-cryptographic random number generator is used to generate a vector of random floating point numbers. This can be a potential security vulnerability if the generated random numbers are used in a security-sensitive context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::VectorXf b(3);\nfor (int i = 0; i < 3; ++i)\n    b(i) = dis(gen);\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used with a uniform real distribution to generate cryptographically secure random floating point numbers.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a24a5345-a860-32e6-9dbf-bc2bd5801cda",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict future values generated by the random number generator, leading to potential security risks.\n\nIn the given code snippet, `MatrixXf::Random(3, 2)` is used to generate a random matrix. However, the `Random()` function in Eigen library is not a cryptographic random number generator, and it may not provide sufficient randomness for security-sensitive operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographic random number generator that is designed to be unpredictable and resistant to attacks. In C++, you can use functions provided by libraries such as `<random>` or OpenSSL's `RAND_bytes()`.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to use `<random>` to generate a random matrix:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nEigen::MatrixXf A(3, 2);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = dis(gen);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "3785b26f-4afb-3179-b50a-27d93d06f441",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\nIn the given code snippet, `MatrixXi::Random(4,6)` is a weak random number generator as it does not provide cryptographically secure random numbers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographically secure random number generator. In C++, you can use the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to use the `<random>` library to generate cryptographically secure random numbers:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nfor (int n=0; n<10; ++n)\n    std::cout << dis(gen) << ' ';\nstd::cout << '\\n';\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This library is used to generate random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "06928318-f5f3-3e22-ae47-f7c35fd15023",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values, leading to a breach of security.\n\nIn the given code snippet, `MatrixXi::Random(2,3)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nEigen::MatrixXi m(2,3);\nfor(int i=0; i<2; ++i)\n    for(int j=0; j<3; ++j)\n        m(i,j) = dis(gen);\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used, which is a cryptographically secure random number generator. The `std::uniform_int_distribution<>` is used to generate random numbers in a specified range.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is used for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "70cb10f6-4c15-3de4-a030-47b4a8996f74",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `atoi()` is used which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform error checking. For instance, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example using `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong int max_in_cache = strtol(argv[3], &endptr, 10);\n\nif (errno == ERANGE){\n    // handle overflow\n} else if (endptr == argv[3]){\n    // handle no digits were found\n} else if (*endptr != '\\0'){\n    // handle further characters after digits\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d331582f-5ff7-3b7a-9d69-6ce43eb9f693",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable outputs and can be exploited by attackers to predict the sequence of random numbers, which can compromise the security of the application.\n\nIn the given code snippet, `Matrix3Xd::Random(3,5)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix3Xd M(3,5);\nfor(int i=0; i<M.size(); i++)\n    M(i) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: This is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: This is a standard C++ library that provides facilities to generate random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "c6a0f325-bdc0-31da-af35-00d5fe46d18a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a prohibited function because it does not perform any error checking and can lead to integer overflow.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives that perform error checking. For `atoi()`, a safer alternative is `strtol()`, which allows for error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is how you can do it:\n\n```cpp\nchar *end;\nlong int max_out_of_cache = strtol(argv[5], &end, 10);\nif (end == argv[5] || *end != '\\0' || errno == ERANGE) {\n    // handle error\n}\n```\n\nIn this code, `strtol()` is used to convert the string to a long integer. If the conversion fails or if the converted value is out of range, an error is handled.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "63942f60-be83-3c1d-947d-7cf4d22e915b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the given code snippet, the function `atoi()` is used which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform error checking. For example, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong val = strtol(argv[4], &endptr, 10);\n\nif ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) || (errno != 0 && val == 0)) {\n    perror(\"strtol\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == argv[4]) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\nmin_out_of_cache = val;\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b5cba995-ae0b-3e70-9483-97be5c4b81e9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflow attacks. In this case, the `atoi()` function is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For the `atoi()` function, a safer alternative is `std::stoi()`, which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n#include <cstdlib>\n\n// ...\n\ntry {\n    min_in_cache = std::stoi(argv[2]);\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>`: for `std::stoi()`\n- `<cstdlib>`: for `std::invalid_argument` and `std::out_of_range`\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "58d0b67b-2ba5-3f2a-b37c-645aa90c423e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\nIn the given code snippet, `MatrixXf::Random(2, 3)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf mat(2, 3);\nfor(int i=0; i<2; ++i)\n    for(int j=0; j<3; ++j)\n        mat(i,j) = dis(gen);\n```\n\nIn this code, a Mersenne Twister generator (`std::mt19937`) is used, which is a cryptographically secure random number generator. The `std::uniform_real_distribution` is used to generate random floating-point numbers between -1 and 1, similar to `MatrixXf::Random`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "4dd2ee8c-1ff6-3a04-a73a-a67708c6157b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other similar attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides facilities to generate random numbers with high quality of randomness.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXcf::Random(4,4)`, you can use the `std::random_device` and `std::mt19937` from the `<random>` library to generate a matrix of random numbers. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf A(4, 4);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e15d867e-6093-386e-a1f8-210795c29e4e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the generator.\n\nIn the given code example, `MatrixXd::Random(6,6)` is used to generate a 6x6 matrix of random numbers. However, the `Random()` function from the Eigen library is not cryptographically secure, making it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A(6,6);\nfor(int i=0; i<6; ++i)\n    for(int j=0; j<6; ++j)\n        A(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister generator `std::mt19937`, which is a cryptographically secure pseudorandom number generator. `std::uniform_real_distribution<>` is then used to generate random numbers in the range [-1, 1], which is the same range as `MatrixXd::Random()`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "098997c9-a126-3a89-839b-3628090fd608",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix4f X = Eigen::Matrix4f::NullaryExpr(4,4,[&](){return dis(gen);});\n```\n\nIn this code, we are using the Mersenne Twister engine (`std::mt19937`) seeded with a random device (`std::random_device`) to generate random numbers. The `std::uniform_real_distribution` is used to generate random floating-point numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "7b829881-e339-34ea-a081-fde268c00cd4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. For instance, in C++, you can use `std::stoi()` which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    Instance.tries = std::stoi(config[i+1].c_str());\n} catch (std::invalid_argument& e) {\n    // handle error: the conversion failed because the string doesn't represent a valid number\n} catch (std::out_of_range& e) {\n    // handle error: the conversion failed because the number is out of the range of representable values\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>`: for `std::stoi()`\n- `<stdexcept>`: for `std::invalid_argument` and `std::out_of_range`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cbe6ce47-848d-3923-ba75-55a472ce43a1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `getenv` function is used, which can lead to security vulnerabilities if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or that are not susceptible to the same vulnerabilities. In the case of `getenv`, consider whether the environment can be controlled by an attacker and if so, use a different method to configure your program.\n\n## Source Code Fix Recommendation\n\nThe `getenv` function is used to get the value of an environment variable. If the environment variable is controlled by an attacker, they could set it to a value that causes your program to behave in unexpected ways. To fix this, you could use a configuration file instead of an environment variable to configure your program. Here is an example of how you could do this:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string get_config(const std::string& config_file_path) {\n    std::ifstream config_file(config_file_path);\n    std::string config;\n    std::getline(config_file, config);\n    return config;\n}\n\nint main() {\n    std::string config_file_path = \"/path/to/config/file\";\n    std::string _config = get_config(config_file_path);\n    // rest of your code\n}\n```\n\nIn this example, the `get_config` function reads the configuration from a file instead of from an environment variable. This is safer because an attacker cannot control the contents of the file unless they have write access to the file system.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>` for `getenv`\n- `<fstream>` for `std::ifstream`\n- `<string>` for `std::string`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c76f7b2c-662c-35b8-833a-15889e017eb6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable outputs and can be exploited by attackers to predict the sequence of random numbers, which can compromise the security of the application.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. However, the random number generator used by this function may not be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf B = Eigen::MatrixXf::Zero(4,4);\n\nfor (int i = 0; i < B.rows(); ++i) {\n    for (int j = 0; j < B.cols(); ++j) {\n        B(i, j) = dis(gen);\n    }\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`), and `std::uniform_real_distribution` is used to generate random floating-point numbers in the range [-1, 1].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e5b5b358-0a2d-328e-896c-a6277b3c5138",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that the generator will produce. This can lead to serious security issues, especially in applications where the random numbers are used for security-critical operations such as generating encryption keys, random identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. If the underlying random number generator used by `MatrixXf::Random` is not cryptographically secure, this could lead to the aforementioned security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses the `std::random_device` class from the `<random>` library to generate random floating-point numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::MatrixXf A(4,4);\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        A(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: This is a standard C++ library that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "161e81a7-40ad-3e46-9dea-f0b47d07fd99",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. This can lead to a variety of security issues, such as predictability in password generation, session identifiers, or other security-critical values.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXd::Random(5,5)`, which generates a 5x5 matrix of random numbers. However, the randomness of these numbers is not guaranteed to be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a secure random number generator that is suitable for cryptographic use. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrixXd X = MatrixXd::NullaryExpr(5,5, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "ea1fc4a1-7003-3eca-b45d-2798857144b0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in generating sensitive data. This can lead to predictability in the generated numbers, making the system vulnerable to attacks. \n\nIn the given code snippet, `MatrixType::Random(a.rows(), a.cols())` is used to generate random numbers. If `MatrixType::Random` uses a weak or non-cryptographic random number generator, it can lead to this vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. C++ provides a cryptographic random number generator in the `<random>` library. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\nEigen::MatrixXd m = Eigen::MatrixXd::Zero(a.rows(), a.cols());\n\nfor (int i = 0; i < a.rows(); ++i)\n{\n    for (int j = 0; j < a.cols(); ++j)\n    {\n        m(i, j) = dis(gen);\n    }\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a strong random number generator. `std::uniform_real_distribution` is then used to generate random numbers in the range [0, 1].\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: for the random number generator and distribution.\n- `<Eigen/Dense>`: for the `Eigen::MatrixXd` type.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "43f9b1eb-5299-303b-8cd2-435bf00d1ab3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "706de43f-f56f-3aef-8480-f4316bf81416",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, leading to a variety of security issues.\n\nIn the given code snippet, `MatrixXd::Random(3,2)` is a weak random number generator as it uses a non-cryptographic random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks, making them suitable for generating sensitive data such as encryption keys, random nonces, and other security-related numbers.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXd::Random(3,2)`, use a cryptographic random number generator. Here is an example using the `<random>` library in C++:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd B = Eigen::MatrixXd::Zero(3,2);\n\nfor(int i=0; i<B.size(); i++)\n{\n    B(i) = dis(gen);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "4b2a7cdd-cdeb-3eb1-b262-ef86e5f9ee76",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict future values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\nIn the given code snippet, `MatrixXd::Random(3,3)` is a weak random number generator as it uses a non-cryptographic random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that can be used for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A = Eigen::MatrixXd::Zero(3,3).unaryExpr([&](double dummy){return dis(gen);});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "ab4e11b4-c527-3070-b34d-f90bed0219c6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the given code example, `MatrixXd::Random(4,4)` is used to generate a 4x4 matrix of random numbers. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks, making them suitable for generating random numbers in a security context.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXd::Random(4,4)`, you can use a cryptographic library to generate random numbers. Here is an example using the OpenSSL library:\n\n```cpp\n#include <openssl/rand.h>\n\nMatrixXd X(4,4);\nfor(int i=0; i<4; i++)\n{\n    for(int j=0; j<4; j++)\n    {\n        unsigned char buffer[4];\n        RAND_bytes(buffer, 4);\n        int num = *reinterpret_cast<int*>(buffer);\n        X(i,j) = num;\n    }\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the OpenSSL library to execute properly.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "fa8c6851-73b7-315b-84ee-697f2d92ceeb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "1a272e94-1c6e-39ba-a6b7-f9587080801b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\nIn the given code snippet, `MatrixXi::Random(4,6)` is a weak random number generator as it does not provide cryptographically secure random numbers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographically secure random number generator. In C++, you can use the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to use the `<random>` library to generate cryptographically secure random numbers:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nfor (int n=0; n<10; ++n)\n    std::cout << dis(gen) << ' ';\nstd::cout << '\\n';\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This library is used to generate random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "6d9deb45-2e85-3c57-8107-2c32d0a5aaed",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that will be generated. This can be particularly dangerous in scenarios where random numbers are used for security-critical operations, such as generating encryption keys, random tokens, or passwords.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(3,5)`, which generates a matrix of random floating-point numbers. If this function uses a non-cryptographic or weak random number generator, the generated numbers could be predictable.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses the `std::random_device` and `std::mt19937` from the `<random>` library to generate cryptographically secure random numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::MatrixXf RandomMatrix(int rows, int cols) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<> dis(-1.0, 1.0);\n\n    Eigen::MatrixXf m(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            m(i, j) = dis(gen);\n        }\n    }\n    return m;\n}\n\nint main() {\n    Eigen::MatrixXf m = RandomMatrix(3, 5);\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: Provides facilities to generate random numbers.\n- `<Eigen/Dense>`: Provides Matrix and Array classes, along with the operations that can be performed on them.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "b178abdc-3936-3754-9d61-fe4dec39fd89",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the given code example, `MatrixXd::Random(4,4)` is used to generate a 4x4 matrix of random numbers. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks, making them suitable for generating random numbers in a security context.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXd::Random(4,4)`, you can use a cryptographic library to generate random numbers. Here is an example using the OpenSSL library:\n\n```cpp\n#include <openssl/rand.h>\n\nMatrixXd X(4,4);\nfor(int i=0; i<4; i++)\n{\n    for(int j=0; j<4; j++)\n    {\n        unsigned char buffer[4];\n        RAND_bytes(buffer, 4);\n        int num = *reinterpret_cast<int*>(buffer);\n        X(i,j) = num;\n    }\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the OpenSSL library to execute properly.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "ea12388b-7d71-3a70-a760-710c99e53396",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of random number generators that are not cryptographically strong. These weak random number generators can produce predictable outcomes, which can be exploited by an attacker to predict future values generated by the random number generator. This can lead to various security issues, such as session prediction, password cracking, and other forms of information leakage.\n\nIn the provided code snippet, the function `Eigen::VectorXf::Random(3)` is used to generate a random vector. However, the Eigen library does not use a cryptographically secure random number generator, making it vulnerable to this type of attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::VectorXf b(3);\nfor (int i = 0; i < 3; ++i)\n{\n    b(i) = dis(gen);\n}\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used with a uniform real distribution. The engine is seeded with a random device (`std::random_device`), which should provide a good amount of entropy.\n\n## Library Dependencies\n\nThe provided code snippet requires the Eigen library. The fixed code snippet additionally requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "ee7756ca-f9d8-3213-b4a5-fb53e16a7fd5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\nIn the given code snippet, `Eigen::MatrixXi::Random(4,4)` is used to generate a 4x4 matrix of random integers. However, the `Random()` function in Eigen library is not cryptographically secure, making it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(-10, 10);\n\nEigen::MatrixXi A(4,4);\nfor(int i=0; i<4; ++i)\n    for(int j=0; j<4; ++j)\n        A(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`). `std::uniform_int_distribution<>` is then used to generate random integers in the range [-10, 10]. These random numbers are used to populate the matrix `A`.\n\n## Library Dependencies\n\nThe code requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "648c2e6b-3157-3d47-9b25-831a0d56ecf1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other similar attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides facilities to generate random numbers with high quality of randomness.\n\n## Source Code Fix Recommendation\n\nInstead of using `MatrixXcf::Random(4,4)`, you can use the `std::random_device` and `std::mt19937` from the `<random>` library to generate a matrix of random numbers. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf A(4, 4);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ for generating random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library for linear algebra.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a07b42de-b2d7-31d5-8873-02551f8eb5e0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random values, leading to a variety of security issues.\n\nIn the given code snippet, `Eigen::MatrixXf::Random(3, 2)` is used to generate a random matrix. However, the Eigen library's `Random()` function is not a cryptographic random number generator, and thus may not be suitable for security-sensitive operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographic random number generator instead of a weak or non-cryptographic one. In C++, you can use libraries such as `<random>` and `<cryptopp>` that provide cryptographic random number generators.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to use the `<random>` library to generate a random number:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nEigen::MatrixXf A = Eigen::MatrixXf::Zero(3, 2);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = dis(gen);\n    }\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographic random number generator. Then, `std::uniform_real_distribution` is used to generate random floating-point numbers between -1.0 and 1.0, which are then used to fill the matrix.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e7458822-a60b-311d-adf2-f20b41787544",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nIn the given code example, `Eigen::ArrayXf::Random(5)` is used to generate an array of 5 random floating point numbers. However, Eigen's `Random()` function is not cryptographically secure, making it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::ArrayXf a(5);\nfor(int i=0; i<5; ++i)\n{\n    a(i) = dis(gen);\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure pseudorandom number generator. `std::uniform_real_distribution<>` is then used to generate random floating point numbers in the range [-1, 1], similar to `Eigen::ArrayXf::Random()`.\n\n## Library Dependencies\n\nThe code example requires the Eigen library for the `Eigen::ArrayXf` class and the `<random>` library for the random number generation.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "9a6b7b4d-c0ca-3b15-b914-a0084ae00190",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable randomness which can be exploited by an attacker to predict the outcome of the random number generator. This can be particularly dangerous in scenarios where the random number is used for security-critical operations such as generating encryption keys, random identifiers, etc.\n\nIn the provided code snippet, the function `Eigen::MatrixXd::Random(n,n).sparseView(0.5,1)` is used to generate a random matrix. The `Eigen::MatrixXd::Random` function uses a non-cryptographic random number generator which makes it vulnerable to this type of attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Sparse>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::SparseMatrix<double> S(n, n);\nfor (int i=0; i<n; ++i)\n    for (int j=0; j<n; ++j)\n        S.insert(i, j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "86481644-aff6-32d4-a362-0fa34f953f32",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will keep reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, the `strlen` function is used without checking if the string `it->second->Name()` is null-terminated. This can lead to the aforementioned vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the string passed to `strlen` is null-terminated. This can be done by initializing strings with a null character or by manually adding a null character at the end of the string.\n\nAdditionally, consider using safer alternatives to `strlen` that take a maximum length parameter to prevent reading past the end of the string. Functions like `strnlen` can be used to avoid this vulnerability.\n\n## Source Code Fix Recommendation\n\nA safer version of the code snippet would look like this:\n\n```cpp\nstd::string name = it->second->Name();\nname_width = static_cast<int>(strnlen(name.c_str(), name.size()));\n```\n\nIn this version, `strnlen` is used instead of `strlen`. The maximum length parameter is set to the size of the string, preventing `strnlen` from reading past the end of the string.\n\n## Library Dependencies\n\nThe code snippet requires the following library dependencies:\n\n- `<cstring>` for `strlen` and `strnlen`\n- `<string>` for `std::string`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "00718a42-c756-3907-a2d8-840092bd0411",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the given code snippet, the `Random()` function from the Eigen library is used to generate a random matrix. This function uses a non-cryptographic random number generator, which makes it vulnerable to this type of attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks. They should be used in any context where the predictability of the generated values can lead to a security vulnerability.\n\n## Source Code Fix Recommendation\n\nThe Eigen library does not provide a cryptographic random number generator. Therefore, you will need to use a different library or implement your own cryptographic random number generator. Here is an example using the `std::random_device` from the C++ Standard Library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> mat(10, 10);\nfor (int i = 0; i < mat.rows(); ++i)\n    for (int j = 0; j < mat.cols(); ++j)\n        mat(i, j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a8afcc76-461a-36cf-ab51-df0023400e14",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values, leading to a breach of security.\n\nIn the given code snippet, `MatrixXcf::Random(2, 3)` is used to generate a matrix of random complex float numbers. However, the `Random()` function is not cryptographically secure, making it a potential security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXcf v(2, 3);\nfor (int i = 0; i < v.rows(); ++i) {\n    for (int j = 0; j < v.cols(); ++j) {\n        v(i, j) = std::complex<float>(dis(gen), dis(gen));\n    }\n}\n```\n\nIn this code, a `std::mt19937` generator is used, which is a Mersenne Twister random number generator. This generator is seeded with a `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "83ecaa1e-8de2-32d4-83b8-d77ffbe0d269",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXcd::Random(4,4)`, which generates a 4x4 matrix of complex numbers with random real and imaginary parts. This function uses a non-cryptographic random number generator, which can lead to predictable values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::default_random_engine generator(rd());\nstd::uniform_real_distribution<double> distribution(-1.0, 1.0);\n\nEigen::MatrixXcd X(4,4);\nfor(int i=0; i<X.rows(); i++)\n    for(int j=0; j<X.cols(); j++)\n        X(i,j) = std::complex<double>(distribution(generator), distribution(generator));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "3471d5e3-4d6d-3d34-af3b-8d71aa3f1190",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values, leading to a breach of security.\n\nIn the given code snippet, `b = MatrixXd::Random(100,50)`, a non-cryptographic random number generator is used to generate a matrix of random numbers. This could potentially be exploited if the random numbers are used in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code snippet that uses a cryptographically secure random number generator to generate a matrix of random numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd m(100,50);\nfor(int i=0; i<m.size(); i++)\n    m(i) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "8fb2a1b9-8342-37ef-a570-3b8d17f41443",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nIn the given code example, `MatrixXd::Random(100,100)` is used to generate a 100x100 matrix of random numbers. However, the `Random()` function from the Eigen library is not cryptographically secure, making it a potential vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code example using the `<random>` library to generate a 100x100 matrix of random numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd A(100, 100);\nfor (int i = 0; i < 100; ++i)\n    for (int j = 0; j < 100; ++j)\n        A(i, j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "24fa4720-14b0-3455-9dca-1d5d053c43ce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nIn the given code example, `Matrix4d::Random(4,4)` is used to generate a 4x4 matrix of random numbers. If the `Random()` function uses a non-cryptographic or weak random number generator, it could be a potential security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrix4d X;\nfor(int i=0; i<4; i++)\n    for(int j=0; j<4; j++)\n        X(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure random number generator. `std::uniform_real_distribution<>` is then used to generate random numbers in the range [-1, 1].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `Eigen/Dense`: for the `Matrix4d` class\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "3fa73e0f-3cf0-313d-96f3-27b282a1c078",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the provided code, the `Random()` function from the Eigen library is used to generate a random matrix. This function uses a non-cryptographic random number generator, which makes it vulnerable to this type of attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks. They are suitable for generating random numbers used in cryptographic algorithms and protocols.\n\nIn C++, the `<random>` library provides several cryptographic random number generators, such as `std::random_device` and `std::mt19937`. These generators should be used instead of non-cryptographic ones.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code using the `std::random_device` generator:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> mat(10, 10);\nfor (int i = 0; i < mat.rows(); ++i)\n    for (int j = 0; j < mat.cols(); ++j)\n        mat(i, j) = dis(gen);\n\nqr = FullPivHouseholderQR.FullPivHouseholderQR(mat);\n```\n\n## Library Dependencies\n\nThe provided code requires the following libraries to execute properly:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "24f84c2d-d1ec-3348-8dd4-e884aa387a61",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\nIn the provided code snippet, the `Random()` function from the Eigen library is used to generate a random matrix. This function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks. They are suitable for tasks that require a high level of security, such as generating encryption keys, random nonces, or other security-related parameters.\n\n## Source Code Fix Recommendation\n\nReplace the `Random()` function with a cryptographic random number generator. Unfortunately, the Eigen library does not provide a cryptographic random number generator. You may need to use another library, such as the OpenSSL library, to generate cryptographically secure random numbers.\n\nHere is an example of how you can generate a random matrix using the OpenSSL library:\n\n```cpp\n#include <openssl/rand.h>\n\nMatrix<SCALAR,Dynamic,Dynamic> randomMatrix(int rows, int cols) {\n    Matrix<SCALAR,Dynamic,Dynamic> mat(rows, cols);\n    for(int i=0; i<rows; i++) {\n        for(int j=0; j<cols; j++) {\n            unsigned char buffer[sizeof(SCALAR)];\n            RAND_bytes(buffer, sizeof(SCALAR));\n            SCALAR randomValue;\n            memcpy(&randomValue, buffer, sizeof(SCALAR));\n            mat(i,j) = randomValue;\n        }\n    }\n    return mat;\n}\n\nqr = BDCSVD.BDCSVD(randomMatrix(10,10));\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the Eigen library. The recommended code fix requires the OpenSSL library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "72565025-f622-331a-ae4b-f7cf0e019e7c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the random number generation, which can lead to various security issues such as session prediction, password cracking, and other forms of information leakage.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. The C++ Standard Library provides a variety of random number generators that can be used, such as `std::random_device`, `std::mt19937`, and `std::uniform_int_distribution`. These generators provide a higher level of randomness and are more difficult for an attacker to predict.\n\n## Source Code Fix Recommendation\n\nReplace the weak random number generator with a strong cryptographic random number generator. Here is an example of how to do this using `std::random_device`:\n\n```cpp\n#include <Eigen/Dense>\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> mat(10, 10);\nfor (int i = 0; i < mat.rows(); ++i) {\n    for (int j = 0; j < mat.cols(); ++j) {\n        mat(i, j) = dis(gen);\n    }\n}\n\nEigen::EigenSolver<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>> eig(mat);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "fdd37cc0-b0df-3a2d-ba8a-7b646c0c8be7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable randomness which can be exploited by an attacker to predict future random numbers generated by the system. This can compromise the security of the system, especially in cases where these random numbers are used for security-critical operations such as encryption, session identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of the `Random()` function from the Eigen library to generate a random matrix for the Householder QR decomposition. This function uses a non-cryptographic random number generator, which can lead to predictable randomness.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<SCALAR, Eigen::Dynamic, Eigen::Dynamic> mat(10, 10);\nfor (int i = 0; i < mat.rows(); ++i) {\n    for (int j = 0; j < mat.cols(); ++j) {\n        mat(i, j) = dis(gen);\n    }\n}\n\nauto qr = mat.householderQr();\n```\n\n## Library Dependencies\n\nThe provided code requires the Eigen library to execute properly.\n\n## OWASP and CWE Links\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "abb149b6-1b05-34b7-bcee-e661ee03d126",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\nIn the provided code snippet, the `Matrix::Random()` function is used to generate a random matrix. If this function uses a non-cryptographic or weak random number generator, it could lead to the aforementioned vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<SCALAR,Dynamic,Dynamic> mat(10,10);\nfor(int i=0; i<mat.size(); i++)\n    mat(i) = dis(gen);\n\nllt = LLT.LLT(mat);\n```\n\nIn this code, a `std::random_device` is used to seed a `std::mt19937` generator, which is a Mersenne Twister random number generator. A `std::uniform_real_distribution` is then used to generate random numbers in the range [-1, 1], which is the same range as `Matrix::Random()`.\n\n## Library Dependencies\n\nThe provided code snippet requires the Eigen library to execute properly.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "91774497-19f9-3004-ae28-7a8c908c4689",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the random number generation, which can lead to various security issues such as session prediction, password cracking, and other forms of information leakage.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. The C++ Standard Library provides a variety of random number generators that can be used, such as `std::random_device`, `std::mt19937`, and `std::uniform_int_distribution`. These generators provide a higher level of randomness and are more difficult for an attacker to predict.\n\n## Source Code Fix Recommendation\n\nReplace the weak random number generator with a strong cryptographic random number generator. Here is an example of how to do this using `std::random_device`:\n\n```cpp\n#include <Eigen/Dense>\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> mat(10, 10);\nfor (int i = 0; i < mat.rows(); ++i) {\n    for (int j = 0; j < mat.cols(); ++j) {\n        mat(i, j) = dis(gen);\n    }\n}\n\nEigen::EigenSolver<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>> eig(mat);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "8581efbd-3748-3d47-b796-084855972a13",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator that produces values that are not predictable or easily guessable. The C++ Standard Library provides a number of random number generators that can be used, such as `std::random_device` and `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device device_;\nstd::mt19937 generator(device_());\nstd::shuffle(A.begin(), A.end(), generator);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator `std::mt19937`, which is then used to shuffle the elements in the container `A`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "95ecab2e-9c6b-3280-bedb-4e67be232fde",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator that produces values that are not predictable or easily guessable. The C++ Standard Library provides a number of random number generators that can be used, such as `std::random_device` and `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device device_;\nstd::mt19937 generator(device_());\nstd::shuffle(A.begin(), A.end(), generator);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator `std::mt19937`, which is then used to shuffle the elements in the container `A`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "ee9fb880-1917-3a6a-85be-b1cc78bc9142",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the provided code snippet, the `Random()` function from the Eigen library is used to generate a random matrix. This function uses a non-cryptographic random number generator, which makes it vulnerable to this type of attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<SCALAR,Dynamic,Dynamic> mat(10,10);\nfor(int i=0; i<mat.size(); i++)\n    mat(i) = dis(gen);\n\nqr = JacobiSVD.JacobiSVD(mat);\n```\n\nIn this code, a `std::mt19937` generator is used, which is a Mersenne Twister random number generator. This generator is seeded with a `std::random_device`, which is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. Then, a `std::uniform_real_distribution` is used to generate random floating-point numbers between -1 and 1.\n\n## Library Dependencies\n\nThe provided code snippet requires the Eigen library to execute properly.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "6be9ff3a-f245-3b77-ade3-fda20d6cf221",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values, leading to a breach of security.\n\nIn the given code snippet, `ArrayXcf::Random(3)` is a weak random number generator as it does not provide cryptographically secure random numbers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nv = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "308efe6a-a341-3b83-a6c2-7bc8fb1927d4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. This can lead to a variety of security issues, such as predictability in password generation, session identifiers, or other security-critical values.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXd::Random(5,5)`, which generates a 5x5 matrix of random numbers. However, the randomness of these numbers is not guaranteed to be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a secure random number generator that is suitable for cryptographic use. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for different purposes.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrixXd X = MatrixXd::NullaryExpr(5,5, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates a uniform distribution of random numbers between -1 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "c07f7da2-ecef-30e1-9914-c280f5d93407",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the provided code snippet, a random matrix is being generated using the `Random` function from the Eigen library. This function uses a non-cryptographic random number generator, which makes it vulnerable to this type of attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<SCALAR,Dynamic,Dynamic> mat(10,10);\nfor(int i=0; i<mat.size(); i++)\n    mat(i) = dis(gen);\n\nlu = PartialPivLU.PartialPivLU(mat);\n```\n\nIn this code, a random number generator is created using `std::mt19937`, which is a Mersenne Twister random number generator. This generator is seeded with a value from `std::random_device`, which is a non-deterministic random number generator. The `std::uniform_real_distribution` is used to generate random floating-point numbers between -1 and 1.\n\n## Library Dependencies\n\nThe provided code snippet requires the Eigen library to execute properly.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "c0d6671f-e8fb-3535-a2dd-2b96f12bb493",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the misuse of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code, the `memcpy` function is used inside a loop, which can potentially lead to a buffer overflow if the size of the copied data (`m_ * m_ * sizeof(T)`) exceeds the size of the destination buffer (`c_`).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the copied data. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `memcpy_s` or `strncpy`, which include additional checks to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\n```cpp\nmemcpy(int num_iters) {\n    eigen_assert(m_ == k_ && k_ == n_);\n#ifdef EIGEN_USE_SYCL // warmup for sycl\n    for (int iter = 0; iter < 10; ++iter) {\n        if (sizeof(c_) >= m_ * m_ * sizeof(T)) { // Check if destination buffer is large enough\n            device_.memcpy(c_, a_, m_ * m_ * sizeof(T));\n        } else {\n            // Handle error\n        }\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example seems to depend on the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2c77ac38-9b3c-3f9a-a4a3-ad46ad8eb42e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the system, leading to a variety of attacks such as brute force attacks, session prediction, and more.\n\nIn the provided code snippet, the `Random()` function from the Eigen library is used to generate a random matrix. This function uses a non-cryptographic random number generator, which makes it vulnerable to the aforementioned attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks. They are typically used in cryptographic applications where the quality of randomness is crucial.\n\nIn C++, the `<random>` library provides a variety of cryptographic random number generators. For example, `std::random_device` can be used to generate non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet using `std::random_device`:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> mat(10, 10);\nfor (int i = 0; i < mat.rows(); ++i) {\n    for (int j = 0; j < mat.cols(); ++j) {\n        mat(i, j) = dis(gen);\n    }\n}\n\nEigen::ColPivHouseholderQR<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>> qr(mat);\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "bc90a1fe-b788-31b1-b59e-0bcdef091f3f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "4dfb7747-05b8-3fe6-a3f4-098857a63f3c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\nIn the given code snippet, `VectorXf::Random(cols)` is used to generate random numbers. However, this function does not use a cryptographically secure random number generator, making it vulnerable to this type of attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::VectorXf x(cols);\nfor (int i = 0; i < cols; ++i) {\n    x(i) = dis(gen);\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`), which is a cryptographically secure random number generator. `std::uniform_real_distribution` is then used to generate random floating-point numbers between -1 and 1, which is the same range as `VectorXf::Random()`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0d603b02-21a6-3057-ba6c-050071a6591a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination are both members of the same object, which increases the likelihood of overlap, especially since the base identifier is the same. Additionally, there are no checks ensuring that the source and destination are non-null, which could lead to null pointer dereference. The absence of explicit bounds checks or guards further increases the risk. The verdict is supported by the classification and the high-confidence 'GENUINE' label from the analysis.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, ensure that the source and destination do not overlap. If overlap is possible, use a memory copy function that is safe for overlapping regions, such as `memmove`, instead of a function that is not, such as `memcpy`. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation. For example:\n\n```cpp\nif (c_ != nullptr && a_ != nullptr) {\n    // Use memmove if overlap is possible\n    device_.memmove(c_, a_, m_ * m_ * sizeof(T));\n}\n```\n\nThis approach ensures that the operation is safe even if the memory regions overlap and avoids null pointer dereference. Always validate the size calculation to prevent buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c8741afe-95d7-35ef-83fa-8bf35aa18032",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, potentially leading to a security breach.\n\nIn the given code snippet, `MatrixXf::Random(3,2)` is used to generate a random matrix. However, this function uses a non-cryptographic random number generator, which makes it vulnerable.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf m(3,2);\nfor(int i=0; i<m.size(); i++)\n    m(i) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`). Then, `std::uniform_real_distribution` is used to generate random floating-point numbers between -1 and 1, which are then used to populate the matrix.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: for the random number generator and distribution.\n- `<Eigen/Dense>`: for the `Eigen::MatrixXf` class.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0a2ded21-5dde-3a1d-91ee-7d3419f5b74f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nIn the given code example, `Matrix4d::Random(4,4)` is used to generate a 4x4 matrix of random numbers. If the `Random()` function uses a non-cryptographic or weak random number generator, it could be a potential security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nMatrix4d X;\nfor(int i=0; i<4; i++)\n    for(int j=0; j<4; j++)\n        X(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure random number generator. `std::uniform_real_distribution<>` is then used to generate random numbers in the range [-1, 1].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for the random number generator\n- `Eigen/Dense`: for the `Matrix4d` class\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a6b83241-c500-3380-8524-4501ff856f5e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable randomness which can be exploited by an attacker to predict the outcome of the random number generator, leading to a breach of security.\n\nThe specific vulnerability sink in the provided code is the use of `VectorXf::Random(cols)`. This function generates a vector of random floating-point numbers, but it does not guarantee that these numbers are cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nEigen::VectorXf b(cols);\nfor (int i = 0; i < cols; ++i) {\n    b(i) = dis(gen);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "94738489-2106-3bd8-a3a7-ef39ad61bf04",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable randomness which can be exploited by an attacker to predict the outcome of the random number generator, leading to a potential security breach.\n\nIn the given code snippet, `VectorXf::Random(12)*0.1` is used to generate random numbers. However, this method is not cryptographically secure and can lead to the aforementioned vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\nelevations = 2*samples.col(0) + 3*samples.col(1) + VectorXf::Constant(12, dis(gen)*0.1);\n```\n\nIn this fix, we use the Mersenne Twister algorithm (`std::mt19937`) which is a cryptographically secure random number generator. We also use `std::uniform_real_distribution<>` to generate a uniform distribution of random numbers between 0 and 1.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen library for `VectorXf`\n- `<random>` library for random number generation\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "097354a3-20bb-32a6-88c5-4e4ec9093d18",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the generator. This can lead to serious security issues, especially in applications where randomness is crucial, such as in cryptographic key generation, password generation, or in any other security-related functionality.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `std::random_device` class from the `<random>` library, which is designed to produce non-deterministic random numbers. If a non-deterministic source is not available, the implementation may use a pseudo-random number engine.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nsamples = DataMatrix::Random(12,2, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister pseudo-random number generator (`std::mt19937`). Then, `std::uniform_int_distribution` is used to generate random numbers in the range [1, 6]. The lambda function is passed to `DataMatrix::Random` to generate the random numbers.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "08af604d-5f6e-364c-a94b-25a12c6f49c1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to a variety of security issues.\n\nIn the provided code snippet, the `Random()` function from the Eigen library is used to generate a random matrix. This function uses a non-cryptographic random number generator, which makes it vulnerable to this issue.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::Matrix<SCALAR, Eigen::Dynamic, Eigen::Dynamic> mat(10, 10);\nfor (int i = 0; i < 10; ++i)\n    for (int j = 0; j < 10; ++j)\n        mat(i, j) = dis(gen);\n\nEigen::LDLT<Eigen::Matrix<SCALAR, Eigen::Dynamic, Eigen::Dynamic>> ldlt = mat.ldlt();\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the Eigen library to execute properly.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "7b979444-c708-3887-bc3b-0e611050871b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that the generator will produce. This can lead to serious security issues, especially in applications where the random numbers are used for security-critical operations such as generating encryption keys, random identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. If the underlying random number generator used by `MatrixXf::Random` is not cryptographically secure, this could lead to the aforementioned security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses the `std::random_device` class from the `<random>` library to generate random floating-point numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::MatrixXf A(4,4);\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        A(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: This is a standard C++ library that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "d89002c3-5d02-3a30-aeb0-558db0a02469",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the system, leading to a variety of attacks such as brute force attacks, session prediction, and more.\n\nThe specific vulnerability sink in the provided code is the use of `DenseVector::Random(cols)`. This function generates a vector of random numbers, but it does not specify the type of random number generator used, which could potentially be a weak or non-cryptographic one.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators, including some that are cryptographically secure.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, cols);\n\nx = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "93243b6e-6c70-3b9a-bdf2-f7afcc7b12be",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nThe specific vulnerability sink in the provided code is the use of `DenseVector::Random(cols)`, which generates a random vector of a specified size. If the random number generator used by this function is not cryptographically secure, it could lead to predictable vectors being generated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nReplace the use of `DenseVector::Random(cols)` with a cryptographically secure random number generator. Here is an example using the `std::random_device` and `std::uniform_int_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(0, cols);\n\nb = DenseVector::Constant(cols, dis(gen));\n```\n\nThis code will generate a random vector of size `cols` with values between 0 and `cols`, using a cryptographically secure random number generator.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: Provides random number generation facilities.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "37c8c6aa-9128-305b-9ab1-4dbd10f8cbab",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict future values and compromise the security of the system.\n\nIn the given code example, `MatrixXf::Random(3,8)` is used to generate a matrix of random floating point numbers. However, this function uses a non-cryptographic random number generator, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. These generators are designed to be unpredictable and resistant to attacks, making them suitable for generating secure random numbers.\n\nIn C++, the `<random>` library provides a variety of cryptographic random number generators, such as `std::random_device` and `std::mt19937`. These can be used to replace the non-cryptographic random number generator in the code.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf M1 = Eigen::MatrixXf::Zero(3,8).unaryExpr([&](float dummy){return dis(gen);});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "d9b0b068-eb3b-3627-a69c-60f36ff6fa7f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `std::rand()` function is a non-cryptographic random number generator that is not suitable for generating random numbers in a security context. It can be predictable and easily reproduced, which can lead to security risks such as predictability in password generation, session identifiers, or cryptographic keys.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. In C++, the `<random>` library provides a variety of random number generators that can be used for cryptographic purposes. These generators are designed to produce numbers that are statistically random and unpredictable, making them suitable for use in security-sensitive contexts.\n\n## Source Code Fix Recommendation\n\nReplace the `std::rand()` function with a cryptographic random number generator. Here is an example of how to do this using the `<random>` library in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random_number = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_real_distribution` produces random floating-point numbers in the range [0, 1).\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "d9b0b068-eb3b-3627-a69c-60f36ff6fa7f"
                ]
              }
            },
            {
              "id": "6bf94a2f-bc65-3e90-ba95-7f5ef70faba8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `std::rand()` function is a non-cryptographic random number generator that is not suitable for generating random numbers in a security context. It can be predictable and easily reproduced, which can lead to security risks such as predictability in password generation, session identifiers, or cryptographic keys.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. In C++, the `<random>` library provides a variety of random number generators that can be used for cryptographic purposes. These generators are designed to produce numbers that are statistically random and unpredictable, making them suitable for use in security-sensitive contexts.\n\n## Source Code Fix Recommendation\n\nReplace the `std::rand()` function with a cryptographic random number generator. Here is an example of how to do this using the `<random>` library in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random_number = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_real_distribution` produces random floating-point numbers in the range [0, 1).\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "6bf94a2f-bc65-3e90-ba95-7f5ef70faba8"
                ]
              }
            },
            {
              "id": "73de4eb9-162a-3f8e-8d04-157d3745e633",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `std::rand()` function is a non-cryptographic random number generator that is not suitable for generating random numbers in a security context. It can be predictable and easily reproduced, which can lead to security risks such as predictability in password generation, session identifiers, or cryptographic keys.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. In C++, the `<random>` library provides a variety of random number generators that can be used for cryptographic purposes. These generators are designed to produce numbers that are statistically random and unpredictable, making them suitable for use in security-sensitive contexts.\n\n## Source Code Fix Recommendation\n\nReplace the `std::rand()` function with a cryptographic random number generator. Here is an example of how to do this using the `<random>` library in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random_number = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_real_distribution` produces random floating-point numbers in the range [0, 1).\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "73de4eb9-162a-3f8e-8d04-157d3745e633"
                ]
              }
            },
            {
              "id": "14578636-f215-312f-b850-b9fd1f578061",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `std::rand()` function is a non-cryptographic random number generator that is not suitable for generating random numbers in a security context. It can be predictable and easily reproduced, which can lead to security risks such as predictability in password generation, session identifiers, or cryptographic keys.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. In C++, the `<random>` library provides a variety of random number generators that can be used for cryptographic purposes. These generators are designed to produce numbers that are statistically random and unpredictable, making them suitable for use in security-sensitive contexts.\n\n## Source Code Fix Recommendation\n\nReplace the `std::rand()` function with a cryptographic random number generator. Here is an example of how to do this using the `<random>` library in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random_number = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_real_distribution` produces random floating-point numbers in the range [0, 1).\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "14578636-f215-312f-b850-b9fd1f578061"
                ]
              }
            },
            {
              "id": "f8b39d1f-245c-3c31-ac5c-039c0201b01f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that will be generated. This can lead to a variety of security issues, such as the ability to predict session IDs, encryption keys, or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `std::random_device` class from the `<random>` library, which is designed to produce non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nInstead of using `Matrix3f::Random(3,3)`, you can use `std::random_device` to generate random numbers for your matrix. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::Matrix3f A;\nstd::random_device rd;\n\nfor(int i=0; i<A.rows(); i++)\n{\n    for(int j=0; j<A.cols(); j++)\n    {\n        A(i,j) = static_cast <float> (rd()) / static_cast <float> (rd.max());\n    }\n}\n```\n\n## Library Dependencies\n\nThe above code requires the following libraries:\n\n- `<random>`: for `std::random_device`\n- `<Eigen/Dense>`: for `Eigen::Matrix3f`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "89004ba3-1e5f-3157-8d9a-952e909ce140",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the random number generation, leading to potential security risks.\n\nIn the given code snippet, `a = MatrixType::Random(rows,cols)`, a weak random number generator might be used to generate the matrix, which could lead to predictable outcomes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use strong cryptographic random number generators. In C++, you can use libraries like `<random>` which provides a variety of random number generators that can be used for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nfor (int n=0; n<10; ++n)\n    a = MatrixType::Random(dis(gen),dis(gen));\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "1ec81b03-f1fe-36b5-90c0-6b9ea0089d9a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nThe `random_shuffle` function in C++ uses a non-cryptographic random number generator, which makes it vulnerable to this issue. This function is often used to randomly rearrange elements in a range, but the predictability of the random numbers can lead to security risks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved by using the `random_device` class from the `<random>` library, which is designed to produce random numbers with a high degree of randomness.\n\n## Source Code Fix Recommendation\n\nReplace the `random_shuffle` function with the `shuffle` function, which allows you to specify a random number generator. Use `random_device` as the generator:\n\n```cpp\n#include <random>\n#include <algorithm>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 g(rd());\n\nstd::shuffle(benchmarks.begin(), benchmarks.end(), g);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for `std::random_device` and `std::mt19937`\n- `<algorithm>`: for `std::shuffle`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "b30876ee-e4c8-39ad-a86d-8d0c0d460737",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "9552c8bd-5c16-335e-a5f0-48a38041b154",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nThis vulnerability is particularly dangerous in security-sensitive contexts, such as when generating cryptographic keys, random nonces, or any other secret values. If an attacker can predict these values, they can potentially break the security of the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators, including some that are cryptographically secure.\n\nAvoid using functions like `rand()`, `drand48()`, and similar, as these are not cryptographically secure. Also, be aware that even if a random number generator is cryptographically secure, it must be properly seeded to ensure its randomness. Using a predictable seed, such as the current time, can also lead to predictable output.\n\n## Source Code Fix Recommendation\n\nReplace the `Random()` function with a cryptographically secure random number generator. Here is an example using the `std::random_device` and `std::uniform_int_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nmb = MyMatrix::Random(gen(),N);\n```\n\nIn this example, `std::random_device` is a non-deterministic random number generator, and `std::uniform_int_distribution` is a distribution that produces integer values evenly distributed across a specified range.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "9de72476-6f8c-3dad-b0e5-c0bd5e76dabd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe or insecure. These functions are often prohibited because they do not perform bounds checking or other necessary validation, which can lead to buffer overflow attacks, format string vulnerabilities, or other security issues.\n\nIn the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `filename` parameter is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `fopen` function. In C++, the `fstream` library provides the `ifstream` and `ofstream` classes that can be used for file reading and writing, respectively. These classes provide more robust error checking and exception handling.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string filename;\n// ... (filename is set somewhere)\nstd::ifstream file(filename);\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: for the `std::ifstream` class\n- `<string>`: for the `std::string` class\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9cdc5be8-858b-351d-a608-8ea791399b08",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the filename is not properly validated or controlled. An attacker could potentially manipulate the filename to overwrite important files or create new files in unintended locations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and error checking. In the case of `fopen`, it is important to validate and control the filename that is passed to the function. \n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file;\nfile.open(filename);\nif (!file.is_open()) {\n    // Handle error\n}\n```\n\nIn this example, the C++ `ofstream` class is used instead of the C `fopen` function. The `ofstream` class provides better error handling and is generally safer to use.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n* fstream\n\n## References\n\n* [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e1d7d9e0-6be0-3a2b-8d46-f9967517349c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nThis vulnerability is particularly dangerous in cryptographic contexts, where the security of the system often relies on the unpredictability of random numbers (e.g., for generating keys, initialization vectors, nonces, etc.). However, it can also be a problem in other contexts where randomness is important, such as in gaming or simulations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators, including some that are cryptographically secure.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nmc = MyMatrix::Random(M,N, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is a non-deterministic random number generator, and `std::mt19937` is a Mersenne Twister random number generator. `std::uniform_int_distribution<>` is used to generate random numbers in a specified range.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "8bb98f16-2aad-365d-8a8a-06d770940ce0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nma = MyMatrix::Random(M,K,gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "16555058-ca36-36d6-9d17-84ccc9c5cde4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nThis vulnerability is particularly dangerous in cryptographic contexts, where the security of the system often relies on the unpredictability of random numbers (e.g., for generating keys, initialization vectors, nonces, etc.). However, it can also be a problem in other contexts where randomness is important, such as in gaming or simulations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators, including some that are cryptographically secure.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nmc = MyMatrix::Random(M,N, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is a non-deterministic random number generator, and `std::mt19937` is a Mersenne Twister random number generator. `std::uniform_int_distribution<>` is used to generate random numbers in a specified range.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "f75d7b0d-5df9-35e3-91f1-5bdf488a3be1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nThis vulnerability is particularly dangerous in security-sensitive contexts, such as when generating cryptographic keys, random nonces, or any other secret values. If an attacker can predict these values, they can potentially break the security of the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators, including some that are cryptographically secure.\n\nAvoid using functions like `rand()`, `drand48()`, and similar, as these are not cryptographically secure. Also, be aware that even if a random number generator is cryptographically secure, it must be properly seeded to ensure its randomness. Using a predictable seed, such as the current time, can also lead to predictable output.\n\n## Source Code Fix Recommendation\n\nReplace the `Random()` function with a cryptographically secure random number generator. Here is an example using the `std::random_device` and `std::uniform_int_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nmb = MyMatrix::Random(gen(),N);\n```\n\nIn this example, `std::random_device` is a non-deterministic random number generator, and `std::uniform_int_distribution` is a distribution that produces integer values evenly distributed across a specified range.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "8cece632-1926-38d8-944e-352e0ce9fc01",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nma = MyMatrix::Random(M,K,gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "64a54e90-e49b-3fad-9ea3-a817cb9e872a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nThis vulnerability is particularly dangerous in cryptographic contexts, where the security of the system often relies on the unpredictability of random numbers (e.g., for generating keys, initialization vectors, nonces, etc.). However, it can also be a problem in other contexts where randomness is important, such as in gaming or simulations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators, including some that are cryptographically secure.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nmc = MyMatrix::Random(M,N, [&]() { return dis(gen); });\n```\n\nIn this code, `std::random_device` is a non-deterministic random number generator, and `std::mt19937` is a Mersenne Twister random number generator. `std::uniform_int_distribution<>` is used to generate random numbers in a specified range.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "2b6a9a68-e718-3aa2-a494-fc09fd65b3a5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even the entire state of the random number generator.\n\nThis vulnerability is particularly dangerous in security-sensitive contexts, such as when generating cryptographic keys, random nonces, or any other secret values. If an attacker can predict these values, they can potentially break the security of the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators, including some that are cryptographically secure.\n\nAvoid using functions like `rand()`, `drand48()`, and similar, as these are not cryptographically secure. Also, be aware that even if a random number generator is cryptographically secure, it must be properly seeded to ensure its randomness. Using a predictable seed, such as the current time, can also lead to predictable output.\n\n## Source Code Fix Recommendation\n\nReplace the `Random()` function with a cryptographically secure random number generator. Here is an example using the `std::random_device` and `std::uniform_int_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nmb = MyMatrix::Random(gen(),N);\n```\n\nIn this example, `std::random_device` is a non-deterministic random number generator, and `std::uniform_int_distribution` is a distribution that produces integer values evenly distributed across a specified range.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "77737424-0fa0-3a11-ba7a-c58da917a5f9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the program, leading to potential security risks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nma = MyMatrix::Random(M,K,gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "e640ae1c-e595-3a4b-a97a-f4b6b3e4158a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflow attacks. In this case, the function `atoi()` is used, which can lead to integer overflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation before using them. For `atoi()`, it is recommended to use `strtol()` or `sscanf()` instead, as these functions provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong int K = strtol(argv[3], &endptr, 10);\n\nif (errno == ERANGE) {\n    // handle overflow\n} else if (endptr == argv[3]) {\n    // handle no digits were found\n} else {\n    // handle additional error checking\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ec9acaac-6d61-3545-a142-e2ae92d254d9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which is a standard library function in C++ that converts a string into an integer. The problem with `atoi()` is that it does not perform any error checking. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using `atoi()` function. Instead, use safer alternatives that perform error checking, such as `strtol()` or `sscanf()`. Always validate and sanitize user input to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example of how to do it:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong int M = strtol(argv[1], &endptr, 10);\n\nif (errno == ERANGE) {\n    // handle overflow\n} else if (endptr == argv[1]) {\n    // handle no digits were found\n} else {\n    // handle additional checks if necessary\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n- `<cerrno>`: This header file declares the integer variable errno, which is set by system calls and some library functions in the event of an error to indicate what went wrong.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4419f75f-caa5-38b7-9652-f32844c99580",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `atoi()` is used, which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. This can lead to undefined behavior if the string cannot be converted to an integer.\n\n## Mitigation Advice\n\nAvoid using prohibited C functions that do not perform error checking. Instead, use safer alternatives that perform error checking. For example, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong int nbtries = strtol(argv[5], &end, 10);\nif (end == argv[5] || *end != '\\0' || errno == ERANGE) {\n    // handle error\n}\n```\n\nIn this code, `strtol()` converts the string to a long integer and provides error checking. If the string cannot be converted to a long integer, an error is raised.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for the `atoi()` function\n- `errno.h`: for the `errno` variable\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0f2a42ef-70e3-3f4f-a2a6-1ee138cac2bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which is a standard C library function that converts a string to an integer. The problem with `atoi()` is that it does not handle errors well. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using `atoi()` function. Instead, use safer alternatives such as `strtol()` or `sscanf()`, which provide error checking. Always validate and sanitize user input to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for strtol and NULL\n\nchar *p;\nlong converted = strtol(argv[4], &p, 10);\nif (*p) {\n    // conversion failed because the input wasn't a number\n} else {\n    nbloops = converted;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fa663eb9-1798-325b-bc6b-33a4fb825295",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a standard C library function that converts a string to an integer. The problem with `atoi()` is that it does not handle errors properly. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using `atoi()`. Instead, use functions that can handle errors properly. In C++, you can use `std::stoi()`, which throws an exception if the conversion fails. Always validate and sanitize user input to prevent injection attacks.\n\n## Source Code Fix\n\nReplace `atoi()` with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n#include <cstdlib>\n\ntry {\n    N = std::stoi(argv[2]);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code requires the following libraries:\n\n- `<string>`: for `std::stoi()`\n- `<cstdlib>`: for `std::invalid_argument` and `std::out_of_range`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "01f91b8e-584e-3e6d-8ae7-1cb139fe8320",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a standard function in C++ for converting a string to an integer. The problem with `atoi()` is that it does not handle errors well. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using `atoi()`. Instead, use functions that can handle errors properly. In C++, you can use `std::stoi()`, which throws an exception if the conversion fails. Always validate and sanitize user input to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `std::stoi()` and add error handling:\n\n```cpp\n#include <string>\n#include <cstdlib>\n\ntry {\n    nbtries = std::stoi(argv[3]);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<string>`: for `std::stoi()`\n- `<cstdlib>`: for `std::invalid_argument` and `std::out_of_range`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4f215ecb-d884-396a-ab70-8cf0f90ac387",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using the `atoi()` function. Instead, use functions that perform error checking such as `strtol()`. Always validate and sanitize user input to prevent injection attacks. \n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is an example of how to do it:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong int nbloops = strtol(argv[2], &endptr, 10);\n\nif (errno == ERANGE){\n    // handle overflow\n} else if (endptr == argv[2]){\n    // handle no digits were found\n} else if (*endptr != '\\0'){\n    // handle further characters after digits\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ef4a0543-f378-3ca9-972f-87e7c7f949ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `atoi()` is used, which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. This can lead to undefined behavior if the string cannot be converted to an integer.\n\n## Mitigation Advice\n\nAvoid using prohibited C functions that do not perform error checking or that can lead to security vulnerabilities. Instead, use safer alternatives that perform error checking. For example, instead of using `atoi()`, you can use `strtol()` or `sscanf()`, which perform error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *end;\nlong int M, N, K;\n\nerrno = 0;\nM = N = K = strtol(argv[1], &end, 10);\nif (errno == ERANGE) {\n    // handle overflow\n} else if (end == argv[1]) {\n    // handle no digits were found\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "03fdced5-ef41-3e4a-89cd-7092f259384e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, such as `strtol()` or `sscanf()`, which provide error checking. Additionally, always validate and sanitize user input to prevent unexpected behavior.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is an example of how to do it:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong int val = strtol(argv[2], &endptr, 10);\n\nif ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) || (errno != 0 && val == 0)) {\n    perror(\"strtol\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == argv[2]) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\nM = N = K = val;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()` and `exit()`\n- `<cerrno>`: for `errno`\n- `<climits>`: for `LONG_MAX` and `LONG_MIN`\n- `<cstdio>`: for `perror()`, `fprintf()`, and `stderr`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "38dc4b96-1184-321a-b026-9149e3c840e8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `atoi()` is used, which is a prohibited C function. The `atoi()` function converts a string to an integer and it does not perform any error checking. This can lead to undefined behavior if the string cannot be converted to an integer.\n\n## Mitigation Advice\n\nAvoid using prohibited C functions that do not perform error checking or that can lead to security vulnerabilities. Instead, use safer alternatives that perform error checking. For example, instead of using `atoi()`, you can use `strtol()` or `sscanf()`, which perform error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *end;\nlong int M, N, K;\n\nerrno = 0;\nM = N = K = strtol(argv[1], &end, 10);\nif (errno == ERANGE) {\n    // handle overflow\n} else if (end == argv[1]) {\n    // handle no digits were found\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "03974536-a330-3446-8f71-ce598e519834",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. These generators are designed to produce random numbers that are unpredictable and resistant to attacks. They are typically used in cryptographic applications where the quality of randomness is crucial.\n\n## Source Code Fix Recommendation\n\nInstead of using `ArrayXXi::Random(4,4).abs()`, you can use a cryptographically secure random number generator like `std::random_device` from the `<random>` library in C++. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> distr(0, 100);\n\nfor(int i=0; i<4; i++)\n{\n    for(int j=0; j<4; j++)\n    {\n        A(i,j) = distr(gen);\n    }\n}\n```\n\nIn this code, `std::random_device` is a non-deterministic random number generator, and `std::mt19937` is a Mersenne Twister pseudorandom generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution<>` produces random integers in a specified range.\n\n## Library Dependencies\n\nThe code example requires the `<random>` library for the random number generator.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "5e47bb2f-e16d-3530-b450-325d97b0daee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable outputs and can be exploited by attackers to predict the sequence of random numbers, which can compromise the security of the application.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. However, the random number generator used by this function may not be cryptographically secure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf B = Eigen::MatrixXf::Zero(4,4);\n\nfor (int i = 0; i < B.rows(); ++i) {\n    for (int j = 0; j < B.cols(); ++j) {\n        B(i, j) = dis(gen);\n    }\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister random number generator (`std::mt19937`), and `std::uniform_real_distribution` is used to generate random floating-point numbers in the range [-1, 1].\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "4f93962c-0bc5-349f-a6b4-1bb0fc9d6266",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that the generator will produce. This can lead to serious security issues, especially in applications where the random numbers are used for security-critical operations such as generating encryption keys, random identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. If the underlying random number generator used by `MatrixXf::Random` is not cryptographically secure, this could lead to the aforementioned security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses the `std::random_device` class from the `<random>` library to generate random floating-point numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::MatrixXf A(4,4);\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        A(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: This is a standard C++ library that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "47ea0e79-3483-3e7a-8c8e-1a52cbb928a5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable randomness which can be exploited by an attacker to predict future random numbers generated by the system. This can compromise the security of the system, especially in cases where these random numbers are used for security-critical operations such as generating encryption keys, random nonces, etc.\n\nThe specific vulnerability sink in the provided code is the use of `VectorXi::Random(4)`. This function generates a vector of 4 random integers. However, the randomness of these numbers is not cryptographically secure, making it a potential security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nEigen::VectorXi v(4);\nfor (int i = 0; i < 4; ++i) {\n    v(i) = dis(gen);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "94c3e479-26ff-3629-93f2-1d0e6cbc24cf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, which can lead to various security issues such as session prediction, password cracking, and other forms of information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator that produces non-predictable and non-reproducible values. In C++, this can be achieved by using the `std::random_device` or `std::mt19937` (Mersenne Twister 19937 generator) from the `<random>` library, which are designed to produce high-quality random numbers.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the specific vulnerability sink:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nusing namespace Eigen;\n\nint main() {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<> dis(-1, 1);\n\n    VectorXcf vcf(512);\n    for (int i = 0; i < vcf.size(); ++i) {\n        vcf[i] = Complex<float>(dis(gen), dis(gen));\n    }\n    vcf *= y;\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister generator `std::mt19937`, which generates high-quality random numbers. These random numbers are then used to populate the `VectorXcf` object.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: for `std::random_device` and `std::mt19937`\n- `<Eigen/Dense>`: for `Eigen::VectorXcf`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "1b411abb-72ec-3b67-8df3-727f1b309eef",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\nIn the given code snippet, `VectorXd::Random(512) * y` generates a vector of 512 random numbers. However, the `Random()` function from the Eigen library is not cryptographically secure, making it a potential security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::VectorXd vd(512);\nfor (int i = 0; i < 512; ++i)\n{\n    vd(i) = dis(gen) * y;\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure pseudorandom number generator. `std::uniform_real_distribution<>` is then used to generate random numbers in the range [-1, 1], which are then multiplied by `y` to populate the vector `vd`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: for the random number generator and distribution.\n- `<Eigen/Dense>`: for the `Eigen::VectorXd` class.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "10b82f67-09bc-332f-92e9-07899f1e6c6c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that the generator will produce. This can lead to serious security issues, especially in applications that rely on random numbers for security features such as encryption keys, random identifiers, tokens, etc.\n\nThe specific vulnerability sink in the provided code is the use of `VectorXf::Random(512) * y` which uses a non-cryptographic random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::VectorXf vf(512);\nfor(int i=0; i<vf.size(); i++)\n    vf(i) = dis(gen) * y;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "25727863-034b-3b66-827a-e4a4dded7bcb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\nIn the given code snippet, `VectorXd::Random(s1) * y` is using a non-cryptographic random number generator. This can lead to vulnerabilities if the generated random numbers are used in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for most purposes. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is a code fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\nVectorXd vd = VectorXd::Constant(s1, dis(gen)) * y;\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers. `std::uniform_real_distribution` produces random floating-point numbers in the range [0, 1).\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen for `VectorXd`\n- `<random>` for random number generation\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "0dd1452b-a451-33a4-9808-edfc60e4f47a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\nIn the given code snippet, `VectorXf::Random(s1) * y` is using a non-cryptographic random number generator. This could potentially lead to vulnerabilities if the generated random numbers are used in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::VectorXf vf(s1);\nfor (int i = 0; i < s1; ++i) {\n    vf(i) = dis(gen) * y;\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographic random number generator. `std::uniform_real_distribution<>` is then used to generate random floating-point numbers between -1 and 1, which are then multiplied by `y` to populate the vector `vf`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which provides various matrix and vector operations.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "c480699e-13f3-3164-9375-b73cb332121e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that will be generated. This can lead to a variety of security issues, such as the ability to predict session IDs, encryption keys, or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `std::random_device` class from the `<random>` library, which is designed to produce non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nInstead of using `Matrix3f::Random(3,3)`, you can use `std::random_device` to generate random numbers for your matrix. Here is an example:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::Matrix3f A;\nstd::random_device rd;\n\nfor(int i=0; i<A.rows(); i++)\n{\n    for(int j=0; j<A.cols(); j++)\n    {\n        A(i,j) = static_cast <float> (rd()) / static_cast <float> (rd.max());\n    }\n}\n```\n\n## Library Dependencies\n\nThe above code requires the following libraries:\n\n- `<random>`: for `std::random_device`\n- `<Eigen/Dense>`: for `Eigen::Matrix3f`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "2f218259-7d19-3a51-a3ee-374377139daf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that the generator will produce. This can lead to serious security issues, especially in applications where the random numbers are used for security-critical operations such as generating encryption keys, random identifiers, or other security tokens.\n\nThe specific vulnerability sink in the provided code is the use of `MatrixXf::Random(4,4)`, which generates a 4x4 matrix of random floating-point numbers. If the underlying random number generator used by `MatrixXf::Random` is not cryptographically secure, this could lead to the aforementioned security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix that uses the `std::random_device` class from the `<random>` library to generate random floating-point numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nEigen::MatrixXf A(4,4);\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        A(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: This is a standard C++ library that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "3d21ef16-2371-3782-8ace-b2e54c4dacc1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\nIn the given code snippet, `VectorXcf::Random(s1) * y`, a random number generator is used to generate a vector of complex numbers. If this vector is used in a security context, it could be vulnerable to attacks due to the predictability of the random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nusing namespace Eigen;\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nVectorXcf vcf(s1);\nfor (int i = 0; i < s1; ++i)\n{\n    vcf[i] = std::complex<float>(dis(gen), dis(gen)) * y;\n}\n```\n\nIn this code, a Mersenne Twister generator (`std::mt19937`) is used, which is a cryptographically secure random number generator. The `std::uniform_real_distribution` is used to generate random floating-point numbers between -1 and 1, which are then used to create the complex numbers for the vector.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `<Eigen/Dense>`: This is a part of the Eigen library, which provides various matrix and vector operations.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "95b54056-e235-3c09-9c77-95c619c8c0ca",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unsecured Web Address\" vulnerability in C++ programming language refers to the use of unencrypted HTTP protocol to access or transmit data over the internet. This can lead to Man-in-the-Middle (MitM) attacks where an attacker can intercept, read, and modify the data being transmitted.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use HTTPS protocol instead of HTTP for accessing or transmitting data over the internet. HTTPS protocol encrypts the data being transmitted, making it difficult for an attacker to read or modify the data.\n\n## Source Code Fix Recommendation\n\nReplace the unsecured web address `http://www.w3.org` with a secured web address `https://www.w3.org`.\n\n```cpp\n// Before fix\nstd::string unsecuredWebAddress = \"http://www.w3.org\";\n\n// After fix\nstd::string securedWebAddress = \"https://www.w3.org\";\n```\n\n## Library Dependencies\n\nThe above code example does not require any library dependencies to execute properly.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "77699200-467d-3838-9add-d606bdde9c24",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability refers to the use of unencrypted HTTP protocol for network communication in a C++ program. This can expose sensitive data to potential eavesdropping or man-in-the-middle attacks, as the data transmitted over HTTP is not encrypted and can be intercepted by attackers.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure HTTPS protocol instead of HTTP for network communication. HTTPS encrypts the data transmitted between the client and the server, making it difficult for attackers to intercept and understand the data.\n\n## Source Code Fix Recommendation\n\nIf you are using a library like libcurl for network communication in your C++ program, you can switch to HTTPS by simply changing the URL from \"http://\" to \"https://\". Here is an example:\n\n```cpp\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl;\n    CURLcode res;\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://mozilla.org\");\n\n        res = curl_easy_perform(curl);\n\n        if(res != CURLE_OK)\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n                    curl_easy_strerror(res));\n\n        curl_easy_cleanup(curl);\n    }\n\n    curl_global_cleanup();\n\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the libcurl library.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A6-Security Misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "8c038c8f-3f8d-3b98-baa8-58ff220e4fb7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable outputs and can be exploited by attackers to predict the sequence of random numbers, which can compromise the security of the application.\n\nIn the given code snippet, `b = VectorXf::Random(3)`, a non-cryptographic random number generator is used to generate a vector of random floating point numbers. This can be a potential security vulnerability if the generated random numbers are used in a security-sensitive context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::VectorXf b(3);\nfor (int i = 0; i < 3; ++i)\n    b(i) = dis(gen);\n```\n\nIn this code, a Mersenne Twister engine (`std::mt19937`) is used with a uniform real distribution to generate cryptographically secure random floating point numbers.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This is a standard library in C++ that provides facilities to generate random numbers.\n- `Eigen/Dense`: This is a part of the Eigen library, which is a high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "6991f353-ccec-3a54-af8e-c679ed1ce1fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict future values generated by the random number generator, leading to potential security risks.\n\nIn the given code snippet, `MatrixXf::Random(3, 2)` is used to generate a random matrix. However, the `Random()` function in Eigen library is not a cryptographic random number generator, and it may not provide sufficient randomness for security-sensitive operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographic random number generator that is designed to be unpredictable and resistant to attacks. In C++, you can use functions provided by libraries such as `<random>` or OpenSSL's `RAND_bytes()`.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to use `<random>` to generate a random matrix:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nEigen::MatrixXf A(3, 2);\nfor (int i = 0; i < A.rows(); ++i) {\n    for (int j = 0; j < A.cols(); ++j) {\n        A(i, j) = dis(gen);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "76950ba3-68c9-331a-b409-8279f9532f74",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the values generated by the random number generator, leading to a variety of security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use strong cryptographic random number generators. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code fix for the vulnerability sink:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, cols);\n\nx = VectorX::Random(dis(gen));\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a strong cryptographic random number generator. `std::uniform_int_distribution<>` is then used to generate a random number in the range [1, cols].\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "fc4c2d1d-8231-35f3-9c34-78d20baeb541",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable values being generated, which can be exploited by an attacker to predict the behavior of the system, leading to a security breach.\n\nThe specific vulnerability sink in the provided code is the use of `VectorX::Random(cols)`, which may not be using a cryptographically secure random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::VectorXd b(cols);\nfor (int i = 0; i < cols; ++i)\n{\n    b(i) = dis(gen);\n}\n```\n\nIn this code, `std::random_device` is used to seed the Mersenne Twister engine (`std::mt19937`), which is a cryptographically secure random number generator. `std::uniform_real_distribution` is then used to generate random numbers in the range [-1, 1], which are stored in the Eigen vector `b`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<random>`: for the random number generators and distributions.\n- `<Eigen/Dense>`: for the Eigen vector.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "5fabfc48-2c41-3059-bdc6-c846d03b6a34",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For `atoi()`, a safer alternative is `std::stoi()`, which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    rep = std::stoi(argv[i++]);\n} catch (std::invalid_argument& e) {\n    // Handle exception: input string does not represent a valid number\n} catch (std::out_of_range& e) {\n    // Handle exception: converted value is out of range\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<cstdlib>` for `atoi()`\n\nThe fixed code requires the following libraries:\n\n- `<string>` for `std::stoi()`\n- `<stdexcept>` for `std::invalid_argument` and `std::out_of_range`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7572439c-c1c5-366a-a085-229467a8193e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can lead to a security risk. In this case, the function `atoi()` is used, which converts a string to an integer. The problem with `atoi()` is that it does not perform any error checking. If the input string cannot be converted to an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should replace `atoi()` with a function that performs error checking, such as `strtol()`. This function allows you to check if the entire string was converted to an integer and if any errors occurred during the conversion.\n\n## Source Code Fix Recommendation\n\nHere is how you can replace `atoi()` with `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong int value = strtol(argv[++i], &endptr, 10);\n\nif (endptr == argv[i] || *endptr != '\\0' || errno == ERANGE) {\n    // Handle conversion error\n} else {\n    tries = value;\n}\n```\n\nIn this code, `strtol()` is used to convert the string to a long integer. If the end pointer is equal to the input string, no conversion was performed. If the end pointer does not point to a null character, the entire string was not converted. If `errno` is set to `ERANGE`, the converted value is out of range.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header file is needed for the `strtol()` function.\n- `<cerrno>`: This header file is needed to check if any errors occurred during the conversion.\n\n## References\n\n- [OWASP Prohibited C Functions](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html#prohibited-c-library-functions)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0f7549f7-4fca-341c-bc64-51fba43de644",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    cache_size3 = std::stoi(argv[i++]);\n} catch (std::invalid_argument& e) {\n    // handle error: the conversion failed\n} catch (std::out_of_range& e) {\n    // handle error: the converted value is out of range\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`: for `std::stoi()`\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "32f10a8a-c451-37f5-a2fb-c66cf63b72f0",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which can lead to integer overflow or underflow if the input is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these insecure functions. For `atoi()`, a safer alternative would be `strtol()` or `sscanf()`. These functions provide error checking which can prevent integer overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to do it with `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong int cache_size2 = strtol(argv[i++], &endptr, 10);\n\nif (errno == ERANGE) {\n    // handle overflow or underflow\n} else if (endptr == argv[i]) {\n    // handle no digits were found\n} else {\n    // successful conversion\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3f3d2b82-6e89-31cd-a459-18b892e94b4b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses certain C library functions that are considered unsafe. These functions are often prohibited because they can lead to buffer overflows, integer overflows, or other types of vulnerabilities that can be exploited by an attacker.\n\nIn the provided code snippet, the function `atoi()` is used, which is a prohibited function. The `atoi()` function converts a string to an integer, but it does not perform any error checking. If the string cannot be converted to an integer, the function returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should replace the `atoi()` function with a safer alternative that performs error checking. In C++, you can use the `std::stoi()` function, which throws an exception if the string cannot be converted to an integer.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code snippet:\n\n```cpp\ntry {\n    cache_size1 = std::stoi(argv[i++]);\n} catch (std::invalid_argument& e) {\n    // Handle the error\n} catch (std::out_of_range& e) {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This library is required for the `atoi()` function.\n- `<string>`: This library is required for the `std::stoi()` function.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f6ae180e-ba3e-30d6-a3c0-982788832e72",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the random number generation, leading to potential security risks.\n\nIn the given code snippet, `a = MatrixType::Random(rows,cols)`, a weak random number generator might be used to generate the matrix, which could lead to predictable outcomes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use strong cryptographic random number generators. In C++, you can use libraries like `<random>` which provides a variety of random number generators that can be used for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nfor (int n=0; n<10; ++n)\n    a = MatrixType::Random(dis(gen),dis(gen));\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "2103a41d-4990-35f3-90d1-5d11ac8623b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C library functions that are considered unsafe. These functions are prohibited because they can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which can lead to integer overflow if the input string represents a number larger than what can be stored in an `int`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n\n// ...\n\ntry {\n    s = std::stoi(argv[i++]);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`: This is required for the `std::stoi()` function.\n\n## References\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d618f82c-97f9-39c6-9589-3ec6e0b57e21",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that will be generated. This can lead to a variety of security issues, such as predictable session identifiers, predictable cryptographic keys, or other security-sensitive random values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `std::random_device` class from the `<random>` library, which is designed to produce non-deterministic random numbers.\n\n## Source Code Fix Recommendation\n\nReplace the `Mat::Random(3,3)` function with a cryptographically secure random number generator. Here is an example of how to do this:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\nfor (int n=0; n<10; ++n)\n    std::cout << dis(gen) << ' ';\nstd::cout << '\\n';\n```\n\nIn this example, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_real_distribution` produces random floating-point numbers in the range [0, 1).\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<random>`: This library is used to generate random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "62202346-6999-3e85-a3bc-83d8e32ad9ab",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable outputs and can be exploited by attackers to predict the sequence of random numbers, which can compromise the security of the application.\n\nIn the given code snippet, `MatrixXd::Random(3,3)` is used to generate a 3x3 matrix of random numbers. However, this function uses a non-cryptographic random number generator, which makes it vulnerable.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a code snippet that uses a cryptographically secure random number generator to generate a 3x3 matrix of random numbers:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXd m(3,3);\nfor(int i=0; i<3; ++i)\n    for(int j=0; j<3; ++j)\n        m(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "bc6866bc-b799-3f79-8b5e-34f4057d00d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions that include proper error handling and boundary checks. For `atoi()`, a safer alternative could be `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong int repeats = strtol(argv[i]+1, &end, 10);\nif (end == argv[i]+1 || *end != '\\0' || errno == ERANGE) {\n    // handle the error, the input was not a valid integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f446bb40-b227-37b6-8764-6363b4d2baaa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. In this case, the function `atoi()` is used, which is considered unsafe because it does not perform any error checking. If the input is not a valid integer, `atoi()` will return 0, which may not be the expected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives that perform error checking. In C++, the `std::stoi()` function can be used as a safer alternative to `atoi()`. This function throws an exception if the conversion cannot be performed, which allows the program to handle the error in a controlled manner.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    tries = std::stoi(argv[i]+1);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `atoi()`\n- `<string>`: for `std::stoi()`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "aa700e41-9dfc-3928-9a04-7021de01c49e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or input validation. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, use `std::stoi()` which throws an exception if the input string cannot be converted to an integer or if the converted value is out of the range of representable values by an int.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    p = std::stoi(argv[i++]);\n} catch (std::invalid_argument& e) {\n    // Handle exception: input string cannot be converted to an integer\n} catch (std::out_of_range& e) {\n    // Handle exception: converted value is out of the range of representable values by an int\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<cstdlib>` for `atoi()`\n- `<string>` for `std::stoi()`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1b894452-c5c4-3d2d-b5d8-3c8733872eb8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can lead to a security risk. In this case, the function `atoi()` is used, which is a standard C library function that converts a string into an integer. The problem with `atoi()` is that it does not handle errors well. If the input string is not a valid integer, `atoi()` will return 0, which can lead to unexpected behavior. Furthermore, `atoi()` does not check for integer overflow, which can lead to further unexpected behavior and potential security risks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should replace `atoi()` with a function that properly handles errors and checks for integer overflow. One such function is `strtol()`, which is also a standard C library function. `strtol()` returns a long integer, and allows you to specify the base of the input string. It also sets the global variable `errno` to indicate any errors that occurred during the conversion.\n\n## Source Code Fix Recommendation\n\nHere is how you can replace `atoi()` with `strtol()` in your code:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\n// ...\n\nchar *end;\nlong n = strtol(argv[i++], &end, 10);\nif (errno == ERANGE) {\n    // Handle integer overflow\n} else if (end == argv[i]) {\n    // Handle invalid input\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header file includes functions from the standard C library, including `strtol()`.\n- `<cerrno>`: This header file defines the integer variable `errno`, which is set by system calls and some library functions in the event of an error to indicate what went wrong.\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "85240ec2-7e7c-35da-ab87-e01e1d6ce763",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a standard C library function that converts a string to an integer. The problem with `atoi()` is that it does not handle errors properly. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using `atoi()`. Instead, use functions that can handle errors properly. In C++, you can use `std::stoi()`, which throws an exception if the conversion fails. Always validate and sanitize user input to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n#include <cstdlib>\n\ntry {\n    rows = std::stoi(argv[i]+1);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code requires the following libraries:\n\n- `<string>`: This is a standard C++ library that provides support for strings.\n- `<cstdlib>`: This is a standard C library that provides general purpose functions, including `atoi()`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "150cec58-14ab-31d6-82e1-80184accdff9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. These generators can produce predictable outcomes, which can be exploited by attackers to predict the sequence of random numbers and compromise the security of the system.\n\nIn the given code snippet, `Eigen::MatrixXf::Random(4, 4)` is used to generate a 4x4 matrix of random floating-point numbers. However, the `Random()` function in Eigen library is not cryptographically secure, which makes it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to generate a 4x4 matrix of random floating-point numbers using the `<random>` library in C++:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\nEigen::MatrixXf m(4, 4);\nfor (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n        m(i, j) = dis(gen);\n```\n\nIn this code, `std::random_device` is used to seed the random number generator, `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_real_distribution<>` generates floating-point numbers uniformly distributed between -1.0 and 1.0.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n- `<random>`: A standard C++ library for generating random numbers.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "8057f00e-e347-3063-8527-6253d21e26a1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Non-Cryptographic Random Number Generators\" vulnerability refers to the use of random number generators that are not cryptographically secure. Non-cryptographic random number generators are predictable and can be easily exploited by attackers, leading to potential security risks.\n\nIn the given code snippet, `MatrixXf::Random(4,4)` generates a 4x4 matrix with random float numbers. However, the `Random()` function is not cryptographically secure, making it vulnerable to attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, you can use functions provided by the `<random>` library, which includes a variety of random number generators that are more secure than the traditional `rand()` function.\n\n## Source Code Fix Recommendation\n\nHere is a sample code fix using the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1, 1);\n\nEigen::MatrixXf m2 = Eigen::MatrixXf::Zero(4,4);\n\nfor(int i=0; i<4; ++i)\n    for(int j=0; j<4; ++j)\n        m2(i,j) = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_real_distribution` produces random floating-point numbers in the range [-1, 1].\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- Eigen: A high-level C++ library of template headers for linear algebra, matrix and vector operations, numerical solvers and related algorithms.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "583fc1bc-f954-3ac1-8399-5d0ebef0030a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers or even reverse-engineer the generator's state.\n\nIn the given code snippet, `MatrixType::Random(rows,cols)` is used to generate a matrix of random numbers. If `MatrixType::Random` uses a non-cryptographic or weak random number generator, it could introduce this vulnerability into the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of generators that are suitable for most purposes. \n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to generate random numbers using the `<random>` library in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nfor (int n=0; n<10; ++n)\n    std::cout << distrib(gen) << ' '; // Use `distrib(gen)` instead of `MatrixType::Random(rows,cols)`\n```\n\n## Library Dependencies\n\nThe `<random>` library is part of the C++ Standard Library and does not require any additional dependencies.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "48ce1b28-9f98-3139-8761-68eecfbfc924",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the random number generation, leading to potential security risks.\n\nIn the given code snippet, `a = MatrixType::Random(rows,cols)`, a weak random number generator might be used to generate the matrix, which could lead to predictable outcomes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use strong cryptographic random number generators. In C++, you can use libraries like `<random>` which provides a variety of random number generators that can be used for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\n\nfor (int n=0; n<10; ++n)\n    a = MatrixType::Random(dis(gen),dis(gen));\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "7bc05f28-9852-399e-bcd6-4426426119f4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of random number generators that are not cryptographically secure. This can lead to predictable patterns in the generated numbers, which can be exploited by attackers to predict future numbers that will be generated. This can lead to a variety of security issues, such as predictable session identifiers, predictable cryptographic keys, or other security-sensitive random values.\n\nIn the provided code example, the `Eigen::MatrixXi::Random(4,4)` function is used to generate a 4x4 matrix of random integers. However, the `Random` function in the Eigen library is not cryptographically secure, which makes it vulnerable to this type of attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a cryptographically secure random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code example, using the `std::random_device` and `std::uniform_int_distribution` classes from the `<random>` library:\n\n```cpp\n#include <random>\n#include <Eigen/Dense>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());\n\nEigen::MatrixXi m2(4,4);\nfor(int i=0; i<m2.rows(); ++i)\n    for(int j=0; j<m2.cols(); ++j)\n        m2(i,j) = dis(gen);\n```\n\n## Library Dependencies\n\nThe provided code example requires the Eigen library to execute properly.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a9838cb1-5b60-3c0c-b440-6aeb9ebe0ada",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atof()` is used, which converts a string to a double. This function does not perform any error checking, so if the input string is not a valid representation of a double, the behavior is undefined, which can lead to unexpected results or vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should replace the use of `atof()` with a safer alternative that performs error checking. In C++, you can use the `std::stod()` function, which throws an exception if the conversion cannot be performed.\n\n## Source Code Fix Recommendation\n\nHere is how you can replace `atof()` with `std::stod()`:\n\n```cpp\ntry {\n    tol = std::stod(inval);\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>` for `atof()`\n- `<string>` for `std::stod()`\n- `<stdexcept>` for `std::invalid_argument`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3d6c53a3-b477-37ff-af18-6b25f296d7e6",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a prohibited C function because it does not perform any error checking and can lead to integer overflow or underflow.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform error checking or can lead to security vulnerabilities. Instead, use safer alternatives provided by the C++ Standard Library. For example, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    nnzPerCol = std::stoi(argv[i]+1);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e1e7ca87-8448-3f14-8a50-845f6376fad9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which is a standard C library function that converts a string to an integer. The problem with `atoi()` is that it does not perform any error checking. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using `atoi()` function. Instead, use functions that perform error checking, such as `strtol()`, `sscanf()`, or C++ style string-to-number conversion functions. Always validate and sanitize user input to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n#include <cstring>\n\nchar *endptr;\nlong int cols = strtol(argv[i]+1, &endptr, 10);\n\nif (endptr == argv[i]+1) {\n    // handle the error. The input string cannot be converted to a number.\n} else if (errno == ERANGE) {\n    // handle the error. The number is out of range.\n} else {\n    // the number is valid.\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- cerrno\n- cstring\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1e6f3a4e-a188-3ef3-8b3f-797f713e15af",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Production Code Debugging Vulnerability\" in C++ refers to the situation where debugging code or debugging commands are accidentally left in the production code. This can lead to a variety of security risks, including information disclosure, unauthorized access, or even remote code execution. In the given code snippet, the vulnerability arises if the string \"markb@localhost.localdomain\" is part of sensitive information that should not be disclosed.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always remove debugging code or commands before deploying the application to production. This includes any code that outputs sensitive information, such as usernames, passwords, server details, etc. \n\n## Source Code Fix Recommendation\n\nIn the given code snippet, the debugging code should be removed or commented out. If the check for the string \"markb@localhost.localdomain\" is necessary for the application's functionality, it should be replaced with a more secure method. For example:\n\n```cpp\n// Before\nline.find(\"markb@localhost.localdomain\") != string::npos\n\n// After\n// Debugging code removed or replaced with secure method\n```\n\n## Library Dependencies\n\nThe given code snippet requires the following library dependencies:\n\n- `<string>`\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "46905281-7504-3b21-85b8-6c04f836ba35",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using `atoi()` function as it does not perform any error checking. Instead, use safer alternatives such as `strtol()` or `sscanf()`, which provide error checking. Also, always validate and sanitize user input to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib> // for strtol\n#include <climits> // for LONG_MAX, LONG_MIN\n#include <cerrno>  // for errno\n\nlong maxiters;\nchar *endptr;\nerrno = 0; // To distinguish success/failure after call\nmaxiters = strtol(inval.c_str(), &endptr, 10);\n\n// Check for various possible errors\nif ((errno == ERANGE && (maxiters == LONG_MAX || maxiters == LONG_MIN))\n    || (errno != 0 && maxiters == 0)) {\n    perror(\"strtol\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == inval.c_str()) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstdlib>` for `strtol()`\n- `<climits>` for `LONG_MAX` and `LONG_MIN`\n- `<cerrno>` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "24e27ff7-8169-3249-83d7-7bee18663005",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but it can be overwritten by a subsequent call to `getenv()`, `setenv()`, or `unsetenv()`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using a safer method to retrieve environment variables. \n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* matrix_dir = std::getenv(\"EIGEN_MATRIXDIR\");\nif (!matrix_dir) {\n    // Handle the case when EIGEN_MATRIXDIR is not set in the environment\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdlib>`: This is a C++ Standard Library that provides several general purpose functions, including dynamic memory management, random numbers, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "55df8ab7-afc3-35b4-bd9d-6cf329fe7001",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the function `getenv()` is used, which can lead to security vulnerabilities as it allows access to the environment variables of the process. If an attacker can modify these variables, they can influence the behavior of the program in unexpected ways.\n\n## Mitigation Advice\n\nAvoid using functions that can lead to security vulnerabilities. Instead, use safer alternatives that perform bounds checking or that do not rely on environment variables. Validate all input and do not trust data from untrusted sources. Use secure coding practices and perform regular code reviews and security testing.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv()`, consider using a configuration file or command line arguments to configure your program. If you must use environment variables, validate them before use. For example:\n\n```cpp\nconst char* value = getenv(\"EIGEN_MATRIXDIR\");\nif (value == NULL) {\n    // Handle error\n} else {\n    // Use value\n}\n```\n\n## Library Dependencies\n\nThe code example does not appear to require any specific library dependencies beyond the standard C++ library.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Proactive Controls](https://owasp.org/www-project-proactive-controls/)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [CWE-807: Reliance on Untrusted Inputs in a Security Decision](https://cwe.mitre.org/data/definitions/807.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "14be3e3b-1561-3dcf-9674-f1cb7db4b6af",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 3724,
                  "startColumn": 9,
                  "endLine": 3724,
                  "endColumn": 17,
                  "charOffset": 163045,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "f4bcd87c-d42b-3e06-b7bd-34d4a7518b34",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 3720,
                  "startColumn": 9,
                  "endLine": 3720,
                  "endColumn": 17,
                  "charOffset": 162930,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "63b65834-a55a-3b82-8b7a-07204466c8b6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 3710,
                  "startColumn": 29,
                  "endLine": 3710,
                  "endColumn": 37,
                  "charOffset": 162574,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "3bd0dcf7-b391-3067-b185-f6ab2ff7f67a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 3728,
                  "startColumn": 9,
                  "endLine": 3728,
                  "endColumn": 17,
                  "charOffset": 163157,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "faa790ff-69b4-3ae9-92be-8fe5b67629df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1909,
                  "startColumn": 2,
                  "endLine": 1909,
                  "endColumn": 32,
                  "charOffset": 87936,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(to, &from, sizeof(from)",
                    "rendered": {
                      "text": "memcpy(to, &from, sizeof(from)",
                      "markdown": "`memcpy(to, &from, sizeof(from)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 87936,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(to, <size of to>,  &from,  sizeof(from)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6b4002af-03ac-3a2f-8926-7c16735b225d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1915,
                  "startColumn": 2,
                  "endLine": 1915,
                  "endColumn": 32,
                  "charOffset": 88336,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(to, &from, sizeof(from)",
                    "rendered": {
                      "text": "memcpy(to, &from, sizeof(from)",
                      "markdown": "`memcpy(to, &from, sizeof(from)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 88336,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(to, <size of to>,  &from,  sizeof(from)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "579a91ef-be13-3167-8139-1b70ee75fd5a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1878,
                  "startColumn": 2,
                  "endLine": 1878,
                  "endColumn": 32,
                  "charOffset": 85886,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(to, &from, sizeof(from)",
                    "rendered": {
                      "text": "memcpy(to, &from, sizeof(from)",
                      "markdown": "`memcpy(to, &from, sizeof(from)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85886,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(to, <size of to>,  &from,  sizeof(from)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b1f874b2-6fb4-3983-b3c1-6ec7d27d40bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1872,
                  "startColumn": 2,
                  "endLine": 1872,
                  "endColumn": 32,
                  "charOffset": 85493,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(to, &from, sizeof(from)",
                    "rendered": {
                      "text": "memcpy(to, &from, sizeof(from)",
                      "markdown": "`memcpy(to, &from, sizeof(from)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85493,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(to, <size of to>,  &from,  sizeof(from)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7245961d-dff1-367d-a38d-25d08fd62538",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1714,
                  "startColumn": 2,
                  "endLine": 1714,
                  "endColumn": 37,
                  "charOffset": 77772,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(&res, from, sizeof(Packet4c)",
                    "rendered": {
                      "text": "memcpy(&res, from, sizeof(Packet4c)",
                      "markdown": "`memcpy(&res, from, sizeof(Packet4c)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77772,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&res, <size of &res>,  from,  sizeof(Packet4c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a657694a-5528-3733-9489-4ee0e9d3a06d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1724,
                  "startColumn": 2,
                  "endLine": 1724,
                  "endColumn": 38,
                  "charOffset": 78190,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&res, from, sizeof(Packet4uc)",
                    "rendered": {
                      "text": "memcpy(&res, from, sizeof(Packet4uc)",
                      "markdown": "`memcpy(&res, from, sizeof(Packet4uc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 78190,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&res, <size of &res>,  from,  sizeof(Packet4uc)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bb888cb9-7a60-3655-82c4-f374ff8e10b7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/Default/Half.h"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 70,
                  "endLine": 227,
                  "endColumn": 97,
                  "charOffset": 10185,
                  "charLength": 27,
                  "snippet": {
                    "text": "http://half.sourceforge.net",
                    "rendered": {
                      "text": "http://half.sourceforge.net",
                      "markdown": "`http://half.sourceforge.net`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/Default/Half.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10185,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "https://half.sourceforge.net"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "84c55a99-1160-3fdd-b86c-ad7267b589aa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1679,
                  "startColumn": 2,
                  "endLine": 1679,
                  "endColumn": 38,
                  "charOffset": 75784,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&res, from, sizeof(Packet4uc)",
                    "rendered": {
                      "text": "memcpy(&res, from, sizeof(Packet4uc)",
                      "markdown": "`memcpy(&res, from, sizeof(Packet4uc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75784,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&res, <size of &res>,  from,  sizeof(Packet4uc)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d985e0f8-d6e8-3987-a846-a89c1fe1f989",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                },
                "region": {
                  "startLine": 1669,
                  "startColumn": 2,
                  "endLine": 1669,
                  "endColumn": 37,
                  "charOffset": 75373,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(&res, from, sizeof(Packet4c)",
                    "rendered": {
                      "text": "memcpy(&res, from, sizeof(Packet4c)",
                      "markdown": "`memcpy(&res, from, sizeof(Packet4c)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/NEON/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75373,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&res, <size of &res>,  from,  sizeof(Packet4c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "55538980-194f-3552-b19c-8a9c643bfcb6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/Default/Half.h"
                },
                "region": {
                  "startLine": 226,
                  "startColumn": 70,
                  "endLine": 226,
                  "endColumn": 97,
                  "charOffset": 10024,
                  "charLength": 27,
                  "snippet": {
                    "text": "http://half.sourceforge.net",
                    "rendered": {
                      "text": "http://half.sourceforge.net",
                      "markdown": "`http://half.sourceforge.net`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/Default/Half.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10024,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "https://half.sourceforge.net"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "fa222a45-afb5-36bb-95fc-df45a8debc1b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/Default/Half.h"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 41,
                  "endLine": 6,
                  "endColumn": 59,
                  "charOffset": 264,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/Default/Half.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 264,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "1fb89969-b6b1-3bf8-913e-5bf0ae362f28",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                },
                "region": {
                  "startLine": 1383,
                  "startColumn": 16,
                  "endLine": 1383,
                  "endColumn": 42,
                  "charOffset": 52129,
                  "charLength": 26,
                  "snippet": {
                    "text": "http://developer.apple.com",
                    "rendered": {
                      "text": "http://developer.apple.com",
                      "markdown": "`http://developer.apple.com`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52129,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "https://developer.apple.com"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "39719e99-873d-3500-b38a-fb17aac97137",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorBase.h"
                },
                "region": {
                  "startLine": 1145,
                  "startColumn": 4,
                  "endLine": 1145,
                  "endColumn": 12,
                  "charOffset": 56648,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "6099f83e-921a-38d7-944b-efe7600ae996",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                },
                "region": {
                  "startLine": 2945,
                  "startColumn": 2,
                  "endLine": 2945,
                  "endColumn": 29,
                  "charOffset": 111197,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(tmp, &x, sizeof(tmp)",
                    "rendered": {
                      "text": "memcpy(tmp, &x, sizeof(tmp)",
                      "markdown": "`memcpy(tmp, &x, sizeof(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111197,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp, <size of tmp>,  &x,  sizeof(tmp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "57ec42fc-213e-3a1a-946a-7162cf77d0a7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                },
                "region": {
                  "startLine": 2955,
                  "startColumn": 2,
                  "endLine": 2955,
                  "endColumn": 29,
                  "charOffset": 111454,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(tmp, &x, sizeof(tmp)",
                    "rendered": {
                      "text": "memcpy(tmp, &x, sizeof(tmp)",
                      "markdown": "`memcpy(tmp, &x, sizeof(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/arch/AltiVec/PacketMath.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111454,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp, <size of tmp>,  &x,  sizeof(tmp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "73e24196-f7c0-36a9-86e4-648486796697",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorBase.h"
                },
                "region": {
                  "startLine": 934,
                  "startColumn": 4,
                  "endLine": 934,
                  "endColumn": 12,
                  "charOffset": 46282,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "8a60286d-4e0c-3867-858f-d17175822cf1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorBase.h"
                },
                "region": {
                  "startLine": 1140,
                  "startColumn": 4,
                  "endLine": 1140,
                  "endColumn": 12,
                  "charOffset": 56406,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "011a25f0-7915-321e-8563-a42c138ee601",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 324,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 324,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "f4ca8137-257b-37e7-8a1b-86301a647d1e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 40,
                  "endLine": 220,
                  "endColumn": 45,
                  "charOffset": 7739,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "81eb0c45-24d1-3930-a177-9e3797dbb15a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 4,
                  "endLine": 36,
                  "endColumn": 23,
                  "charOffset": 1341,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1341,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3676d032-d31e-3bd3-bc61-16db9caa85d0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 19,
                  "endLine": 279,
                  "endColumn": 85,
                  "charOffset": 11333,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(line_buf, &buf[base_offset], line_len*sizeof(ComplexScalar)",
                    "rendered": {
                      "text": "memcpy(line_buf, &buf[base_offset], line_len*sizeof(ComplexScalar)",
                      "markdown": "`memcpy(line_buf, &buf[base_offset], line_len*sizeof(ComplexScalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11333,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(line_buf, <size of line_buf>,  &buf[base_offset],  line_len*sizeof(ComplexScalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b0480fcd-b09a-3fd2-8145-b6a276f88e65",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 4,
                  "endLine": 39,
                  "endColumn": 23,
                  "charOffset": 1480,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1480,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e2464196-b54d-3045-9b57-7266f0cf8c45",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 19,
                  "endLine": 297,
                  "endColumn": 85,
                  "charOffset": 11946,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&buf[base_offset], line_buf, line_len*sizeof(ComplexScalar)",
                    "rendered": {
                      "text": "memcpy(&buf[base_offset], line_buf, line_len*sizeof(ComplexScalar)",
                      "markdown": "`memcpy(&buf[base_offset], line_buf, line_len*sizeof(ComplexScalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11946,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&buf[base_offset], <size of &buf[base_offset]>,  line_buf,  line_len*sizeof(ComplexScalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dae71298-18fc-3f87-a46e-5ca84f790ca9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 6,
                  "endLine": 33,
                  "endColumn": 25,
                  "charOffset": 1202,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1202,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7c856da8-1e08-3f63-beb9-06c96b2824a2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 336,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 336,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "e2d5fe6e-43c8-3056-ad4e-2e17ad1d2133",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h"
                },
                "region": {
                  "startLine": 274,
                  "startColumn": 15,
                  "endLine": 274,
                  "endColumn": 90,
                  "charOffset": 10690,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy((void*)(m_device.get(data)),m_device.get(m_data), m_dims.TotalSize()",
                    "rendered": {
                      "text": "memcpy((void*)(m_device.get(data)),m_device.get(m_data), m_dims.TotalSize()",
                      "markdown": "`memcpy((void*)(m_device.get(data)),m_device.get(m_data), m_dims.TotalSize()`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10690,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void*)(m_device.get(data)), <size of (void*)(m_device.get(data))>, m_device.get(m_data),  m_dims.TotalSize()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ed49b0dc-27c4-3d4a-9d7a-90ff1111fd1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 4,
                  "endLine": 117,
                  "endColumn": 23,
                  "charOffset": 3824,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3824,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a9d9c2dc-255f-326a-9aa1-ce8495a1ab4b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 15,
                  "endLine": 79,
                  "endColumn": 91,
                  "charOffset": 3118,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy((void*)(m_device.get(dest)), m_device.get(m_data), m_dims.TotalSize()",
                    "rendered": {
                      "text": "memcpy((void*)(m_device.get(dest)), m_device.get(m_data), m_dims.TotalSize()",
                      "markdown": "`memcpy((void*)(m_device.get(dest)), m_device.get(m_data), m_dims.TotalSize()`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3118,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void*)(m_device.get(dest)), <size of (void*)(m_device.get(dest))>,  m_device.get(m_data),  m_dims.TotalSize()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6f67176e-f6ce-30d4-a4cb-b6f029a8101f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 4,
                  "endLine": 120,
                  "endColumn": 23,
                  "charOffset": 3945,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3945,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "db9e914b-5825-327e-a4d7-f74203e05526",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 8,
                  "endLine": 111,
                  "endColumn": 43,
                  "charOffset": 3652,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(dst_ptr, src_ptr, blocksize)",
                    "rendered": {
                      "text": "memcpy(dst_ptr, src_ptr, blocksize)",
                      "markdown": "`memcpy(dst_ptr, src_ptr, blocksize)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3652,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_ptr, <size of dst_ptr>,  src_ptr,  blocksize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7eab39bf-9c18-3c11-b60d-0ff51bb3aa70",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 45,
                  "endLine": 32,
                  "endColumn": 89,
                  "charOffset": 1143,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void* dst, const void* src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void* dst, const void* src, size_t n)",
                      "markdown": "`memcpy(void* dst, const void* src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1143,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void* dst, <size of void* dst>,  const void* src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4c49039e-54dd-39e5-9a9e-75cee56a5690",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 8,
                  "endLine": 97,
                  "endColumn": 27,
                  "charOffset": 2990,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2990,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fa65ebe1-e965-308e-bb4b-7c15f05a2603",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 6,
                  "endLine": 88,
                  "endColumn": 25,
                  "charOffset": 2524,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2524,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d46ea14-f53c-31af-92a0-c12fd20a9fb4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 27,
                  "endLine": 86,
                  "endColumn": 71,
                  "charOffset": 2446,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void* dst, const void* src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void* dst, const void* src, size_t n)",
                      "markdown": "`memcpy(void* dst, const void* src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2446,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void* dst, <size of void* dst>,  const void* src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8bdf98f3-3765-3d0d-8d14-ddc39df178ba",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 336,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 336,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "97ea52ce-c102-3600-9424-bb2e7420c6a8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 336,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 336,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "7a1b9856-e0eb-320e-997b-a13a8de80a12",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h"
                },
                "region": {
                  "startLine": 518,
                  "startColumn": 19,
                  "endLine": 518,
                  "endColumn": 119,
                  "charOffset": 20415,
                  "charLength": 100,
                  "snippet": {
                    "text": "memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), contiguous_values * sizeof(Scalar)",
                    "rendered": {
                      "text": "memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), contiguous_values * sizeof(Scalar)",
                      "markdown": "`memcpy((void*)(m_device.get(data + i)), m_device.get(src+offset), contiguous_values * sizeof(Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20415,
                        "charLength": 100
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void*)(m_device.get(data + i)), <size of (void*)(m_device.get(data + i))>,  m_device.get(src+offset),  contiguous_values * sizeof(Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8707d7a8-dbda-3504-a630-bf781b406d6b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 45,
                  "endLine": 264,
                  "endColumn": 89,
                  "charOffset": 8824,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void* dst, const void* src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void* dst, const void* src, size_t n)",
                      "markdown": "`memcpy(void* dst, const void* src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceGpu.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8824,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void* dst, <size of void* dst>,  const void* src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "00c832fa-781c-3e87-8ae0-fd9e345661bd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 1009,
                  "startColumn": 20,
                  "endLine": 1009,
                  "endColumn": 39,
                  "charOffset": 39420,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(dst, src, n)",
                    "rendered": {
                      "text": "memcpy(dst, src, n)",
                      "markdown": "`memcpy(dst, src, n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39420,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3a24382c-6fb9-30c8-89a8-73a1c1a8045a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 41,
                  "endLine": 13,
                  "endColumn": 59,
                  "charOffset": 490,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 490,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "264c4abe-7e6f-3acc-bc28-1c61407fc8ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 1008,
                  "startColumn": 27,
                  "endLine": 1008,
                  "endColumn": 72,
                  "charOffset": 39346,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(void *dst, const Index *src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void *dst, const Index *src, size_t n)",
                      "markdown": "`memcpy(void *dst, const Index *src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39346,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *dst, <size of void *dst>,  const Index *src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "95e8293b-fc59-3e76-b49e-2655d280ea90",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorIO.h"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 54,
                  "endLine": 145,
                  "endColumn": 62,
                  "charOffset": 4940,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "cc0b2f93-c2fd-3f65-bd3b-03b2edffc555",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorIO.h"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 336,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorIO.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 336,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "d90fb2ad-e0a8-3b8e-985f-fab6a8caa31f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/misc/lapacke.h"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 31,
                  "endLine": 113,
                  "endColumn": 45,
                  "charOffset": 3658,
                  "charLength": 14,
                  "snippet": {
                    "text": "malloc( size )",
                    "rendered": {
                      "text": "malloc( size )",
                      "markdown": "`malloc( size )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/misc/lapacke.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3658,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "35932502-d5c6-39df-9adc-7b0590ef3eab",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 624,
                  "startColumn": 49,
                  "endLine": 624,
                  "endColumn": 55,
                  "charOffset": 22272,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "33781bca-3742-3029-af23-863c8a54bf91",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 9,
                  "endLine": 593,
                  "endColumn": 16,
                  "charOffset": 21230,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "13d3dcb0-e633-3c89-b2ec-2b131a408c06",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                },
                "region": {
                  "startLine": 316,
                  "startColumn": 27,
                  "endLine": 316,
                  "endColumn": 71,
                  "charOffset": 12336,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(void *dst, const void *src, size_t n)",
                    "rendered": {
                      "text": "memcpy(void *dst, const void *src, size_t n)",
                      "markdown": "`memcpy(void *dst, const void *src, size_t n)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12336,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *dst, <size of void *dst>,  const void *src,  size_t n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "343454c2-3387-3561-b6ba-49d5352ec8fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 570,
                  "startColumn": 4,
                  "endLine": 570,
                  "endColumn": 31,
                  "charOffset": 20409,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(target, start, size)",
                    "rendered": {
                      "text": "memcpy(target, start, size)",
                      "markdown": "`memcpy(target, start, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Memory.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20409,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(target, <size of target>,  start,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ca526359-696d-3550-8b11-c6d0bd37cd61",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 9,
                  "endLine": 138,
                  "endColumn": 16,
                  "charOffset": 5834,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2058c040-f779-3cf7-9d65-084cd929b437",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 257,
                  "startColumn": 17,
                  "endLine": 257,
                  "endColumn": 29,
                  "charOffset": 9623,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Memory.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9623,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f121f25f-42e8-35f9-8aab-6c53e48c140b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 13,
                  "endLine": 184,
                  "endColumn": 25,
                  "charOffset": 7535,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Memory.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7535,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d3d66a6-e959-3430-a7ac-a251c43af97d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Memory.h"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 24,
                  "endLine": 105,
                  "endColumn": 48,
                  "charOffset": 4446,
                  "charLength": 24,
                  "snippet": {
                    "text": "malloc(size + alignment)",
                    "rendered": {
                      "text": "malloc(size + alignment)",
                      "markdown": "`malloc(size + alignment)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Memory.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4446,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8b91929d-fcd9-3c9c-b7e8-82b9ec94be0b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 4,
                  "endLine": 117,
                  "endColumn": 41,
                  "charOffset": 4127,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(value.data(), src, data_bytes)",
                    "rendered": {
                      "text": "memcpy(value.data(), src, data_bytes)",
                      "markdown": "`memcpy(value.data(), src, data_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4127,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value.data(), <size of value.data()>,  src,  data_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "eeda3e42-7d8a-322a-ba65-1247ac06d83a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 4,
                  "endLine": 112,
                  "endColumn": 38,
                  "charOffset": 3875,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(&header, src, header_bytes)",
                    "rendered": {
                      "text": "memcpy(&header, src, header_bytes)",
                      "markdown": "`memcpy(&header, src, header_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3875,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&header, <size of &header>,  src,  header_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "97ff9085-198b-3b95-bd81-0ff26271ebd5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 4,
                  "endLine": 102,
                  "endColumn": 42,
                  "charOffset": 3454,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(dest, value.data(), data_bytes)",
                    "rendered": {
                      "text": "memcpy(dest, value.data(), data_bytes)",
                      "markdown": "`memcpy(dest, value.data(), data_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3454,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  value.data(),  data_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "39e8afd6-ccc2-34d9-831a-4203debb96ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 4,
                  "endLine": 100,
                  "endColumn": 39,
                  "charOffset": 3387,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(dest, &header, header_bytes)",
                    "rendered": {
                      "text": "memcpy(dest, &header, header_bytes)",
                      "markdown": "`memcpy(dest, &header, header_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3387,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  &header,  header_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "aa25054f-301a-34a8-8f04-46f1782ef7e6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 72,
                  "endColumn": 37,
                  "charOffset": 2476,
                  "charLength": 33,
                  "snippet": {
                    "text": "memcpy(&value, src, sizeof(value)",
                    "rendered": {
                      "text": "memcpy(&value, src, sizeof(value)",
                      "markdown": "`memcpy(&value, src, sizeof(value)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2476,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&value, <size of &value>,  src,  sizeof(value)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "12240eb1-4ec1-35b5-b725-b8a915be3d40",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/util/Serializer.h"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 4,
                  "endLine": 57,
                  "endColumn": 38,
                  "charOffset": 1825,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(dest, &value, sizeof(value)",
                    "rendered": {
                      "text": "memcpy(dest, &value, sizeof(value)",
                      "markdown": "`memcpy(dest, &value, sizeof(value)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/util/Serializer.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1825,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  &value,  sizeof(value)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "64a04276-8c3d-3e92-ad5c-dba9807ec104",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/SparseCore/AmbiVector.h"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 11,
                  "endLine": 99,
                  "endColumn": 70,
                  "charOffset": 2832,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(newBuffer,  m_buffer,  copyElements * sizeof(ListEl)",
                    "rendered": {
                      "text": "memcpy(newBuffer,  m_buffer,  copyElements * sizeof(ListEl)",
                      "markdown": "`memcpy(newBuffer,  m_buffer,  copyElements * sizeof(ListEl)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/SparseCore/AmbiVector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2832,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(newBuffer, <size of newBuffer>,   m_buffer,   copyElements * sizeof(ListEl)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e65560a6-f9cd-3838-b659-e5aa6d0355da",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 8,
                  "endLine": 224,
                  "endColumn": 82,
                  "charOffset": 7098,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(lowerProfile, m_lowerProfile, copyLowerProfileSize * sizeof (Index)",
                    "rendered": {
                      "text": "memcpy(lowerProfile, m_lowerProfile, copyLowerProfileSize * sizeof (Index)",
                      "markdown": "`memcpy(lowerProfile, m_lowerProfile, copyLowerProfileSize * sizeof (Index)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7098,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(lowerProfile, <size of lowerProfile>,  m_lowerProfile,  copyLowerProfileSize * sizeof (Index)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "516d5458-ef03-3006-ae8c-35daa1a0a268",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 8,
                  "endLine": 223,
                  "endColumn": 82,
                  "charOffset": 7013,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(upperProfile, m_upperProfile, copyUpperProfileSize * sizeof (Index)",
                    "rendered": {
                      "text": "memcpy(upperProfile, m_upperProfile, copyUpperProfileSize * sizeof (Index)",
                      "markdown": "`memcpy(upperProfile, m_upperProfile, copyUpperProfileSize * sizeof (Index)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7013,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(upperProfile, <size of upperProfile>,  m_upperProfile,  copyUpperProfileSize * sizeof (Index)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "39c3c578-409f-3a6f-89ad-9009e2dc89e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 8,
                  "endLine": 222,
                  "endColumn": 62,
                  "charOffset": 6948,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(lower, m_lower, copyLowerSize * sizeof (Scalar)",
                    "rendered": {
                      "text": "memcpy(lower, m_lower, copyLowerSize * sizeof (Scalar)",
                      "markdown": "`memcpy(lower, m_lower, copyLowerSize * sizeof (Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6948,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(lower, <size of lower>,  m_lower,  copyLowerSize * sizeof (Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "076ad077-5a3b-3e0e-9ef3-161c7f573452",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 8,
                  "endLine": 220,
                  "endColumn": 59,
                  "charOffset": 6821,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(diag, m_diag, copyDiagSize * sizeof (Scalar)",
                    "rendered": {
                      "text": "memcpy(diag, m_diag, copyDiagSize * sizeof (Scalar)",
                      "markdown": "`memcpy(diag, m_diag, copyDiagSize * sizeof (Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6821,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(diag, <size of diag>,  m_diag,  copyDiagSize * sizeof (Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6a96b405-3662-3aee-bbc2-cb981085d9a1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 8,
                  "endLine": 64,
                  "endColumn": 88,
                  "charOffset": 1846,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(m_lowerProfile, other.m_lowerProfile, m_lowerProfileSize * sizeof (Index)",
                    "rendered": {
                      "text": "memcpy(m_lowerProfile, other.m_lowerProfile, m_lowerProfileSize * sizeof (Index)",
                      "markdown": "`memcpy(m_lowerProfile, other.m_lowerProfile, m_lowerProfileSize * sizeof (Index)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1846,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_lowerProfile, <size of m_lowerProfile>,  other.m_lowerProfile,  m_lowerProfileSize * sizeof (Index)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0a0f3296-a078-3ec6-bd3a-f8ff16b55342",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 8,
                  "endLine": 221,
                  "endColumn": 62,
                  "charOffset": 6883,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(upper, m_upper, copyUpperSize * sizeof (Scalar)",
                    "rendered": {
                      "text": "memcpy(upper, m_upper, copyUpperSize * sizeof (Scalar)",
                      "markdown": "`memcpy(upper, m_upper, copyUpperSize * sizeof (Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6883,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(upper, <size of upper>,  m_upper,  copyUpperSize * sizeof (Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "08282e69-cb06-36f0-af21-c5ef89d83528",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 8,
                  "endLine": 63,
                  "endColumn": 88,
                  "charOffset": 1755,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(m_upperProfile, other.m_upperProfile, m_upperProfileSize * sizeof (Index)",
                    "rendered": {
                      "text": "memcpy(m_upperProfile, other.m_upperProfile, m_upperProfileSize * sizeof (Index)",
                      "markdown": "`memcpy(m_upperProfile, other.m_upperProfile, m_upperProfileSize * sizeof (Index)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1755,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_upperProfile, <size of m_upperProfile>,  other.m_upperProfile,  m_upperProfileSize * sizeof (Index)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a0636a6a-9fc4-33b3-af67-edd4ad18d920",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 8,
                  "endLine": 61,
                  "endColumn": 56,
                  "charOffset": 1601,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(m_upper, other.m_upper, other.upperSize()",
                    "rendered": {
                      "text": "memcpy(m_upper, other.m_upper, other.upperSize()",
                      "markdown": "`memcpy(m_upper, other.m_upper, other.upperSize()`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1601,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_upper, <size of m_upper>,  other.m_upper,  other.upperSize()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0440a437-85d5-3054-94b8-f061ee89264f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 8,
                  "endLine": 60,
                  "endColumn": 65,
                  "charOffset": 1533,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(m_diag, other.m_diag, m_diagSize * sizeof (Scalar)",
                    "rendered": {
                      "text": "memcpy(m_diag, other.m_diag, m_diagSize * sizeof (Scalar)",
                      "markdown": "`memcpy(m_diag, other.m_diag, m_diagSize * sizeof (Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1533,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_diag, <size of m_diag>,  other.m_diag,  m_diagSize * sizeof (Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "414018d6-1d7d-3600-a5b1-281942e71a92",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineMatrix.h"
                },
                "region": {
                  "startLine": 669,
                  "startColumn": 12,
                  "endLine": 669,
                  "endColumn": 76,
                  "charOffset": 25263,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(m_rowStartIndex, other.m_rowStartIndex, (m_outerSize + 1)",
                    "rendered": {
                      "text": "memcpy(m_rowStartIndex, other.m_rowStartIndex, (m_outerSize + 1)",
                      "markdown": "`memcpy(m_rowStartIndex, other.m_rowStartIndex, (m_outerSize + 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineMatrix.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25263,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_rowStartIndex, <size of m_rowStartIndex>,  other.m_rowStartIndex,  (m_outerSize + 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e0c3adf1-534a-39e5-9bb6-ec29495650a5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 8,
                  "endLine": 62,
                  "endColumn": 56,
                  "charOffset": 1678,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(m_lower, other.m_lower, other.lowerSize()",
                    "rendered": {
                      "text": "memcpy(m_lower, other.m_lower, other.lowerSize()",
                      "markdown": "`memcpy(m_lower, other.m_lower, other.lowerSize()`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1678,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_lower, <size of m_lower>,  other.m_lower,  other.lowerSize()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2d6496ce-8375-3bf1-8a13-d9cf924390a2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/MathFunctions.h"
                },
                "region": {
                  "startLine": 907,
                  "startColumn": 24,
                  "endLine": 907,
                  "endColumn": 29,
                  "charOffset": 26919,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "dd966dd2-8711-3d23-ab3b-0398ff4519ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Skyline/SkylineMatrix.h"
                },
                "region": {
                  "startLine": 668,
                  "startColumn": 12,
                  "endLine": 668,
                  "endColumn": 76,
                  "charOffset": 25167,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(m_colStartIndex, other.m_colStartIndex, (m_outerSize + 1)",
                    "rendered": {
                      "text": "memcpy(m_colStartIndex, other.m_colStartIndex, (m_outerSize + 1)",
                      "markdown": "`memcpy(m_colStartIndex, other.m_colStartIndex, (m_outerSize + 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/Skyline/SkylineMatrix.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25167,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_colStartIndex, <size of m_colStartIndex>,  other.m_colStartIndex,  (m_outerSize + 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "725c3ead-87b0-3080-bb80-6258edcd0001",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/NumTraits.h"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 2,
                  "endLine": 98,
                  "endColumn": 35,
                  "charOffset": 3070,
                  "charLength": 33,
                  "snippet": {
                    "text": "memcpy(&tgt, &staged, sizeof(Tgt)",
                    "rendered": {
                      "text": "memcpy(&tgt, &staged, sizeof(Tgt)",
                      "markdown": "`memcpy(&tgt, &staged, sizeof(Tgt)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/NumTraits.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3070,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tgt, <size of &tgt>,  &staged,  sizeof(Tgt)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6680d9e3-8ea2-3a93-a749-e1686e692ef7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/MathFunctions.h"
                },
                "region": {
                  "startLine": 902,
                  "startColumn": 54,
                  "endLine": 902,
                  "endColumn": 62,
                  "charOffset": 26638,
                  "charLength": 8,
                  "snippet": {
                    "text": "RAND_MAX",
                    "rendered": {
                      "text": "RAND_MAX",
                      "markdown": "`RAND_MAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e80fbf39-1012-37f3-a2e6-c0cb8b6589ee",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/MathFunctions.h"
                },
                "region": {
                  "startLine": 887,
                  "startColumn": 30,
                  "endLine": 887,
                  "endColumn": 38,
                  "charOffset": 26126,
                  "charLength": 8,
                  "snippet": {
                    "text": "RAND_MAX",
                    "rendered": {
                      "text": "RAND_MAX",
                      "markdown": "`RAND_MAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "034e0f37-b617-3f3b-b4ab-4f4ba8c9a368",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/MathFunctions.h"
                },
                "region": {
                  "startLine": 892,
                  "startColumn": 30,
                  "endLine": 892,
                  "endColumn": 35,
                  "charOffset": 26337,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "783192ee-66ee-3105-b824-2789aae99359",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/IterativeSolvers/BiCGSTABL.h"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 35,
                  "endLine": 74,
                  "endColumn": 42,
                  "charOffset": 3209,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "d90045bc-f037-305a-9d7f-794a07eb5b9f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/IterativeSolvers/IDRSTABL.h"
                },
                "region": {
                  "startLine": 204,
                  "startColumn": 59,
                  "endLine": 204,
                  "endColumn": 66,
                  "charOffset": 7500,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "bea50275-bf91-35f5-9d20-2a5f5e3ac6c2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/IterativeSolvers/IDRS.h"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 55,
                  "endLine": 76,
                  "endColumn": 62,
                  "charOffset": 3197,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "67e52466-91ce-3aa0-ab73-8a6b3274c00a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 9,
                  "endLine": 40,
                  "endColumn": 15,
                  "charOffset": 1444,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b429276c-c32c-3f98-afce-603695b3c432",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 9,
                  "endLine": 37,
                  "endColumn": 15,
                  "charOffset": 1240,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bf85f604-d246-36da-a767-ef536fa1c594",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 9,
                  "endLine": 34,
                  "endColumn": 15,
                  "charOffset": 1083,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7d18cb29-690e-3dc2-9a3e-32fa8aa048b9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 9,
                  "endLine": 31,
                  "endColumn": 15,
                  "charOffset": 940,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "44afb113-db3a-3769-82d7-69ca3a9a191c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 41,
                  "endLine": 9,
                  "endColumn": 59,
                  "charOffset": 407,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/SparseExtra/MarketIO.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 407,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "64b8b755-45bf-37ef-a814-4e47b011ed1d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/Random.h"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 17,
                  "endLine": 134,
                  "endColumn": 24,
                  "charOffset": 4918,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "14ccfd3a-9b8d-3378-979d-0ee031f4e4a5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/Random.h"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 20,
                  "endLine": 57,
                  "endColumn": 27,
                  "charOffset": 2056,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "36f1d284-de53-34cf-bef9-998caf7b8e5d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/Random.h"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 20,
                  "endLine": 88,
                  "endColumn": 27,
                  "charOffset": 3252,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a39a4d16-994f-344d-8072-c1b25d15b76b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h"
                },
                "region": {
                  "startLine": 701,
                  "startColumn": 8,
                  "endLine": 701,
                  "endColumn": 86,
                  "charOffset": 27095,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(&(m_values[nz_marker]), it->value().data(), block_size * sizeof(Scalar)",
                    "rendered": {
                      "text": "memcpy(&(m_values[nz_marker]), it->value().data(), block_size * sizeof(Scalar)",
                      "markdown": "`memcpy(&(m_values[nz_marker]), it->value().data(), block_size * sizeof(Scalar)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27095,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&(m_values[nz_marker]), <size of &(m_values[nz_marker])>,  it->value().data(),  block_size * sizeof(Scalar)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ab077fa8-f208-384b-996d-ee1bc4b048ab",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/DenseBase.h"
                },
                "region": {
                  "startLine": 558,
                  "startColumn": 34,
                  "endLine": 558,
                  "endColumn": 41,
                  "charOffset": 25260,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "76e93c0a-7054-39ca-b105-374641a78dd5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/DenseBase.h"
                },
                "region": {
                  "startLine": 557,
                  "startColumn": 34,
                  "endLine": 557,
                  "endColumn": 41,
                  "charOffset": 25194,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a44457c5-322e-34c9-a5e4-0eb015908a29",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured URL Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/DenseStorage.h"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 15,
                  "endLine": 81,
                  "endColumn": 41,
                  "charOffset": 3113,
                  "charLength": 26,
                  "snippet": {
                    "text": "http://eigen.tuxfamily.org",
                    "rendered": {
                      "text": "http://eigen.tuxfamily.org",
                      "markdown": "`http://eigen.tuxfamily.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/DenseStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3113,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "https://eigen.tuxfamily.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "597f8468-7c7f-3ccd-b886-e98161e70098",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured URL Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Eigen/src/Core/DenseStorage.h"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 15,
                  "endLine": 75,
                  "endColumn": 41,
                  "charOffset": 2747,
                  "charLength": 26,
                  "snippet": {
                    "text": "http://eigen.tuxfamily.org",
                    "rendered": {
                      "text": "http://eigen.tuxfamily.org",
                      "markdown": "`http://eigen.tuxfamily.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "Eigen/src/Core/DenseStorage.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2747,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "https://eigen.tuxfamily.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "d352f1db-f775-3372-90a4-1e5b9cf45471",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/doc/examples/MatrixSine.cpp"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 25,
                  "endLine": 8,
                  "endColumn": 32,
                  "charOffset": 128,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "c32e1388-7014-3347-8595-997bece32718",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/doc/examples/MatrixSinh.cpp"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 25,
                  "endLine": 8,
                  "endColumn": 32,
                  "charOffset": 128,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "c77cd837-3623-32ca-a6dd-750d3cd36b0c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h"
                },
                "region": {
                  "startLine": 385,
                  "startColumn": 14,
                  "endLine": 385,
                  "endColumn": 18,
                  "charOffset": 16066,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "de9d29a5-c4a0-36fd-8dd5-841f78f937e7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_compute_MatrixType2.cpp"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 14,
                  "endLine": 3,
                  "endColumn": 21,
                  "charOffset": 82,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "bf92539b-f315-30c1-931b-29bfcc1a6042",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Vectorwise_reverse.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "714bf76d-5a5b-3429-9e25-849a759ad327",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/tut_arithmetic_transpose_conjugate.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "5ff775c3-543d-3fa5-9c65-1ceb1c27f40d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/HessenbergDecomposition_packedMatrix.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "9447cf9d-7654-38c5-962b-5691c2ac66ff",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_compute_MatrixType2.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "f401c856-320f-35bd-b9dc-b479841bb85d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 14,
                  "endLine": 4,
                  "endColumn": 21,
                  "charOffset": 152,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "6fe7c369-a1a2-32c3-ad0a-b02ab91f3e18",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "527eaa60-b063-38cc-9fb2-89b0a2d5b169",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tridiagonalization_decomposeInPlace.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "2af9ebd1-f815-31ba-8447-b4bff7e24365",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_random_int_int.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 18,
                  "endLine": 1,
                  "endColumn": 25,
                  "charOffset": 18,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "78f1867a-2c10-3292-9d02-2620d162fec5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_reverse.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0c449cd9-8b70-3972-bed6-4ddf445882e5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_compute_MatrixType.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 63,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "91454575-edd8-3c7a-a5fc-8af75f943902",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/HouseholderQR_householderQ.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 21,
                  "endLine": 1,
                  "endColumn": 28,
                  "charOffset": 21,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "7d986658-9dda-3b4e-91a2-9736fa4383fb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/HessenbergDecomposition_compute.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0fb17a26-8830-3ab1-b665-25ea612d9b1f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "fa22f8e7-9067-344f-a6d8-b56508d785a7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/DirectionWise_hnormalized.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "7c2b7708-e7f4-352c-ac5b-9cbe58a5cf2c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/RealSchur_RealSchur_MatrixType.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "c3c96ce3-3521-3167-a7f7-7318e4e59a58",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Slicing_rawarray_cxx11.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0ee3343a-3c18-34c0-80f0-7f3447a0dbc1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tridiagonalization_compute.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 57,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a812ceda-ac2b-3a8d-86b3-bf5845f57074",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/HessenbergDecomposition_matrixH.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e45ede20-ba7d-3ade-83fb-5ffd95bd2f4b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/libs/BLAS/blas_interface_impl.hh"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 23,
                  "endLine": 105,
                  "endColumn": 29,
                  "charOffset": 3776,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4be47059-21bd-3233-9816-58e00783422e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/ComplexEigenSolver_compute.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "00b1f2a5-2444-3e5c-a2ce-99849cd4cf3d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_random_int.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 18,
                  "endLine": 1,
                  "endColumn": 25,
                  "charOffset": 18,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0504c979-3e1f-38ab-abd3-5ff0137680c1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/libs/BLAS/blas_interface_impl.hh"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 23,
                  "endLine": 104,
                  "endColumn": 29,
                  "charOffset": 3730,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cf3fe8e2-62ce-3533-aef0-1774775e70c7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/libs/BLAS/blas_interface_impl.hh"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 23,
                  "endLine": 79,
                  "endColumn": 29,
                  "charOffset": 2722,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bdb083fc-006b-3351-8586-223120398812",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/ComplexSchur_matrixU.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "925846aa-f227-3784-bad2-73d4e4e56301",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/data/smooth.cxx"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 24,
                  "endLine": 49,
                  "endColumn": 28,
                  "charOffset": 1895,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "53d51183-2beb-3750-98b9-b0d118d2d29c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_replicate.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "28227fc5-f89d-3fda-a491-0752aebcc272",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/data/regularize.cxx"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 20,
                  "endLine": 49,
                  "endColumn": 24,
                  "charOffset": 1775,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cb19944e-54b7-348b-a71f-8369c4ca2831",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/data/regularize.cxx"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 21,
                  "endLine": 48,
                  "endColumn": 25,
                  "charOffset": 1740,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6df0f168-f792-3f79-beaf-bf92ac351b32",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/LeastSquaresQR.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 60,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a24a5345-a860-32e6-9dbf-bc2bd5801cda",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/LeastSquaresQR.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "3785b26f-4afb-3179-b50a-27d93d06f441",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Slicing_arrayexpr.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 55,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "06928318-f5f3-3e22-ae47-f7c35fd15023",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/DirectionWise_replicate.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "70cb10f6-4c15-3de4-a030-47b4a8996f74",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/data/mean.cxx"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 19,
                  "endLine": 74,
                  "endColumn": 23,
                  "charOffset": 2370,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d331582f-5ff7-3b7a-9d69-6ce43eb9f693",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/VectorwiseOp_homogeneous.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "c6a0f325-bdc0-31da-af35-00d5fe46d18a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/data/mean.cxx"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 23,
                  "endLine": 76,
                  "endColumn": 27,
                  "charOffset": 2446,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "63942f60-be83-3c1d-947d-7cf4d22e915b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/data/mean.cxx"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 23,
                  "endLine": 75,
                  "endColumn": 27,
                  "charOffset": 2408,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b5cba995-ae0b-3e70-9483-97be5c4b81e9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/data/mean.cxx"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 19,
                  "endLine": 73,
                  "endColumn": 23,
                  "charOffset": 2336,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "58d0b67b-2ba5-3f2a-b37c-645aa90c423e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tutorial_AdvancedInitialization_CommaTemporary.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "4dd2ee8c-1ff6-3a04-a73a-a67708c6157b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/ComplexSchur_compute.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e15d867e-6093-386e-a1f8-210795c29e4e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/EigenSolver_pseudoEigenvectors.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "098997c9-a126-3a89-839b-3628090fd608",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 60,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "7b829881-e339-34ea-a081-fde268c00cd4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/generic_bench/btl.hh"
                },
                "region": {
                  "startLine": 194,
                  "startColumn": 27,
                  "endLine": 194,
                  "endColumn": 31,
                  "charOffset": 5717,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cbe6ce47-848d-3923-ba75-55a472ce43a1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/btl/generic_bench/btl.hh"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 14,
                  "endLine": 170,
                  "endColumn": 20,
                  "charOffset": 4995,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c76f7b2c-662c-35b8-833a-15889e017eb6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/RealQZ_compute.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 59,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e5b5b358-0a2d-328e-896c-a6277b3c5138",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/RealQZ_compute.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "161e81a7-40ad-3e46-9dea-f0b47d07fd99",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "ea1fc4a1-7003-3eca-b45d-2798857144b0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/bench/bench_svd.cpp"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 29,
                  "endLine": 36,
                  "endColumn": 36,
                  "charOffset": 1053,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "43f9b1eb-5299-303b-8cd2-435bf00d1ab3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "unsupported/bench/bench_svd.cpp"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 41,
                  "endLine": 11,
                  "endColumn": 59,
                  "charOffset": 524,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "unsupported/bench/bench_svd.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 524,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "706de43f-f56f-3aef-8480-f4316bf81416",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/PartialPivLU_solve.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 59,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "4b2a7cdd-cdeb-3eb1-b262-ef86e5f9ee76",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/PartialPivLU_solve.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "ab4e11b4-c527-3070-b34d-f90bed0219c6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_operatorSqrt.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "fa8c6851-73b7-315b-84ee-697f2d92ceeb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/mix_eigen_and_c/example.c"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 329,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "demos/mix_eigen_and_c/example.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 329,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "1a272e94-1c6e-39ba-a6b7-f9587080801b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Slicing_stdvector_cxx11.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 56,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "6d9deb45-2e85-3c57-8107-2c32d0a5aaed",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/FullPivLU_kernel.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "b178abdc-3936-3754-9d61-fe4dec39fd89",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/SelfAdjointEigenSolver_operatorInverseSqrt.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "ea12388b-7d71-3a70-a760-710c99e53396",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/TutorialLinAlgSVDSolve.cpp"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 40,
                  "endLine": 8,
                  "endColumn": 47,
                  "charOffset": 212,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "ee7756ca-f9d8-3213-b4a5-fb53e16a7fd5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/nullary_indexing.cpp"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 39,
                  "endLine": 43,
                  "endColumn": 46,
                  "charOffset": 1634,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "648c2e6b-3157-3d47-9b25-831a0d56ecf1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/ComplexSchur_matrixT.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a07b42de-b2d7-31d5-8873-02551f8eb5e0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/TutorialLinAlgSVDSolve.cpp"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 40,
                  "endLine": 6,
                  "endColumn": 47,
                  "charOffset": 97,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e7458822-a60b-311d-adf2-f20b41787544",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/Tutorial_ArrayClass_cwise_other.cpp"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 37,
                  "endLine": 6,
                  "endColumn": 44,
                  "charOffset": 94,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "9a6b7b4d-c0ca-3b15-b914-a0084ae00190",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/matrixfree_cg.cpp"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 51,
                  "endLine": 85,
                  "endColumn": 58,
                  "charOffset": 2746,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "86481644-aff6-32d4-a362-0fa34f953f32",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/tensors/benchmark_main.cc"
                },
                "region": {
                  "startLine": 213,
                  "startColumn": 38,
                  "endLine": 213,
                  "endColumn": 63,
                  "charOffset": 6039,
                  "charLength": 25,
                  "snippet": {
                    "text": "strlen(it->second->Name()",
                    "rendered": {
                      "text": "strlen(it->second->Name()",
                      "markdown": "`strlen(it->second->Name()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/tensors/benchmark_main.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6039,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strlen_s(it->second->Name(, <size of it->second->Name(>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/tensors/benchmark_main.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6039,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strnlen(it->second->Name(, <size of it->second->Name(>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "00718a42-c756-3907-a2d8-840092bd0411",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/fullpivlu_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 80,
                  "endLine": 13,
                  "endColumn": 87,
                  "charOffset": 229,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a8afcc76-461a-36cf-ab51-df0023400e14",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_cwiseArg.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "83ecaa1e-8de2-32d4-83b8-d77ffbe0d269",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tridiagonalization_diagonal.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 25,
                  "endLine": 1,
                  "endColumn": 32,
                  "charOffset": 25,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "3471d5e3-4d6d-3d34-af3b-8d71aa3f1190",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/TutorialLinAlgExComputeSolveError.cpp"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 26,
                  "endLine": 9,
                  "endColumn": 33,
                  "charOffset": 150,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "8fb2a1b9-8342-37ef-a570-3b8d17f41443",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/TutorialLinAlgExComputeSolveError.cpp"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 26,
                  "endLine": 8,
                  "endColumn": 33,
                  "charOffset": 107,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "24fa4720-14b0-3455-9dca-1d5d053c43ce",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tridiagonalization_householderCoefficients.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "3fa73e0f-3cf0-313d-96f3-27b282a1c078",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/fullpivqr_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 91,
                  "endLine": 13,
                  "endColumn": 98,
                  "charOffset": 240,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "24f84c2d-d1ec-3348-8dd4-e884aa387a61",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/bdcsvd_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 77,
                  "endLine": 13,
                  "endColumn": 84,
                  "charOffset": 227,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "72565025-f622-331a-ae4b-f7cf0e019e7c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/eigensolver_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 83,
                  "endLine": 13,
                  "endColumn": 90,
                  "charOffset": 241,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "fdd37cc0-b0df-3a2d-ba8a-7b646c0c8be7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/qr_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 84,
                  "endLine": 13,
                  "endColumn": 91,
                  "charOffset": 233,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "abb149b6-1b05-34b7-bcee-e661ee03d126",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/llt_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 75,
                  "endLine": 13,
                  "endColumn": 82,
                  "charOffset": 230,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "91774497-19f9-3004-ae28-7a8c908c4689",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/eigensolver_cplx.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 83,
                  "endLine": 13,
                  "endColumn": 90,
                  "charOffset": 258,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "8581efbd-3748-3d47-b796-084855972a13",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/tensors/tensor_benchmarks.h"
                },
                "region": {
                  "startLine": 205,
                  "startColumn": 28,
                  "endLine": 205,
                  "endColumn": 36,
                  "charOffset": 7127,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "95ecab2e-9c6b-3280-bedb-4e67be232fde",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/tensors/tensor_benchmarks.h"
                },
                "region": {
                  "startLine": 200,
                  "startColumn": 28,
                  "endLine": 200,
                  "endColumn": 36,
                  "charOffset": 6989,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "ee9fb880-1917-3a6a-85be-b1cc78bc9142",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/jacobisvd_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 80,
                  "endLine": 13,
                  "endColumn": 87,
                  "charOffset": 230,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "6be9ff3a-f245-3b77-ade3-fda20d6cf221",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Cwise_arg.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "308efe6a-a341-3b83-a6c2-7bc8fb1927d4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tridiagonalization_Tridiagonalization_MatrixType.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "c07f7da2-ecef-30e1-9914-c280f5d93407",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/partialpivlu_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 83,
                  "endLine": 13,
                  "endColumn": 90,
                  "charOffset": 232,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "c0d6671f-e8fb-3535-a2dd-2b96f12bb493",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/tensors/tensor_benchmarks.h"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 7,
                  "endLine": 45,
                  "endColumn": 48,
                  "charOffset": 1034,
                  "charLength": 197,
                  "snippet": {
                    "text": "memcpy(int num_iters) {\n    eigen_assert(m_ == k_ && k_ == n_);\n#ifdef EIGEN_USE_SYCL // warmup for sycl\n    for (int iter = 0; iter < 10; ++iter) {\n      device_.memcpy(c_, a_, m_ * m_ * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(int num_iters) {\n    eigen_assert(m_ == k_ && k_ == n_);\n#ifdef EIGEN_USE_SYCL // warmup for sycl\n    for (int iter = 0; iter < 10; ++iter) {\n      device_.memcpy(c_, a_, m_ * m_ * sizeof(T)",
                      "markdown": "`memcpy(int num_iters) {\n    eigen_assert(m_ == k_ && k_ == n_);\n#ifdef EIGEN_USE_SYCL // warmup for sycl\n    for (int iter = 0; iter < 10; ++iter) {\n      device_.memcpy(c_, a_, m_ * m_ * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/tensors/tensor_benchmarks.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1034,
                        "charLength": 197
                      },
                      "insertedContent": {
                        "text": "memcpy_s(int num_iters) {\n    eigen_assert(m_ == k_ && k_ == n_);\n#ifdef EIGEN_USE_SYCL // warmup for sycl\n    for (int iter = 0; iter < 10; ++iter) {\n      device_.memcpy(c_, <size of int num_iters) {\n    eigen_assert(m_ == k_ && k_ == n_);\n#ifdef EIGEN_USE_SYCL // warmup for sycl\n    for (int iter = 0; iter < 10; ++iter) {\n      device_.memcpy(c_>,  a_,  m_ * m_ * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2c77ac38-9b3c-3f9a-a4a3-ad46ad8eb42e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/colpivqr_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 90,
                  "endLine": 13,
                  "endColumn": 97,
                  "charOffset": 239,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "bc90a1fe-b788-31b1-b59e-0bcdef091f3f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/BiCGSTAB_step_by_step.cpp"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 16,
                  "endLine": 7,
                  "endColumn": 23,
                  "charOffset": 196,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "4dfb7747-05b8-3fe6-a3f4-098857a63f3c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/sparse_cholesky.cpp"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 25,
                  "endLine": 85,
                  "endColumn": 32,
                  "charOffset": 2732,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0d603b02-21a6-3057-ba6c-050071a6591a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/tensors/tensor_benchmarks.h"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 14,
                  "endLine": 50,
                  "endColumn": 48,
                  "charOffset": 1340,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(c_, a_, m_ * m_ * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(c_, a_, m_ * m_ * sizeof(T)",
                      "markdown": "`memcpy(c_, a_, m_ * m_ * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/tensors/tensor_benchmarks.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1340,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c_, <size of c_>,  a_,  m_ * m_ * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c8741afe-95d7-35ef-83fa-8bf35aa18032",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/JacobiSVD_basic.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0a2ded21-5dde-3a1d-91ee-7d3419f5b74f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tridiagonalization_packedMatrix.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a6b83241-c500-3380-8524-4501ff856f5e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/sparse_cholesky.cpp"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 25,
                  "endLine": 84,
                  "endColumn": 32,
                  "charOffset": 2693,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "94738489-2106-3bd8-a3a7-ef39ad61bf04",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/LLT_solve.cpp"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 70,
                  "endLine": 4,
                  "endColumn": 77,
                  "charOffset": 248,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "097354a3-20bb-32a6-88c5-4e4ec9093d18",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/LLT_solve.cpp"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 33,
                  "endLine": 3,
                  "endColumn": 40,
                  "charOffset": 164,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "08af604d-5f6e-364c-a94b-25a12c6f49c1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "failtest/ldlt_int.cpp"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 77,
                  "endLine": 13,
                  "endColumn": 84,
                  "charOffset": 232,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "7b979444-c708-3887-bc3b-0e611050871b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/RealSchur_compute.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "d89002c3-5d02-3a30-aeb0-558db0a02469",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/sparse_trisolver.cpp"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 31,
                  "endLine": 66,
                  "endColumn": 38,
                  "charOffset": 1654,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "93243b6e-6c70-3b9a-bdf2-f7afcc7b12be",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/sparse_trisolver.cpp"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 31,
                  "endLine": 65,
                  "endColumn": 38,
                  "charOffset": 1609,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "37c8c6aa-9128-305b-9ab1-4dbd10f8cbab",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tutorial_SlicingCol.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 24,
                  "endLine": 1,
                  "endColumn": 31,
                  "charOffset": 24,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "f8b39d1f-245c-3c31-ac5c-039c0201b01f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_applyOnTheLeft.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "89004ba3-1e5f-3157-8d9a-952e909ce140",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchCholesky.cpp"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 29,
                  "endLine": 45,
                  "endColumn": 36,
                  "charOffset": 942,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "1ec81b03-f1fe-36b5-90c0-6b9ea0089d9a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchmark-blocking-sizes.cpp"
                },
                "region": {
                  "startLine": 528,
                  "startColumn": 4,
                  "endLine": 528,
                  "endColumn": 19,
                  "charOffset": 17285,
                  "charLength": 15,
                  "snippet": {
                    "text": "random_shuffle(",
                    "rendered": {
                      "text": "random_shuffle(",
                      "markdown": "`random_shuffle(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "b30876ee-e4c8-39ad-a86d-8d0c0d460737",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/tensors/tensor_contract_sycl_bench.cc"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 41,
                  "endLine": 12,
                  "endColumn": 59,
                  "charOffset": 442,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/tensors/tensor_contract_sycl_bench.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 442,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "9552c8bd-5c16-335e-a5f0-48a38041b154",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 178,
                  "startColumn": 17,
                  "endLine": 178,
                  "endColumn": 24,
                  "charOffset": 5002,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "9de72476-6f8c-3dad-b0e5-c0bd5e76dabd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchmark-blocking-sizes.cpp"
                },
                "region": {
                  "startLine": 363,
                  "startColumn": 15,
                  "endLine": 363,
                  "endColumn": 20,
                  "charOffset": 10937,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9cdc5be8-858b-351d-a608-8ea791399b08",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchmark-blocking-sizes.cpp"
                },
                "region": {
                  "startLine": 347,
                  "startColumn": 15,
                  "endLine": 347,
                  "endColumn": 20,
                  "charOffset": 10228,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e1d7d9e0-6be0-3a2b-8d46-f9967517349c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 17,
                  "endLine": 181,
                  "endColumn": 24,
                  "charOffset": 5080,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "8bb98f16-2aad-365d-8a8a-06d770940ce0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 17,
                  "endLine": 177,
                  "endColumn": 24,
                  "charOffset": 4972,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "16555058-ca36-36d6-9d17-84ccc9c5cde4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 17,
                  "endLine": 138,
                  "endColumn": 24,
                  "charOffset": 3901,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "f75d7b0d-5df9-35e3-91f1-5bdf488a3be1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 17,
                  "endLine": 137,
                  "endColumn": 24,
                  "charOffset": 3871,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "8cece632-1926-38d8-944e-352e0ce9fc01",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 17,
                  "endLine": 136,
                  "endColumn": 24,
                  "charOffset": 3841,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "64a54e90-e49b-3fad-9ea3-a817cb9e872a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 17,
                  "endLine": 105,
                  "endColumn": 24,
                  "charOffset": 2790,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "2b6a9a68-e718-3aa2-a494-fc09fd65b3a5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 17,
                  "endLine": 104,
                  "endColumn": 24,
                  "charOffset": 2760,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "77737424-0fa0-3a11-ba7a-c58da917a5f9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 17,
                  "endLine": 103,
                  "endColumn": 24,
                  "charOffset": 2730,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "e640ae1c-e595-3a4b-a97a-f4b6b3e4158a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 8,
                  "endLine": 75,
                  "endColumn": 12,
                  "charOffset": 1529,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ec9acaac-6d61-3545-a142-e2ae92d254d9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 8,
                  "endLine": 73,
                  "endColumn": 12,
                  "charOffset": 1483,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4419f75f-caa5-38b7-9652-f32844c99580",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 14,
                  "endLine": 77,
                  "endColumn": 18,
                  "charOffset": 1587,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0f2a42ef-70e3-3f4f-a2a6-1ee138cac2bf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 14,
                  "endLine": 76,
                  "endColumn": 18,
                  "charOffset": 1558,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fa663eb9-1798-325b-bc6b-33a4fb825295",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 8,
                  "endLine": 74,
                  "endColumn": 12,
                  "charOffset": 1506,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "01f91b8e-584e-3e6d-8ae7-1cb139fe8320",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 14,
                  "endLine": 69,
                  "endColumn": 18,
                  "charOffset": 1432,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4f215ecb-d884-396a-ab70-8cf0f90ac387",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 14,
                  "endLine": 68,
                  "endColumn": 18,
                  "charOffset": 1403,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ef4a0543-f378-3ca9-972f-87e7c7f949ff",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 16,
                  "endLine": 67,
                  "endColumn": 20,
                  "charOffset": 1374,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "03fdced5-ef41-3e4a-89cd-7092f259384e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 16,
                  "endLine": 59,
                  "endColumn": 20,
                  "charOffset": 1226,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "38dc4b96-1184-321a-b026-9149e3c840e8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchBlasGemm.cpp"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 18,
                  "endLine": 55,
                  "endColumn": 22,
                  "charOffset": 1131,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "03974536-a330-3446-8f71-ce598e519834",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tutorial_std_sort_rows_cxx11.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "5e47bb2f-e16d-3530-b450-325d97b0daee",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/GeneralizedEigenSolver.cpp"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 23,
                  "endLine": 3,
                  "endColumn": 30,
                  "charOffset": 97,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "4f93962c-0bc5-349f-a6b4-1bb0fc9d6266",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/GeneralizedEigenSolver.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 61,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "47ea0e79-3483-3e7a-8c8e-1a52cbb928a5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/Tutorial_range_for_loop_1d_cxx11.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "94c3e479-26ff-3629-93f2-1d0e6cbc24cf",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_norm.cpp"
                },
                "region": {
                  "startLine": 350,
                  "startColumn": 31,
                  "endLine": 350,
                  "endColumn": 38,
                  "charOffset": 11378,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "1b411abb-72ec-3b67-8df3-727f1b309eef",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_norm.cpp"
                },
                "region": {
                  "startLine": 349,
                  "startColumn": 28,
                  "endLine": 349,
                  "endColumn": 35,
                  "charOffset": 11330,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "10b82f67-09bc-332f-92e9-07899f1e6c6c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_norm.cpp"
                },
                "region": {
                  "startLine": 348,
                  "startColumn": 28,
                  "endLine": 348,
                  "endColumn": 35,
                  "charOffset": 11285,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "25727863-034b-3b66-827a-e4a4dded7bcb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_norm.cpp"
                },
                "region": {
                  "startLine": 333,
                  "startColumn": 28,
                  "endLine": 333,
                  "endColumn": 35,
                  "charOffset": 10879,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "0dd1452b-a451-33a4-9808-edfc60e4f47a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_norm.cpp"
                },
                "region": {
                  "startLine": 332,
                  "startColumn": 28,
                  "endLine": 332,
                  "endColumn": 35,
                  "charOffset": 10835,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "c480699e-13f3-3164-9375-b73cb332121e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/MatrixBase_applyOnTheRight.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "2f218259-7d19-3a51-a3ee-374377139daf",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/EigenSolver_compute.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 49,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "3d21ef16-2371-3782-8ace-b2e54c4dacc1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_norm.cpp"
                },
                "region": {
                  "startLine": 334,
                  "startColumn": 31,
                  "endLine": 334,
                  "endColumn": 38,
                  "charOffset": 10926,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "95b54056-e235-3c09-9c77-95c619c8c0ca",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spbench/spbenchstyle.h"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 17,
                  "endLine": 16,
                  "endColumn": 34,
                  "charOffset": 537,
                  "charLength": 17,
                  "snippet": {
                    "text": "http://www.w3.org",
                    "rendered": {
                      "text": "http://www.w3.org",
                      "markdown": "`http://www.w3.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/spbench/spbenchstyle.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 537,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "https://www.w3.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "77699200-467d-3838-9add-d606bdde9c24",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/analyze-blocking-sizes.cpp"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 41,
                  "endLine": 8,
                  "endColumn": 59,
                  "charOffset": 327,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://mozilla.org",
                    "rendered": {
                      "text": "http://mozilla.org",
                      "markdown": "`http://mozilla.org`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/analyze-blocking-sizes.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 327,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://mozilla.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "8c038c8f-3f8d-3b98-baa8-58ff220e4fb7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/LeastSquaresNormalEquations.cpp"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 23,
                  "endLine": 2,
                  "endColumn": 30,
                  "charOffset": 60,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "6991f353-ccec-3a54-af8e-c679ed1ce1fc",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/snippets/LeastSquaresNormalEquations.cpp"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 23,
                  "endLine": 1,
                  "endColumn": 30,
                  "charOffset": 23,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "76950ba3-68c9-331a-b409-8279f9532f74",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/sparse_lu.cpp"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 23,
                  "endLine": 80,
                  "endColumn": 30,
                  "charOffset": 1566,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "fc4c2d1d-8231-35f3-9c34-78d20baeb541",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/sparse_lu.cpp"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 23,
                  "endLine": 79,
                  "endColumn": 30,
                  "charOffset": 1529,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "5fabfc48-2c41-3059-bdc6-c846d03b6a34",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_gemm.cpp"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 14,
                  "endLine": 220,
                  "endColumn": 18,
                  "charOffset": 5355,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7572439c-c1c5-366a-a085-229467a8193e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_gemm.cpp"
                },
                "region": {
                  "startLine": 214,
                  "startColumn": 16,
                  "endLine": 214,
                  "endColumn": 20,
                  "charOffset": 5251,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0f7549f7-4fca-341c-bc64-51fba43de644",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_gemm.cpp"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 26,
                  "endLine": 209,
                  "endColumn": 30,
                  "charOffset": 5161,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "32f10a8a-c451-37f5-a2fb-c66cf63b72f0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_gemm.cpp"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 24,
                  "endLine": 207,
                  "endColumn": 28,
                  "charOffset": 5088,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3f3d2b82-6e89-31cd-a459-18b892e94b4b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_gemm.cpp"
                },
                "region": {
                  "startLine": 204,
                  "startColumn": 22,
                  "endLine": 204,
                  "endColumn": 26,
                  "charOffset": 5009,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f6ae180e-ba3e-30d6-a3c0-982788832e72",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/benchEigenSolver.cpp"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 29,
                  "endLine": 45,
                  "endColumn": 36,
                  "charOffset": 959,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "2103a41d-4990-35f3-90d1-5d11ac8623b6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_gemm.cpp"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 12,
                  "endLine": 193,
                  "endColumn": 16,
                  "charOffset": 4777,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d618f82c-97f9-39c6-9589-3ec6e0b57e21",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/eig33.cpp"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 15,
                  "endLine": 172,
                  "endColumn": 22,
                  "charOffset": 6413,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "62202346-6999-3e85-a3bc-83d8e32ad9ab",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/QuickStart_example2_dynamic.cpp"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 25,
                  "endLine": 9,
                  "endColumn": 32,
                  "charOffset": 129,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "bc6866bc-b799-3f79-8b5e-34f4057d00d1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spmv.cpp"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 16,
                  "endLine": 67,
                  "endColumn": 20,
                  "charOffset": 1696,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f446bb40-b227-37b6-8764-6363b4d2baaa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spmv.cpp"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 14,
                  "endLine": 63,
                  "endColumn": 18,
                  "charOffset": 1620,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "aa700e41-9dfc-3928-9a04-7021de01c49e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_gemm.cpp"
                },
                "region": {
                  "startLine": 198,
                  "startColumn": 14,
                  "endLine": 198,
                  "endColumn": 18,
                  "charOffset": 4900,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1b894452-c5c4-3d2d-b5d8-3c8733872eb8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_gemm.cpp"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 14,
                  "endLine": 197,
                  "endColumn": 18,
                  "charOffset": 4869,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "85240ec2-7e7c-35da-ab87-e01e1d6ce763",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spmv.cpp"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 13,
                  "endLine": 51,
                  "endColumn": 17,
                  "charOffset": 1395,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "150cec58-14ab-31d6-82e1-80184accdff9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/function_taking_ref.cpp"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 39,
                  "endLine": 12,
                  "endColumn": 46,
                  "charOffset": 281,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "8057f00e-e347-3063-8527-6253d21e26a1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/TemplateKeyword_simple.cpp"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 26,
                  "endLine": 14,
                  "endColumn": 33,
                  "charOffset": 289,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "583fc1bc-f954-3ac1-8399-5d0ebef0030a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_reverse.cpp"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 29,
                  "endLine": 26,
                  "endColumn": 36,
                  "charOffset": 487,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "48ce1b28-9f98-3139-8761-68eecfbfc924",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_reverse.cpp"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 29,
                  "endLine": 25,
                  "endColumn": 36,
                  "charOffset": 439,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "7bc05f28-9852-399e-bcd6-4426426119f4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "doc/examples/TemplateKeyword_flexible.cpp"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 40,
                  "endLine": 14,
                  "endColumn": 47,
                  "charOffset": 457,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a9838cb1-5b60-3c0c-b440-6aeb9ebe0ada",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spbench/spbenchsolver.cpp"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 10,
                  "endLine": 65,
                  "endColumn": 14,
                  "charOffset": 2686,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3d6c53a3-b477-37ff-af18-6b25f296d7e6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spmv.cpp"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 18,
                  "endLine": 59,
                  "endColumn": 22,
                  "charOffset": 1546,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e1e7ca87-8448-3f14-8a50-845f6376fad9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spmv.cpp"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 13,
                  "endLine": 55,
                  "endColumn": 17,
                  "charOffset": 1468,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1e6f3a4e-a188-3ef3-8b3f-797f713e15af",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Code Debugging Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "scripts/eigen_gen_credits.cpp"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 22,
                  "endLine": 19,
                  "endColumn": 31,
                  "charOffset": 496,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "46905281-7504-3b21-85b8-6c04f836ba35",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spbench/spbenchsolver.cpp"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 15,
                  "endLine": 67,
                  "endColumn": 19,
                  "charOffset": 2773,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "24e27ff7-8169-3249-83d7-7bee18663005",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spbench/spbenchsolver.cpp"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 17,
                  "endLine": 40,
                  "endColumn": 23,
                  "charOffset": 2024,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "55df8ab7-afc3-35b4-bd9d-6cf329fe7001",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/spbench/spbenchsolver.cpp"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 7,
                  "endLine": 35,
                  "endColumn": 13,
                  "charOffset": 1728,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}